MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "07 de marzo de 2021" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "14H02" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Log de entrenamiento";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* Log de entrenamiento
Fecha:                07 de marzo de 2021
Hora:                14H02
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O2GY8WUF "C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O2GY8WUF new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "07 de marzo de 2021" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "14H02" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "Usuario:                Jose Caloca";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "Sitio:                70115216";
MPRINT(EM_DIAGRAM):   put "Plataforma:            X64_10PRO";
MPRINT(EM_DIAGRAM):   put "Versión de mantenimiento: 9.04.01M6P111518";
MPRINT(EM_DIAGRAM):   put "Versión de EM:          15.1";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "07 de marzo de 2021" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "14H02" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "Usuario:                Jose Caloca";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Salida de entrenamiento";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Salida de puntuación";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Salida del informe";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
24189      proc freq data=EMWS1.VarClus_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS1.VarClus_VariableSet noprint;
24190      table ROLE*LEVEL/out=WORK.VarClusMETA;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.VarClusMETA;
24191      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 11 observations read from the data set EMWS1.VARCLUS_VARIABLESET.
NOTE: The data set WORK.VARCLUSMETA has 5 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.07 seconds
      cpu time            0.03 seconds
      

24192      proc print data=WORK.VarClusMETA label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.VarClusMETA label noobs;
24193      var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
24194      label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "Rol" LEVEL = "Nivel de medida" COUNT = "Número de ocurrencias";
24195      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
24196      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "Resumen de variables";
MPRINT(EM_DIAGRAM):   run;
24197      run;

NOTE: There were 5 observations read from the data set WORK.VARCLUSMETA.
NOTE: The PROCEDURE PRINT printed page 1.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

24198      title10;
MPRINT(EM_DIAGRAM):   title10;
24199      %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * VarClus: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * VarClus: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'DM_ang';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'introduction';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   set EMWS1.Ids_EMINFO;
MPRINT(EM_DIAGRAM):   where key in('HPDMSAMPLE', 'IDSTABLE');
MPRINT(EM_DIAGRAM):   if key = 'HPDMSAMPLE' then call symput('_ForceGrid', '1');
MPRINT(EM_DIAGRAM):   else call symput('_IDS_TABLE', DATA);
MPRINT(EM_DIAGRAM):   run;
MPRINT(HPDM_PERFORMANCE):  ;
PERFORMANCE  DETAILS
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
24553      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
24554      * VarClus: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * VarClus: Generation of macros and macro variables;
24555      * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
24556      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;

24557      %let EMEXCEPTIONSTRING=;
24558      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
24559      * TRAIN: VarClus;
MPRINT(EM_DIAGRAM):   * TRAIN: VarClus;
24560      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
24561      %let EM_ACTION = TRAIN;
24562      %let syscc = 0;
24563      
24564      %macro main;
24565      
24566         filename temp catalog 'sashelp.emexpl.variableclustering_macros.source';
24567         %include temp;
24568         filename temp catalog 'sashelp.emexpl.variableclustering_macros2.source';
24569         %include temp;
24570         filename temp;
24571      
24572        %SetProperties;
24573      
24574         %if %upcase(&EM_ACTION) = CREATE %then %do;
24575             filename temp catalog 'sashelp.emexpl.variableclustering_create.source';
24576             %include temp;
24577             filename temp;
24578             %create;
24579         %end;
24580         %else
24581         %if %upcase(&EM_ACTION) = TRAIN %then %do;
24582              filename temp catalog 'sashelp.emexpl.variableclustering_train.source';
24583                 %include temp;
24584                 filename temp;
24585                 %train;
24586         %end;
24587         %else
24588         %if %upcase(&EM_ACTION) = SCORE %then %do;
24589                 filename temp catalog 'sashelp.emexpl.variableclustering_score.source';
24590                 %include temp;
24591                 filename temp;
24592                 %score;
24593         %end;
24594         %else
24595         %if %upcase(&EM_ACTION) = REPORT %then %do;
24596                 filename temp catalog 'sashelp.emexpl.variableclustering_report.source';
24597                 %include temp;
24598                 filename temp;
24599                 %report;
24600         %end;
24601         /*
24602         %if %upcase(&EM_ACTION) = OPENTESTTABLE %then %do;
24603             %put 'OPENING TABLE';
24604         %end;
24605         %if %upcase(&EM_ACTION) = CLOSETESTTABLE %then %do;
24606             %put 'CLOSE TABLE';
24607         %end;
24608         */
24609      %mend main;
24610      %main;
MPRINT(EM_DIAGRAM):    
MPRINT(MAIN):   filename temp catalog 'sashelp.emexpl.variableclustering_macros.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_MACROS.SOURCE.
24611     +
24612     +/* Initialize property macro variables */
24613     +%macro SetProperties;
24614     +   %em_checkmacro(name=EM_PROPERTY_MAXCLUS,       global=Y, value=DEFAULT);
24615     +   %em_checkmacro(name=EM_PROPERTY_HIDEVARIABLE,  global=Y, value=Y);
24616     +   %em_checkmacro(name=EM_PROPERTY_PRINTOPTION,   global=Y, value=SHORT);
24617     +   %em_checkmacro(name=EM_PROPERTY_CLUSSOURCE,    global=Y, value=CORR);
24618     +   %em_checkmacro(name=EM_PROPERTY_CLUSCOMP,      global=Y, value=PRINCIPAL);
24619     +   %em_checkmacro(name=EM_PROPERTY_CLUSHIERACHY,      global=Y, value=Y);
24620     +   %em_checkmacro(name=EM_PROPERTY_INCLUDECLASSVAR,      global=Y, value=N);
24621     +   %em_checkmacro(name=EM_PROPERTY_EXPORTEDCOMP,      global=Y, value=CLUSTERCOMP);
24622     +   %em_checkmacro(name=EM_PROPERTY_MAXEIGEN,         global=Y, value=DEFAULT);
24623     +   %em_checkmacro(name=EM_PROPERTY_PROPORTION,      global=Y, value=DEFAULT);
24624     +   %em_checkmacro(name=EM_PROPERTY_PRINTOPTION,      global=Y, value=SHORT);
24625     +   %em_checkmacro(name=EM_PROPERTY_TWOSTAGECLUS,      global=Y, value=AUTO);
24626     +   %em_checkmacro(name=EM_PROPERTY_SUPPRESSSAMPWARN,      global=Y, value=N);
24627     +
24628     +%mend SetProperties;
24629     +
24630     +%Macro MakeDummyVariables(indata=,
24631     +                          outvar=,
24632     +                          outdata=,
24633     +                          fileref=,
24634     +                          recreatecmeta=N, /* optional */
24635     +                          incmeta=,     /* optional */
24636     +                          outcmeta=,    /* optional */
24637     +                          ndummyvars=_ndummyvars
24638     +                          );
24639     +    %global &ndummyvars;
24640     +
24641     +    proc dmdb batch data=&indata out=_dmdbdat dmdbcat=_dmdbcat classout=_classout;;
24642     +       class
24643     +       %EM_BINARY_INPUT %EM_NOMINAL_INPUT %EM_ORDINAL_INPUT
24644     +       %EM_BINARY_REJECTED %EM_NOMINAL_REJECTED %EM_ORDINAL_REJECTED
24645     +    ;
24646     +    run;
24647     +    %let &ndummyvars = 0;
24648     +    data _null_;
24649     +    %let dsid = %sysfunc(open(work._classout));
24650     +      %let &ndummyvars = %sysfunc(attrn(&dsid, NOBS));
24651     +    %let dsid = %sysfunc(close(&dsid));
24652     +    run;
24653     +
24654     +    proc dmzip data=_dmdbdat dmdbcat=_dmdbcat;
24655     +       input
24656     +       %EM_BINARY_INPUT %EM_NOMINAL_INPUT %EM_ORDINAL_INPUT
24657     +       %EM_BINARY_REJECTED %EM_NOMINAL_REJECTED %EM_ORDINAL_REJECTED
24658     +        / level=nominal stdize=no;
24659     +       make outvar = &outvar;
24660     +       score data = &indata out =&outdata;
24661     +       code  file=  "&fileref";
24662     +    run;
24663     +    %if &recreatecmeta eq Y %then %do;
24664     +    proc contents data =&outvar out=_tmpds(keep=NAME LABEL);
24665     +    data _tmpds;
24666     +        set _tmpds;
24667     +           ROLE = 'INPUT';
24668     +           LEVEL = 'INTERVAL';
24669     +           CREATOR='DMZIP';
24670     +           if NAME = '_TYPE_' then delete;
24671     +    run;
24672     +    data &outcmeta;
24673     +         set &incmeta _tmpds;
24674     +    run;
24675     +    %end;
24676     +    proc datasets lib=work nolist;
24677     +      delete  _dmdbdat _dmdbcat _classout
24678     +    %if &recreatecmeta eq Y %then %do;
24679     +    _tmpds
24680     +    %end;
24681     +    ;
24682     +    quit;
24683     +%Mend MakeDummyVariables;
24684     +
24685     +/*--- Determine Optimal Number of Cluster ----
24686     +%macro FindClusNum(statds=, groupds=, minvariation=);
24687     +   %global optnclus;
24688     +   data varclus_tmp(drop=_NAME_);
24689     +      set &statDs;
24690     +      where _type_ ='PROPOR';
24691     +   run;
24692     +   proc sort data=varclus_tmp;
24693     +      by _NCL_;
24694     +   run;
24695     +   proc transpose data=varclus_tmp out=varclus_tmp;
24696     +      by _NCL_;
24697     +      var %EM_INTERVAL_INPUT
24698     +      %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
24699     +      %let dsid = %sysfunc(open(&EM_USER_OUTDUMMY));
24700     +      %let nvar = %sysfunc(attrn(&dsid, NVAR));
24701     +          %do i = 2 %to &nvar;
24702     +          %let varname = %sysfunc(varname(&dsid, &i));
24703     +          &varname
24704     +          %end;
24705     +      %end;
24706     +   ;
24707     +   run;
24708     +
24709     +   %if &minVariation eq %then %do;
24710     +       %let minVariation = &EM_PROPERTY_MINVARIATION;
24711     +   %end;
24712     +   %if ^(0<&minVariation<100) %then %do;
24713     +       %let minVariation = 90;
24714     +   %end;
24715     +
24716     +   data _null_;
24717     +      set varclus_tmp end=eof;
24718     +      by _NCL_;
24719     +      retain flag 0;
24720     +      if first._ncl_ then flag=0;
24721     +      if .<col1 < &minVariation then flag=1;
24722     +      if last._ncl_ and ^flag then do;
24723     +         call symput('OPTNCL', _ncl_);
24724     +         stop;
24725     +      end;
24726     +     if eof then call symput('OPTNCL', _ncl_);
24727     +   run;
24728     +
24729     +   %let optnclus = &OPTNCL;
24730     +
24731     +   data varclus_tmp(drop=_NCL_ _NAME_);
24732     +      set &statDs;
24733     +      where _type_ in('RSQUARED' 'GROUP') and _NCL_=&OPTNCL;
24734     +   run;
24735     +   proc sort data=varclus_tmp;
24736     +      by _TYPE_;
24737     +   run;
24738     +   proc transpose data=varclus_tmp out=varclus_tmp;
24739     +      by _TYPE_;
24740     +   run;
24741     +   proc sort data=varclus_tmp;
24742     +      by _name_ _type_;
24743     +   run;
24744     +
24745     +  proc transpose data=varclus_tmp out=&groupds;
24746     +      by _NAME_;
24747     +   run;
24748     +   proc sort data=&groupDs(rename=(col1=Cluster col2=Rsquare _NAME_=VARIABLE));
24749     +      by Cluster descending Rsquare;
24750     +      where Cluster ne 0;
24751     +   run;
24752     +   proc datasets lib=work nolist mt=(DATA VIEW);
24753     +      delete varclus_tmp;
24754     +   run;
24755     +   quit;
24756     +%mend findClusNum;
24757     +*/
24758     +
24759     +%macro getNclusfromTrain(inoutstat=, nc=);
24760     +%global &nc;
24761     +data _null_;
24762     +    set &inoutstat end=eof;
24763     +    if eof then do;
24764     +    call symput("&nc", _ncl_);
24765     +    end;
24766     +run;
24767     +%mend  getNclusfromTrain;
24768     +
24769     +%macro MakeDeltaCode(groupds=, outstatscore=, deltacodefile=);
24770     +
24771     +     *--- Build Code to Modify Metadata ---*;
24772     +     filename X "&deltacodefile";
24773     +     data _null_;
24774     +        FILE X;
24775     +        set &groupds end=eof;
24776     +        /*by Cluster;*/
24777     +         if _N_=1 then do;
24778     +           %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
24779     +            put "if upcase(strip(ROLE)) ='INPUT' and upcase(strip(LEVEL)) ^='INTERVAL' then ROLE ='REJECTED' ;";
24780     +           %end;
24781     +           put "if upcase(strip(ROLE))='INPUT' and upcase(strip(LEVEL))='INTERVAL' then do;";
24782     +           put "if upcase(strip(NAME)) in (";
24783     +        end;
24784     +        if Strip(upcase(Selected)) eq 'YES' then do;
24785     +           string = '"'!!trim(left(VARIABLE))!!'"';
24786     +           put string;
24787     +        end;
24788     +        if eof then do;
24789     +           put ') then ROLE="INPUT";';
24790     +           put 'else ROLE="REJECTED";';
24791     +           put 'end;';
24792     +
24793     +           %if %upcase(&EM_PROPERTY_HIDEVARIABLE) eq Y %then %do;
24794     +             put 'if upcase(strip(ROLE)) = "REJECTED" then delete ;';
24795     +           %end;
24796     +        end;
24797     +     run;
24798     +     quit;
24799     +
24800     +     filename X;
24801     +
24802     +     quit;
24803     +%mend MakeDeltaCode;
24804     +
24805     +%macro MakeVarClusCorrData(statds=, corrds=, corrplotds= );
24806     +    %if ^%sysfunc(exist(&statds)) %then %do;
24807     +         %goto doendc;
24808     +    %end;
24809     +
24810     +    data &corrds(drop=_TYPE_ _NCL_) ;
24811     +       set &statds;
24812     +       where _type_ eq 'CORR' ;
24813     +    run ;
24814     +    proc sort data=&corrds;
24815     +       by _NAME_ ;
24816     +    run ;
24817     +    proc transpose data=&corrds out=&corrplotds name=_TMP_;
24818     +      BY _NAME_ ;
24819     +    run ;
24820     +    data &corrplotds;
24821     +       length _Y_ $100;
24822     +       set &corrplotDs;
24823     +       if _LABEL_ ne '' then _Y_=_LABEL_ ; else _Y_=_TMP_ ;
24824     +    run ;
24825     +    data varclus_match(rename=(_TMP_= _NAME_ _LABEL_=_X_));
24826     +       set &corrplotds;
24827     +       where _LABEL_ ne '' ;
24828     +       keep _TMP_ _LABEL_ ;
24829     +    run ;
24830     +    data _null_;
24831     +       nobs=0;
24832     +       dsid = open('varclus_match');
24833     +       if dsid then do;
24834     +          nobs = attrn(dsid, 'NOBS');
24835     +          dsid = close(dsid);
24836     +       end;
24837     +       call symput ('CORR_NOBS', nobs);
24838     +    run;
24839     +    %if &corr_nobs %then %do;
24840     +        proc sort data=varclus_match;
24841     +           by _name_;
24842     +        run ;
24843     +        proc sort data=&corrplotds;
24844     +           by _name_;
24845     +        run ;
24846     +        data &corrplotds(keep= _X_ _Y_ col1 rename=(col1=Correlation)) ;
24847     +           merge varclus_match &corrplotds;
24848     +           by _NAME_ ;
24849     +           if _X_ eq '' then _X_=_NAME_ ;
24850     +           label _X_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))";
24851     +           label _Y_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))";
24852     +           label col1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))";
24853     +
24854     +       run ;
24855     +    %end;
24856     +    %else %do;
24857     +        proc sort data=&corrplotds;
24858     +           by _name_;
24859     +        run ;
24860     +        data &corrplotds(keep= _NAME_ _Y_ col1 rename=(_NAME_=_X_ col1=Correlation)) ;
24861     +           set &corrplotds;
24862     +           label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
24863     +           label _Y_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
24864     +           label col1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))";
24865     +
24866     +        run ;
24867     +    %end;
24868     +    proc sort data=&corrplotds;
24869     +       by _X_ _Y_;
24870     +    run ;
24871     +    proc datasets lib=work nolist mt=(DATA VIEW);
24872     +       delete varclus_match;
24873     +    run;
24874     +    quit;
24875     +
24876     +%doendc:
24877     +
24878     +%mend MakeVarClusCorrData;
24879     +
24880     +%macro MakeStatPlotData(statds= , outstatplotds=);
24881     +   %if %sysfunc(exist(&statds)) %then %do;
24882     +
24883     +       data varclus_tmp(drop=_NAME_ _NCL_) ;
24884     +          set &statDs;
24885     +          where _type_ in('MEAN', 'STD', 'N');
24886     +       run ;
24887     +       proc transpose data=varclus_tmp out=&outstatplotds;
24888     +          id _TYPE_ ;
24889     +       run ;
24890     +       data &outstatplotds;
24891     +          set &outstatplotds(obs=1000);
24892     +          label _name_= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_name, noquote))";
24893     +          label _label_="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_label, noquote))" ;
24894     +          if MEAN ne 0 then SCALEDSTD= STD / MEAN ;
24895     +          else SCALEDSTD= STD ;
24896     +          label SCALEDSTD = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_scaledstd, noquote))";
24897     +       run ;
24898     +       proc sort data=&outstatplotds;
24899     +          by descending SCALEDSTD ;
24900     +       run ;
24901     +       proc datasets lib=work nolist mt=(DATA VIEW);
24902     +          delete varclus_tmp;
24903     +       run;
24904     +       quit;
24905     +    %end;
24906     +
24907     +%mend MakeStatPlotData;
24908     +
24909     +
24910     +%macro CreateScoreCode(indata=, ncluscomp=, fileref=);
24911     +     %EM_GETNAME(KEY=OUTSTATSCORE, type=DATA);
24912     +    data &EM_USER_OUTSTATSCORE;
24913     +          set &indata;
24914     +          if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = &ncluscomp ) or (_TYPE_ in ('MEAN' 'STD'));
24915     +          if _TYPE_ = 'MEAN' then _NAME_='MEAN';
24916     +          if _TYPE_ = 'STD' then _NAME_='STD';
24917     +          DROP _TYPE_ _NCL_;
24918     +     run;
24919     +
24920     +     filename _file_  "&fileRef";
24921     +
24922     +     data _null_;
24923     +        FILE _file_ MOD;
24924     +        put ' ';
24925     +        put '/*-------------------------------------------------*/';
24926     +        put '/* ' "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_title_begin , noquote))" '*/';
24927     +        put '/*-------------------------------------------------*/';
24928     +        put ' ';
24929     +        %let dsid = %sysfunc(open(&EM_USER_OUTSTATSCORE));
24930     +
24931     +        %let nvar = %sysfunc(attrn(&dsid, NVAR));
24932     +        %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
24933     +
24934     +        %let k = 1;
24935     +        %do %while(^%sysfunc(fetch(&dsid)));
24936     +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
24937     +                %if &k > 2 %then %do;
24938     +                 %let cn = %eval(&k-2);
24939     +                 put "&_name = 0 ; /*---" "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_cluscompnum, noquote, &cn))"  "------ */";
24940     +                %end;
24941     +                %let k = %eval(&k+1);
24942     +        %end;
24943     +
24944     +        %let rc = %sysfunc(rewind(&dsid));
24945     +
24946     +        %do i= 2 %to &nvar;
24947     +            %let _varname =  %sysfunc(varname(&dsid, &i));
24948     +            %do %while(^%sysfunc(fetch(&dsid)));
24949     +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
24950     +                %if &_name = MEAN %then
24951     +                %let _mean = %sysfunc(getvarn(&dsid, &i));
24952     +                %else %if &_name = STD %then
24953     +                %let _std = %sysfunc(getvarn(&dsid, &i));
24954     +                %else %do;
24955     +                      %let coeff =  %sysfunc(getvarn(&dsid, &i));
24956     +                      %let abscoeff = %sysfunc(abs(&coeff));
24957     +                          %if &abscoeff >  0 %then %do;
24958     +                       put "&_name = &_name+&coeff * (&_varname - &_mean)/&_std;";
24959     +                           %end;
24960     +                 %end;
24961     +             %end;
24962     +             %let rc = %sysfunc(rewind(&dsid));
24963     +         %end;
24964     +
24965     +        %let dsid= %sysfunc(close(&dsid));
24966     +       run;
24967     +%mend CreateScoreCode;
24968     +
24969     +
24970     +
24971     +/*----------------------------------------------------------
24972     +    Instead of using %MakeRSquareData,
24973     +    %MakeVarClusResultTable at macro2.source is used
24974     + +----------------------------------------------------------*/
24975     +
24976     +
24977     +%macro MakeRSquareData(indata=, inClusRSquare=, outdata=, ncluster=);
24978     +
24979     +/* modifying  from ods rsquare = data */
24980     +
24981     +data &outdata(drop= ControlVar  NumberOfClusters CurrentCluster);
24982     +    Length Cluster $16;
24983     +    length Variable $32;
24984     +    Length VariableLabel $64;
24985     +    set &indata; retain CurrentCluster;
24986     +    if NumberOfClusters ^= &ncluster then delete;
24987     +    if strip(Cluster) eq '' then Cluster = CurrentCluster;
24988     +    CurrentCluster = Cluster;
24989     +   run;
24990     +proc sort data =&outdata ;
24991     +     by Cluster RsquareRatio;
24992     +run;
24993     +data _tmprsq(drop=index);
24994     +     set &outdata; by Cluster;
24995     +     if first.Cluster then do;
24996     +     index = strip(scan(Cluster,2 ));
24997     +     Variable = "Clus"||index;
24998     +     VariableLabel = "Cluster Component "||index;
24999     +     OwnCluster = 1;
25000     +     NextClosest = .;
25001     +     RsquareRatio = 0;
25002     +     output;
25003     +     end;
25004     +run;
25005     +
25006     +proc sort data = _tmprsq ;
25007     +     by Cluster RsquareRatio;
25008     +run;
25009     +data &outdata;
25010     +     set &outdata _tmprsq;
25011     +by Cluster;
25012     +run;
25013     +
25014     +
25015     +/* Just create the Selected variable with all YES */
25016     +
25017     +data &outdata;
25018     +    set &outdata; by cluster;
25019     +    length Selected $8;
25020     +    Selected = 'YES';
25021     +    label  OwnCluster = 'R-Sqaure with Cluster Component';
25022     +    label  NextClosest = 'R-Sqaure with Next Cluster Component';
25023     +    rename OwnCluster = RSqWithClusterComp;
25024     +    rename NextClosest = RSqWithNextClusComp;
25025     +run;
25026     +
25027     +
25028     +/* Selected = Y/N will be done %score section -----
25029     +
25030     +%if &EM_PROPERTY_EXPORTEDCOMP ne CLUSTERCOMP %then %do;
25031     +data &outdata;
25032     +    set &outdata; by cluster;
25033     +    length Selected $8;
25034     +    if first.Cluster then Selected = 'YES';
25035     +    else Selected = 'NO';
25036     +    label  OwnCluster = 'R-Sqaure with Cluster Component';
25037     +    label  NextClosest = 'R-Sqaure with Next Cluster Component';
25038     +    rename OwnCluster = RSqWithClusterComp;
25039     +    rename NextClosest = RSqWithNextClusComp;
25040     +run;
25041     +%end;
25042     +%else %do;
25043     +data &outdata;
25044     +    set &outdata; by cluster;
25045     +    if last.Cluster then Selected = 'YES';
25046     +    else Selected = 'NO';
25047     +    label  OwnCluster = 'R-Sqaure with Cluster Component';
25048     +    label  NextClosest = 'R-Sqaure with Next Cluster Component';
25049     +    rename OwnCluster = RSqWithClusterComp;
25050     +    rename NextClosest = RSqWithNextClusComp;
25051     +run;
25052     +%end;
25053     +---------------------------------------------------------------*/
25054     +
25055     +%if %sysfunc(exist(&inClusRSquare)) %then %do;
25056     +/* to calculate NextClosestClusRsq */
25057     +proc transpose data = &inClusRSquare  out=_clusRsq;
25058     +      by cluster;
25059     +      run;
25060     +data _clusRsq;
25061     +     set _clusRsq;
25062     +     if strip(upcase(Cluster)) eq strip(upcase(_NAME_)) then delete;
25063     +run;
25064     +
25065     +proc sort data=_clusRsq;
25066     +    by cluster col1;
25067     +    run;
25068     +data _clusRsq(drop=_NAME_ _LABEL_);
25069     +     set _clusRsq; by cluster;
25070     +     if last.Cluster then output;
25071     +     label  COL1 = 'R-Sqaure with Next Cluster Component';
25072     +     rename COL1 = RSqWithNextClusComp;
25073     +     rename Cluster = Variable;
25074     +     label  Cluster = "Variable";
25075     +run;
25076     +
25077     +proc sort data =&outdata;
25078     +     by Variable;
25079     +run;
25080     +data &outdata;
25081     +    merge &outdata _clusRsq;
25082     +    by Variable;
25083     +run;
25084     +proc sort data =&outdata;
25085     +by Cluster  RsquareRatio;
25086     +run;
25087     +quit;
25088     +%end;
25089     +
25090     +proc datasets lib = work nolist;
25091     +     delete _tmprsq _clusRsq;
25092     +     run;
25093     +quit;
25094     +
25095     +%mend MakeRSquareData;
25096     +
25097     +
25098     +/*-------------------------------------------------------------------------*/
25099     +
25100     +
25101     +
25102     +%macro ModifyCorr(indata=,
25103     +                  outdata=,
25104     +                  rsquare = Y
25105     +                  );
25106     +    data corr_tmp;
25107     +        set &indata;
25108     +    run;
25109     +     proc sql;
25110     +           update &indata
25111     +           set
25112     +     %let dsid = %sysfunc(open(work.corr_tmp));
25113     +     %let nvar = %sysfunc(attrn(&dsid, NVAR));
25114     +          %do i = 4 %to &nvar;
25115     +          %let _name = %sysfunc(varname(&dsid, &i));
25116     +             %if &rsquare eq Y %then %let _name_md = &_name.**2;
25117     +            %else  %let _name_md = &_name;
25118     +            %if &i < &nvar %then %do;
25119     +               &_name = 1- &_name_md ,
25120     +            %end;
25121     +            %else %do;
25122     +               &_name = &_name_md where _TYPE_ contains 'CORR' ;
25123     +            %end;
25124     +          %end;
25125     +      %let dsid= %sysfunc(close(&dsid));
25126     +
25127     +      select * from &indata;
25128     +      run;
25129     +      proc datasets lib = work nolist;
25130     +           delete corr_tmp;
25131     +      run;
25132     +      quit;
25133     +
25134     + %mend ModifyCorr;
25135     +
25136     + %macro MakeClusStructCorrData(indata=,outdata=, ncluster=, Rsquare=N);
25137     +    data &outdata(drop= _NCL_  _TYPE_);
25138     +       set &indata;
25139     +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'STRUCTUR') then delete;
25140     +       rename _NAME_ = Cluster;
25141     +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
25142     +    run;
25143     +    %if &RSquare eq Y %then %do;
25144     +     data corr_tmp;
25145     +        set &outdata;
25146     +     run;
25147     +
25148     +     data &outdata(drop=i);
25149     +          set &outdata;
25150     +          %let dsid = %sysfunc(open(work.corr_tmp));
25151     +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
25152     +          %do i = 2 %to &nvar;
25153     +            %let _name = %sysfunc(varname(&dsid, &i));
25154     +            %let _name_md = &_name.**2;
25155     +                &_name = &_name_md;
25156     +          %end;
25157     +      %let dsid= %sysfunc(close(&dsid));
25158     +      run;
25159     +      proc datasets lib = work nolist;
25160     +           delete corr_tmp;
25161     +      run;
25162     +
25163     +    %end;
25164     +     quit;
25165     +%mend MakeClusStructCorrData;
25166     +
25167     +%macro MakeInterClusCorrData(indata=, outdata=, ncluster=, RSquare=N, makeplotds=N, plotds=);
25168     +    data &outdata(drop= _NCL_  _TYPE_);
25169     +       set &indata;
25170     +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'CCORR') then delete;
25171     +       rename _NAME_ = Cluster;
25172     +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
25173     +    run;
25174     +    data corr_tmp;
25175     +        set &outdata;
25176     +    run;
25177     +
25178     +    %let dsid = %sysfunc(open(work.corr_tmp));
25179     +    %let nclus2= %eval(&ncluster+1);
25180     +    data &outdata;
25181     +         set &outdata;
25182     +          %do i = 2 %to &nclus2;
25183     +          %let i_1 = %eval(&i-1);
25184     +            %let _name = %sysfunc(varname(&dsid, &i));
25185     +            %let _newName = Clus&i_1;
25186     +                rename &_name = &_newName; ;
25187     +                *label &_name ="Cluster &i_1";
25188     +                label &_name = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clusternum, noquote,  &i_1))";
25189     +          %end;
25190     +          keep Cluster
25191     +          %do i = 2 %to &nclus2;
25192     +                %let _name = %sysfunc(varname(&dsid, &i));
25193     +                &_name
25194     +          %end;
25195     +          ;
25196     +    %let dsid= %sysfunc(close(&dsid));
25197     +     run;
25198     +     quit;
25199     +
25200     +    %if &RSquare eq Y %then %do;
25201     +
25202     +       data corr_tmp;
25203     +        set &outdata;
25204     +     run;
25205     +
25206     +     data &outdata(drop=i);
25207     +          set &outdata;
25208     +          %let dsid = %sysfunc(open(work.corr_tmp));
25209     +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
25210     +          %do i = 2 %to &nvar;
25211     +            %let _name = %sysfunc(varname(&dsid, &i));
25212     +            %let _name_md = &_name.**2;
25213     +                &_name = &_name_md;
25214     +          %end;
25215     +      %let dsid= %sysfunc(close(&dsid));
25216     +      run;
25217     +    %end;
25218     +
25219     +    %if &makeplotds eq Y %then %do;
25220     +     proc transpose data = &outdata
25221     +          out=&plotds(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
25222     +          by cluster;
25223     +     run;
25224     +     data &plotds;
25225     +          set  &plotds;
25226     +          label x="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
25227     +          label Y="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
25228     +     run;
25229     +     %end;
25230     +     proc datasets lib = work nolist;
25231     +           delete corr_tmp;
25232     +     run;
25233     +     quit;
25234     +%mend MakeInterClusCorrData;
25235     +
25236     +
25237     +%macro MakeClusConstellData(indata=, outlink=, outnode=);
25238     +
25239     +data &outlink(drop = Selected);
25240     +     set &indata;
25241     +     LINKID = _N_;
25242     +     label LINKID = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_linkid,  noquote))";
25243     +     if strip(upcase(Cluster)) eq strip(upcase(Variable)) then Variable = ClosestCluster;
25244     +run;
25245     +data &outnode(keep=NODEID TYPE LABEL);
25246     +    set &indata;
25247     +    length TYPE $16;
25248     +    rename Variable = NODEID;
25249     +    label  Variable= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))";
25250     +    if strip(upcase(Cluster)) eq strip(upcase(Variable))
25251     +    then  TYPE = "CLUSTER";
25252     +    else  TYPE="VARIABLE";
25253     +    label TYPE = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))";
25254     +run;
25255     +quit;
25256     +%mend MakeClusConstellData;
25257     +
25258     +
25259     +
25260     +%macro MakeClusConstellData(indata=, outlink=, outnode=);
25261     +
25262     +data &outlink(drop = Selected);
25263     +     set &indata;
25264     +     LINKID = _N_;
25265     +     label LINKID = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_linkid,  noquote))";
25266     +     if strip(upcase(Cluster)) eq strip(upcase(Variable)) then Variable = ClosestCluster;
25267     +run;
25268     +data &outnode(keep=NODEID TYPE LABEL);
25269     +    set &indata;
25270     +    length TYPE $16;
25271     +    rename Variable = NODEID;
25272     +    label  Variable= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))";
25273     +    if strip(upcase(Cluster)) eq strip(upcase(Variable))
25274     +    then  TYPE = "CLUSTER";
25275     +    else  TYPE="VARIABLE";
25276     +    label TYPE = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))";
25277     +run;
25278     +quit;
25279     +%mend MakeClusConstellData;
25280     +
25281     +
25282     +/*--- This will work only when inds is not a view data -------
25283     +
25284     +%macro getNVarNObs(inds=, nvar=, nobs=);
25285     +
25286     +    %global &nvar;
25287     +    %global &nobs;
25288     +    data _null_;
25289     +         dsid = open("&inds");
25290     +         nv = attrn(dsid, 'NVAR');
25291     +         no = attrn(dsid, 'NOBS');
25292     +         dsid = close(dsid);
25293     +         call symput("&nvar", nv);
25294     +         call symput("&nobs", no);
25295     +    run;
25296     +    quit;
25297     +%mend  getNVarNObs;
25298     +
25299     ++---------------------------------------------------------------*/
25300     +
25301     +
25302     +%macro getNVar(inds=, nvar=);
25303     +    %global &nvar;
25304     +    data _null_;
25305     +         dsid = open("&inds");
25306     +         nv = attrn(dsid, 'NVAR');
25307     +         dsid = close(dsid);
25308     +         call symput("&nvar", nv);
25309     +    run;
25310     +    quit;
25311     +%mend  getNVar;
25312     +
25313     +
25314     +
25315     +%macro getNObs(inds=, nobs=);
25316     +    %global &nobs;
25317     +    data _null_;
25318     +        set &inds end=eof;
25319     +        if eof then call symput("&nobs", _N_);
25320     +    run;
25321     +    quit;
25322     +%mend  getNObs;
25323     +
25324     +%Macro CreateVarclusMeta(trainnum=);
25325     +   %EM_GETNAME(KEY=VARCLUSMETA, TYPE=DATA);
25326     +    data &EM_USER_VARCLUSMETA;
25327     +         length TrainNum 8.;
25328     +         length NewTrain $8;
25329     +         length NGCluster 8.;
25330     +         length ExportedComp $16;
25331     +         length HideVariable $8;
25332     +         TrainNum = &trainnum;
25333     +         NewTrain = "Y";
25334     +         ExportedComp = "&EM_PROPERTY_EXPORTEDCOMP";
25335     +         HideVariable = "&EM_PROPERTY_HIDEVARIABLE";
25336     +         NGCluster = 0; /* zero means no twostage */
25337     +   run;
25338     +   quit;
25339     +%mend CreateVarclusMeta;
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp catalog 'sashelp.emexpl.variableclustering_macros2.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_MACROS2.SOURCE.
25340     +
25341     +%macro MakeInterClusCorrData(indata=, outdata=, ncluster=, globalclusid=, RSquare=N, makeplotds=N, plotds=);
25342     +    data &outdata(drop= _NCL_  _TYPE_);
25343     +       set &indata;
25344     +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'CCORR') then delete;
25345     +       %if &globalclusid ne %then %do;
25346     +       _NAME_ = "GC&globalclusid._"||upcase(_NAME_);
25347     +       rename _NAME_ = Cluster;
25348     +       %end;
25349     +       %else %do;
25350     +        _NAME_ = upcase(_NAME_);
25351     +       rename _NAME_ = Cluster;
25352     +       %end;
25353     +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
25354     +    run;
25355     +    data corr_tmp;
25356     +        set &outdata;
25357     +    run;
25358     +
25359     +    %let dsid = %sysfunc(open(work.corr_tmp));
25360     +    %let nclus2= %eval(&ncluster+1);
25361     +    data &outdata;
25362     +         set &outdata;
25363     +          %do i = 2 %to &nclus2;
25364     +          %let i_1 = %eval(&i-1);
25365     +            %let _name = %sysfunc(varname(&dsid, &i));
25366     +            %if &globalclusid ne %then
25367     +                %do; %let _newName = GC&globalclusid._CLUS&i_1;
25368     +                     rename &_name = &_newName;
25369     +                     *label &_name ="GC &globalclusid : Cluster &i_1";
25370     +                     label &_name = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gc_clusternum, noquote,  &globalclusid, &i_1))";
25371     +                %end;
25372     +            %else
25373     +                %do; %let _newName = CLUS&i_1;
25374     +                     rename &_name = &_newName;
25375     +                     *label &_name ="Cluster &i_1";
25376     +                     label &_name = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clusternum, noquote,  &i_1))";
25377     +                %end;
25378     +          %end;
25379     +          keep Cluster
25380     +          %do i = 2 %to &nclus2;
25381     +                %let _name = %sysfunc(varname(&dsid, &i));
25382     +                &_name
25383     +          %end;
25384     +          ;
25385     +    %let dsid= %sysfunc(close(&dsid));
25386     +     run;
25387     +     quit;
25388     +
25389     +    %if &RSquare eq Y %then %do;
25390     +
25391     +       data corr_tmp;
25392     +        set &outdata;
25393     +     run;
25394     +
25395     +     data &outdata;
25396     +          set &outdata;
25397     +          %let dsid = %sysfunc(open(work.corr_tmp));
25398     +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
25399     +          %do i = 2 %to &nvar;
25400     +            %let _name = %sysfunc(varname(&dsid, &i));
25401     +            %let _name_md = &_name.**2;
25402     +                &_name = &_name_md;
25403     +          %end;
25404     +      %let dsid= %sysfunc(close(&dsid));
25405     +      run;
25406     +    %end;
25407     +
25408     +    %if &makeplotds eq Y %then %do;
25409     +     proc transpose data = &outdata
25410     +          out=&plotds(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
25411     +          by cluster;
25412     +     run;
25413     +     data &plotds;
25414     +          set  &plotds;
25415     +          label x="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
25416     +          label Y="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
25417     +          label  Correlation="%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))";
25418     +     run;
25419     +     %end;
25420     +     proc datasets lib = work nolist;
25421     +           delete corr_tmp;
25422     +     run;
25423     +     quit;
25424     +%mend MakeInterClusCorrData;
25425     +
25426     +%macro MakeOwnRSquare(indata=, outdata=, ncluster=, globalclusid=);
25427     +    data _tmpds(drop= _NCL_);
25428     +       set &indata;
25429     +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) in ('GROUP','RSQUARED')) then delete;
25430     +       %if &globalclusid ne %then %do;
25431     +           _NAME_ = "GC&globalclusid.";
25432     +       rename _NAME_ = Cluster;
25433     +       %end;
25434     +       %else %do;
25435     +        _NAME_ = "CLUS";
25436     +        rename _NAME_ = Cluster;
25437     +       %end;
25438     +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
25439     +    run;
25440     +    proc transpose data =_tmpds out =&outdata;
25441     +    run;
25442     +
25443     +    data &outdata(drop=COL1);
25444     +        %if &globalclusid ne %then %do;
25445     +        length GCluster $16;
25446     +        %end;
25447     +        length Cluster $32;
25448     +        length _NAME_ $32;
25449     +         set &outdata;
25450     +         _NAME_ = upcase(_NAME_);
25451     +         rename _NAME_=Variable;
25452     +         *label _NAME_="Variable";
25453     +         label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
25454     +         label Cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
25455     +         label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
25456     +
25457     +         %if &globalclusid ne %then %do;
25458     +          GCluster = "GC&globalclusid";
25459     +          Cluster = "GC&globalclusid._CLUS"||strip(COL1);
25460     +         %end;
25461     +         %else %do;
25462     +         Cluster = "CLUS"||strip(COL1);
25463     +        %end;
25464     +         rename COL2 = RSqWithOwnClusComp;
25465     +         *label COL2 = "R-Square With Own Cluster Component";
25466     +         label COL2 = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_ownrsq, noquote))" ;
25467     +
25468     +   run;
25469     +   proc sort data =&outdata;
25470     +        by Cluster RSqWithOwnClusComp;
25471     +   run;
25472     +   proc datasets lib = work nolist;
25473     +           delete _tmpds;
25474     +   run;
25475     +   quit;
25476     +%mend MakeOwnRSquare;
25477     +
25478     +%macro MakeClusStructCorrData(indata=, outdata=, globalclusid=, ncluster=, Rsquare=N);
25479     +    data &outdata(drop= _NCL_  _TYPE_);
25480     +       %if &globalclusid ne %then %do;
25481     +        length GCluster $16;
25482     +        %end;
25483     +       set &indata;
25484     +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'STRUCTUR') then delete;
25485     +       %if &globalclusid ne %then %do;
25486     +         GCluster = "GC&globalclusid";
25487     +         _NAME_ = "GC&globalclusid._"||upcase(_NAME_);
25488     +         rename _NAME_ = Cluster;
25489     +         label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
25490     +         label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
25491     +
25492     +       %end;
25493     +       %else %do;
25494     +         _NAME_ = upcase(_NAME_);
25495     +         rename _NAME_ = Cluster;
25496     +         label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
25497     +         label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
25498     +
25499     +       %end;
25500     +     run;
25501     +    %if &RSquare eq Y %then %do;
25502     +     data corr_tmp;
25503     +          set &outdata;
25504     +     run;
25505     +     %let istart = 2;
25506     +     %if &globalclusid ne %then %let istart = 3;
25507     +     data &outdata;
25508     +          set &outdata;
25509     +          %let dsid = %sysfunc(open(work.corr_tmp));
25510     +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
25511     +          %do i =&istart %to &nvar;
25512     +            %let _name = %sysfunc(varname(&dsid, &i));
25513     +            %let _name_md = &_name.**2;
25514     +                &_name = &_name_md;
25515     +          %end;
25516     +      %let dsid= %sysfunc(close(&dsid));
25517     +      run;
25518     +      proc datasets lib = work nolist;
25519     +           delete corr_tmp;
25520     +      run;
25521     +    %end;
25522     +     quit;
25523     +%mend MakeClusStructCorrData;
25524     +
25525     +/*
25526     +%MakeClusStructCorrData(indata=playpen._outstat, outdata=_structrsq , ncluster=7, Rsquare=Y);
25527     +*/
25528     +
25529     +%macro FindNextClosestClusByVar(indata=, outdata=, globalclusid=, ncluster=);
25530     +
25531     +     /* The indata should be the outdata
25532     +        from %MakeClusStructCorrData(indata=, outdata=, ); */
25533     +
25534     +     proc sort data =&indata out=_tmpclusRsq;
25535     +     by cluster;
25536     +     run;
25537     +
25538     +     proc transpose data =_tmpclusRsq out=_tmpclusRsq;
25539     +      by cluster;
25540     +     run;
25541     +
25542     +     proc sort data=_tmpclusRsq;
25543     +        by _NAME_ COL1;
25544     +     run;
25545     +
25546     +     data _tmpclusRsq;
25547     +         length _NAME_ $32;
25548     +         set _tmpclusRsq; by _NAME_;
25549     +          _NAME_ = upcase(_NAME_);
25550     +          %if &ncluster ne 1 %then %do;
25551     +             if last._NAME_ then delete;
25552     +          %end;
25553     +          %else %do;
25554     +             COL1 = 0;
25555     +          %end;
25556     +     run;
25557     +     /* need to sort again */
25558     +     proc sort data=_tmpclusRsq;
25559     +        by _NAME_ COL1;
25560     +     run;
25561     +
25562     +     data &outdata;
25563     +         set _tmpclusRsq; by _NAME_;
25564     +         Cluster = upcase(Cluster);
25565     +         if last._NAME_ then output;
25566     +         *label  COL1 = 'R-Sqaure with Next Cluster Component';
25567     +         label COL1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextrsq, noquote))" ;
25568     +         rename COL1 = RSqWithNextClusComp;
25569     +         Cluster = upcase(Cluster);
25570     +         rename Cluster = ClosestCluster;
25571     +         *label  Cluster = "Next Closest Cluster";
25572     +         label Cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextclus, noquote))" ;
25573     +         rename _NAME_ = Variable;
25574     +         label  _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
25575     +    run;
25576     +
25577     +
25578     +    %if &globalclusid ne %then %do;
25579     +    data &outdata;
25580     +       length GCluster $16;
25581     +       set &outdata;
25582     +       GCluster = "GC&globalclusid";
25583     +       run;
25584     +    %end;
25585     +    proc datasets lib = work nolist;
25586     +           delete _tmpclusRsq;
25587     +    run;
25588     +    quit;
25589     +%mend FindNextClosestClusByVar;
25590     +
25591     +
25592     +%macro FindNextClosestClusByCluster(indata=, outdata=, globalclusid=, ncluster=);
25593     +     /* The indata should be the outdata from %MakeInterClusCorrData(indata=, outdata=, ); */
25594     +     proc sort data =&indata out=_tmpclusRsq;
25595     +     by cluster;
25596     +     run;
25597     +     proc transpose data =_tmpclusRsq out=_tmpclusRsq;
25598     +     by cluster;
25599     +     run;
25600     +     proc sort data=_tmpclusRsq;
25601     +        by _NAME_ col1;
25602     +     run;
25603     +     data _tmpclusRsq;
25604     +         length _NAME_ $32;
25605     +         set _tmpclusRsq; by _NAME_;
25606     +          _NAME_ = upcase(_NAME_);
25607     +          %if &ncluster ne 1 %then %do;
25608     +             if last._NAME_ then delete;
25609     +          %end;
25610     +          %else %do;
25611     +             COL1 = 0;
25612     +          %end;
25613     +     run;
25614     +     data &outdata;
25615     +         set _tmpclusRsq; by _NAME_;
25616     +         Cluster = upcase(Cluster);
25617     +         if last._NAME_ then output;
25618     +         *label  COL1 = 'R-Sqaure with Next Cluster Component';
25619     +         label COL1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextrsq, noquote))" ;
25620     +         rename COL1 = RSqWithNextClusComp;
25621     +         Cluster = upcase(Cluster);
25622     +         rename Cluster = ClosestCluster;
25623     +         *label  Cluster = "Next Closest Cluster";
25624     +         label Cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextclus, noquote))" ;
25625     +         rename _NAME_ = Variable;
25626     +         *label  _NAME_ = "Variable";
25627     +         label  _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
25628     +
25629     +    run;
25630     +    %if &globalclusid ne %then %do;
25631     +    data &outdata;
25632     +       length GCluster $16;
25633     +       set &outdata;
25634     +       GCluster = "GC&globalclusid";
25635     +       run;
25636     +    %end;
25637     +
25638     +    proc datasets lib = work nolist;
25639     +           delete _tmpclusRsq;
25640     +    run;
25641     +
25642     +    quit;
25643     +%mend FindNextClosestClusByCluster;
25644     +
25645     +%macro MakeVarClusResultTable(indata1=, indata2=, indata3=, outdata=, globalclusid=, ncluster=, selectedcomp=clustercomp);
25646     +/*----
25647     +  indata1=_ownRsq, indata2=_nextVarRsq, indata3=_nextClusRSq,
25648     +-----------*/
25649     +
25650     +proc sort data =&indata1;
25651     +    by Variable;
25652     +run;
25653     +proc sort data =&indata2;
25654     +    by Variable;
25655     +run;
25656     +data &outdata;
25657     +    merge &indata1 &indata2;
25658     +    by Variable;
25659     +    length Type $16;
25660     +    Type = 'Variable';
25661     +    *label Type ='Type';
25662     +    label Type = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_type, noquote))" ;
25663     +run;
25664     +
25665     +
25666     +data &indata3;
25667     +    set  &indata3 ;
25668     +    length RSqWithOwnClusComp 8.;
25669     +    Cluster = Variable;
25670     +    RSqWithOwnClusComp = 1;
25671     +    *label RSqWithOwnClusComp = "R-Square With Own Cluster Component";
25672     +    label RSqWithOwnClusComp = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_ownrsq, noquote))" ;
25673     +    length Type $16;
25674     +    Type = 'ClusterComp';
25675     +    label Type = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_type, noquote))" ;
25676     +
25677     +;
25678     +run;
25679     +
25680     +proc sort data=&outdata;
25681     +    by Cluster;
25682     +run;
25683     +proc sort data =&indata3;
25684     +    by Cluster;
25685     +run;
25686     +
25687     +data &outdata;
25688     +     set &outdata &indata3;
25689     +     by Cluster;
25690     +run;
25691     +
25692     +
25693     +/* Create the Selected variable with all YES */
25694     +
25695     +data &outdata;
25696     +     set &outdata;
25697     +     length RsqRatio 8.;
25698     +     length Selected $8;
25699     +     *label RSqRatio = "1-R**2 Ratio";
25700     +     label RSqRatio =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_oneminusrsq, noquote))" ;
25701     +     *label Selected = "Variable Selected";
25702     +     label Selected = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_varselected, noquote))" ;
25703     +     RsqRatio = (1-RSqWithOwnClusComp)/(1-RSqWithNextClusComp);
25704     +     Selected ='YES';
25705     +     rename _LABEL_ = Label;
25706     +     label _LABEL_ =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_label, noquote))" ;
25707     +run;
25708     +
25709     +
25710     +/*----  Selected = Y/N will be assigened at the %score                   -------+
25711     +        Just create the Selected variable with all YES at the step above
25712     + +------------------------------------------------------------------------------+
25713     +
25714     +proc sort data=&outdata;
25715     +    by Cluster RsqRatio;
25716     +run;
25717     +
25718     +%if &selectedcomp eq CLUSTERCOMP %then %do;
25719     +data &outdata;
25720     +     set &outdata; by Cluster;
25721     +     length Selected $8;
25722     +     label Selected = "Variable Selected";
25723     +     if  first.Cluster then Selected ='Yes';
25724     +     else Selected = 'No';
25725     +    run;
25726     +%end;
25727     +%else %do;
25728     +data &outdata(drop = _var _varchange);
25729     +     set &outdata; retain _var 0; by Cluster;
25730     +     length Selected $8;
25731     +     label Selected = "Variable Selected";
25732     +     if first.Cluster then  _varchange = 0;
25733     +     else _varchange =1;
25734     +     if _var ne _varchange then  Selected  = 'Yes';
25735     +     else Selected = 'No';
25736     +     if last.cluster then  _var = 0;
25737     +     else _var = _varchange;
25738     +run;
25739     +%end;
25740     +
25741     +--------------------------------------------------------------*/
25742     +
25743     +quit;
25744     +%mend MakeVarClusResultTable;
25745     +
25746     +%Macro MakePlotDataFromCorrTable(indata=, outdata=, globalclusid=);
25747     +     proc sort data =&indata;
25748     +        by cluster;
25749     +     run;
25750     +     proc transpose data =&indata
25751     +          out=&outdata(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
25752     +          by cluster;
25753     +     run;
25754     +     data &outdata;
25755     +          set  &outdata;
25756     +          label x= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
25757     +          label Y= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
25758     +          label Correlation = "%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))" ;
25759     +     run;
25760     +     %if &globalclusid ne %then %do;
25761     +     data &outdata;
25762     +          Length GCluster $16;
25763     +          label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
25764     +          set  &outdata;
25765     +          GCluster ="GC&globalclusid.";
25766     +          run;
25767     +     %end;
25768     +
25769     +%Mend MakePlotDataFromCorrTable;
25770     +
25771     +
25772     +%macro MakeCorrelation(indata=,
25773     +                       outstat=_tmpoutstat,
25774     +                       corrmatrix=N,
25775     +                       outcorr=_tmpoutcorr,
25776     +                       includeclassvar=N,
25777     +                       target=,
25778     +                       freq=,
25779     +                       weight=);
25780     +   %if &target eq  %then %do;
25781     +
25782     +       proc varclus data=&indata outstat=&outstat hi maxclusters=1 noprint;
25783     +            var %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED
25784     +       %if &includeclassvar eq Y %then %do;
25785     +          %let dsid = %sysfunc(open(&EM_USER_OUTDUMMY));
25786     +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
25787     +          %do i = 2 %to &nvar;
25788     +          %let varname = %sysfunc(varname(&dsid, &i));
25789     +          &varname
25790     +          %end;
25791     +       %end;
25792     +       ;
25793     +      %if &freq ne  %then %do;
25794     +          freq &freq;
25795     +      %end;
25796     +      %if &weight ne  %then %do;
25797     +          weight &weight;
25798     +      %end;
25799     +
25800     +      run;
25801     +      %if &corrmatrix eq Y %then %do;
25802     +      data  &outcorr (drop = _NCL_ _TYPE_);
25803     +           set  &outstat ;
25804     +           if _TYPE_ ='CORR' then output;
25805     +      run;
25806     +      %end;
25807     +    %end;
25808     +    %else %do;
25809     +       proc corr data=&indata outp=&outstat noprint;
25810     +            var
25811     +       %let dsid = %sysfunc(open(&indata));
25812     +       %let nvar = %sysfunc(attrn(&dsid, NVAR));
25813     +          %do i = 1 %to &nvar;
25814     +              %let _name = %sysfunc(varname(&dsid, &i));
25815     +              %if &_name ne &target %then;
25816     +              &_name
25817     +           %end;
25818     +        %let dsid= %sysfunc(close(&dsid));
25819     +        ;
25820     +        with &target;
25821     +        run;
25822     +    %end;
25823     +    quit;
25824     +%mend MakeCorrelation;
25825     +
25826     +
25827     +%macro MakeCorrelationDistance(indata=,
25828     +                               outdata=,
25829     +                               rsquare = N
25830     +                               );
25831     +    data corr_tmp;
25832     +        set &indata;
25833     +        if _N_ = 1 then do;
25834     +           output;
25835     +           stop;
25836     +         end;
25837     +    run;
25838     +    %if &outdata ne  %then %let  _outdata = &outdata;
25839     +    %else %let _outdata = &indata;
25840     +
25841     +    data &_outdata;
25842     +         set &indata;
25843     +
25844     +         %let dsid = %sysfunc(open(work.corr_tmp));
25845     +         %let nvar = %sysfunc(attrn(&dsid, NVAR));
25846     +          %do i = 2 %to &nvar;
25847     +              %let _name = %sysfunc(varname(&dsid, &i));
25848     +              %if &rsquare eq Y %then %let _name_md = &_name.**2;
25849     +              %else  %let _name_md = &_name;
25850     +              &_name = 1- &_name_md;
25851     +          %end;
25852     +      %let dsid= %sysfunc(close(&dsid));
25853     +      run;
25854     +      proc datasets lib = work nolist;
25855     +           delete corr_tmp;
25856     +      run;
25857     +      quit;
25858     +  %mend MakeCorrelationDistance;
25859     +
25860     +
25861     +%macro UpdateOutStatCorrToDistance(indata=, /* indata should be a outstat from proc varclus */
25862     +                                   rsquare = N
25863     +                                   );
25864     +    data corr_tmp;
25865     +        set &indata;
25866     +    run;
25867     +    proc sql noprint;
25868     +           update &indata
25869     +           set
25870     +     %let dsid = %sysfunc(open(work.corr_tmp));
25871     +     %let nvar = %sysfunc(attrn(&dsid, NVAR));
25872     +          %do i = 4 %to &nvar;
25873     +          %let _name = %sysfunc(varname(&dsid, &i));
25874     +             %if &rsquare eq Y %then %let _name_md = &_name.**2;
25875     +            %else  %let _name_md = &_name;
25876     +            %if &i < &nvar %then %do;
25877     +               &_name = 1- &_name_md ,
25878     +            %end;
25879     +            %else %do;
25880     +               &_name = &_name_md where _TYPE_ eq 'CORR' ;
25881     +            %end;
25882     +          %end;
25883     +      %let dsid= %sysfunc(close(&dsid));
25884     +
25885     +      select * from &indata;
25886     +      run;
25887     +     data &indata( drop = _NCL_);
25888     +           set &indata;
25889     +           if _TYPE_ not in ('CORR', 'STD', 'N', 'MEAN') then delete;
25890     +           if _TYPE_ ='CORR' then _TYPE_ ='DISTANCE';
25891     +     run;
25892     +     data &indata(DROP = _NCL_);
25893     +           set &indata;
25894     +           if _TYPE_ = 'CORR' then _TYPE_ ='DISTANCE';
25895     +           if _TYPE_ not in ('DISTANCE', 'N', 'STD', 'MEAN') then delete;
25896     +           rename _NAME_ = _VAR_;
25897     +     run;
25898     +     proc datasets lib = work nolist;
25899     +           delete corr_tmp;
25900     +     run;
25901     +     quit;
25902     + %mend UpdateOutStatCorrToDistance;
25903     +
25904     +
25905     +%macro HierClusWithCorr(indata= ,
25906     +                        ncluster=,
25907     +                        method = Ward,
25908     +                        outtree = _outtree,
25909     +                        idvar =_VAR_,
25910     +                        outdata=,
25911     +                        rescore = N,
25912     +                        newncluster=
25913     +                        );
25914     +      %global &newncluster;
25915     +      %if &rescore ne Y %then %do;
25916     +      proc cluster data=&indata(type=Distance where=(upcase(strip(_TYPE_)) = "DISTANCE"))
25917     +                   method=&method outtree=&outtree noprint;
25918     +           id &idvar;
25919     +      run;
25920     +      %end;
25921     +      proc tree data=&outtree nclusters = &ncluster out=&outdata noprint;
25922     +      run;
25923     +      /* ----- Check some variables like CL1, CL5..., remove them ----*/
25924     +      proc contents data =&indata out=_outcontent(keep=NAME) noprint;
25925     +      run;
25926     +      data _outcontent;
25927     +          set _outcontent;
25928     +          if NAME in ('_TYPE_' , '_VAR_') then delete;
25929     +          index = 1;
25930     +          rename NAME = _NAME_;
25931     +      run;
25932     +      proc sort data=_outcontent;
25933     +          by _NAME_;
25934     +      run;
25935     +      proc sort data =&outdata;
25936     +           by _NAME_;
25937     +      run;
25938     +      data &outdata(drop=index);
25939     +          merge &outdata _outcontent;
25940     +          by _NAME_;
25941     +          if index = . then delete;
25942     +      run;
25943     +      /*-----------------------------------------------------------*/
25944     +      data &outdata;
25945     +           length CLUSNAME $16;
25946     +           set &outdata;
25947     +           if CLUSTER > &ncluster then delete;
25948     +           CLUSNAME='GC'||strip(CLUSTER);
25949     +           *label CLUSNAME = "Cluster Name";
25950     +           label CLUSNAME  = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername, noquote))" ;
25951     +           rename _NAME_ = VARIABLE ;
25952     +           *label _NAME_ = "Variable";
25953     +           *label CLUSTER = "Cluster";
25954     +           label _NAME_ ="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
25955     +           label CLUSTER ="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
25956     +      run;
25957     +      proc sort data=&outdata out=&outdata;
25958     +           by CLUSTER;
25959     +      run;
25960     +      proc means data =&outdata noprint;
25961     +           output out=_meanout;
25962     +      run;
25963     +      data _null_;
25964     +            set _meanout;
25965     +            if strip(_STAT_) eq 'MAX' then do;
25966     +            call symput("&newncluster", CLUSTER);
25967     +            stop;
25968     +            end;
25969     +      run;
25970     +
25971     +      proc datasets lib = work nolist;
25972     +           delete _outcontent _meanout;
25973     +      run;
25974     +      quit;
25975     +%mend  HierClusWithCorr;
25976     +
25977     +%macro CreateScoreCode2(indata=, ncluscomp=, globalclusid=, fileref=);
25978     +
25979     +     data _tmpindata;
25980     +          set &indata;
25981     +          if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = &ncluscomp ) or (_TYPE_ in ('MEAN' 'STD'));
25982     +          if _TYPE_ = 'MEAN' then _NAME_='MEAN';
25983     +          if _TYPE_ = 'STD' then _NAME_='STD';
25984     +          if _TYPE_ = 'SCORE' then _NAME_=upcase("GC&globalclusid._"||_NAME_);
25985     +          DROP _TYPE_ _NCL_;
25986     +     run;
25987     +
25988     +     filename _file_  "&fileRef";
25989     +
25990     +     data _null_;
25991     +        FILE _file_ MOD;
25992     +        put ' ';
25993     +        put "/*-------------------------------------------------*/";
25994     +        put '/* ' "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_title_gclus, noquote, &globalclusid))" '*/';
25995     +        put "/*-------------------------------------------------*/";
25996     +        put ' ';
25997     +        %let dsid = %sysfunc(open(work._tmpindata));
25998     +
25999     +        %let nvar = %sysfunc(attrn(&dsid, NVAR));
26000     +        %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
26001     +        %let k = 1;
26002     +        %do %while(^%sysfunc(fetch(&dsid)));
26003     +               %let _name = %sysfunc(getvarc(&dsid, &vn_name));
26004     +               %if &k > 2 %then %do;
26005     +                %let cn = %eval(&k-2);
26006     +                 put "&_name = 0 ; /*---" "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_gcluscompnum, noquote, &globalclusid, &cn))" "------ */";
26007     +                %end;
26008     +                %let k = %eval(&k+1);
26009     +
26010     +        %end;
26011     +        %let rc = %sysfunc(rewind(&dsid));
26012     +
26013     +        %do j= 2 %to &nvar;
26014     +            %let _varname = %sysfunc(varname(&dsid, &j));
26015     +            %do %while(^%sysfunc(fetch(&dsid)));
26016     +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
26017     +                %if &_name = MEAN %then
26018     +                %let _mean = %sysfunc(getvarn(&dsid, &j));
26019     +                %else %if &_name = STD %then
26020     +                %let _std = %sysfunc(getvarn(&dsid, &j));
26021     +                %else %do;
26022     +                      %let coeff =  %sysfunc(getvarn(&dsid, &j));
26023     +                      %let abscoeff = %sysfunc(abs(&coeff));
26024     +                          %if &abscoeff >  0 %then %do;
26025     +                       put "&_name = &_name+&coeff * (&_varname - &_mean)/&_std;";
26026     +                           %end;
26027     +                 %end;
26028     +             %end;
26029     +             %let rc = %sysfunc(rewind(&dsid));
26030     +         %end;
26031     +
26032     +        %let dsid= %sysfunc(close(&dsid));
26033     +
26034     +     run;
26035     +
26036     +     filename _file_;
26037     +     proc datasets lib = work nolist;
26038     +           delete _tmpindata;
26039     +     run;
26040     +     quit;
26041     +%mend CreateScoreCode2;
26042     +
26043     +
26044     +%macro MakeDeltaCode2(groupds=,deltacodefile=);
26045     +
26046     +     /*--- Build Code to Modify Metadata ---*/
26047     +     filename X "&deltacodefile";
26048     +     data _null_;
26049     +        FILE X;
26050     +        set &groupds end=eof;
26051     +        if _N_=1 then do;
26052     +           %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
26053     +            put "if upcase(strip(ROLE)) ='INPUT' and upcase(strip(LEVEL)) ^='INTERVAL' then ROLE ='REJECTED' ;";
26054     +           %end;
26055     +           put "if upcase(strip(ROLE))='INPUT' and upcase(strip(LEVEL))='INTERVAL' then do;";
26056     +           put "if upcase(strip(NAME)) in (";
26057     +        end;
26058     +        if Strip(upcase(Selected)) eq 'YES' then do;
26059     +           string = '"'!!trim(left(VARIABLE))!!'"';
26060     +           put string;
26061     +        end;
26062     +        if eof then do;
26063     +           put ') then ROLE="INPUT";';
26064     +           put 'else ROLE="REJECTED";';
26065     +           put 'end;';
26066     +
26067     +           %if %upcase(&EM_PROPERTY_HIDEVARIABLE) eq Y %then %do;
26068     +             put 'if upcase(strip(ROLE)) = "REJECTED" then delete ;';
26069     +           %end;
26070     +        end;
26071     +     run;
26072     +     quit;
26073     +
26074     +     filename X;
26075     +     quit;
26076     +%mend MakeDeltaCode2;
26077     +
26078     +%macro getInitialGClusterNumber(indata=, ninput=, ndummy=0, div=100, ngc=);
26079     +  %global &ngc;
26080     +  data _null_;
26081     +  %if &indata ne %then %do;
26082     +      %let dsid = %sysfunc(open(&indata));
26083     +           %let nvar = %sysfunc(attrn(&dsid, NVAR));
26084     +      %let dsid = %sysfunc(close(&dsid));
26085     +  %end;
26086     +  %else %do;
26087     +       %let nvar = %eval(&ninput+&ndummy); ;
26088     +  %end;
26089     +  %let numgc = %eval(&nvar/&div+2);
26090     +  %let &ngc = &numgc;
26091     +   run;
26092     +  quit;
26093     +%mend getInitialGClusterNumber;
26094     +
26095     +
26096     +%macro MakeGobalConstellData(indata=, outlink=, outnode=);
26097     +data &outlink(drop = Selected);
26098     +     set &indata;
26099     +     LINKID = _N_;
26100     +     label LINKID = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_linkid, noquote))" ;
26101     +run;
26102     +data &outnode(keep=NODEID TYPE LABEL);
26103     +    set &indata;
26104     +    length TYPE $16;
26105     +    rename VARIABLE = NODEID;
26106     +    *label  CLUSNAME="Node ID";
26107     +    label CLUSNAME= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;
26108     +    TYPE = "VARIABLE";
26109     +    *label TYPE = "Node Type";
26110     +    label TYPE =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))" ;
26111     +    run;
26112     +data _tmp(keep=NODEID TYPE LABEL);
26113     +    set &indata;
26114     +    length TYPE $16;
26115     +    rename CLUSNAME = NODEID;
26116     +    label  CLUSNAME= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;
26117     +    TYPE = "GCLUSTER";
26118     +    label TYPE = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))" ;
26119     +    run;
26120     +proc sort data=_tmp;
26121     +    by NODEID;
26122     +run;
26123     +data _tmp;
26124     +    set _tmp; by NODEID;
26125     +    if first.NODEID then output;
26126     +run;
26127     +proc sort data=&outnode;
26128     +    by NODEID;
26129     +run;
26130     +data  &outnode;
26131     +    set _tmp &outnode;
26132     +run;
26133     +proc datasets lib = work nolist;
26134     +     delete _tmp;
26135     +run;
26136     +quit;
26137     +%mend MakeGobalConstellData;
26138     +
26139     +/* Make contellation plot data among GCLUSTERS */
26140     +
26141     +%Macro MakeGClusterConstData(indata=, inoutrsq=, outnode=, outlink=);
26142     +
26143     +data &outlink(keep = _NAME_ _PARENT_ _LABEL_ LINKID);
26144     +     set &indata;
26145     +     LINKID = _N_;
26146     +     if upcase(substr(strip(_NAME_),1, 2))="CL" then do;
26147     +        _NAME_ = "ROOT"||upcase(substr(strip(_NAME_),5));
26148     +     end;
26149     +     if _PARENT_ ne " " and upcase(substr(strip(_PARENT_),1, 2))="CL" then do;
26150     +        _PARENT_ = "ROOT"||upcase(substr(strip(_PARENT_),5));
26151     +     end;
26152     +     if upcase(substr(strip(_LABEL_),1, 2))="CL" then do;
26153     +        _LABEL_ = "ROOT"||upcase(substr(strip(_LABEL_),5));
26154     +    end;
26155     +run;
26156     +
26157     +data _tmp_outrsquare;
26158     +        set &inoutrsq;
26159     +        if upcase(strip(TYPE)) = 'CLUSTERCOMP' then delete;
26160     +run;
26161     +
26162     +proc freq data =_tmp_outrsquare noprint;
26163     +         tables GCluster/out=_tmp_GCLUSFREQ(rename=(GCLUSTER=_NAME_));
26164     +run;
26165     +
26166     +data &outnode(keep=_NAME_ TYPE LABEL);
26167     +    set &outlink;
26168     +    length TYPE $16;
26169     +    length LABEL $100;
26170     +    /*label CLUSNAME= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;*/
26171     +
26172     +    if upcase(substr(strip(_NAME_),1, 2))='GC' then do;
26173     +    TYPE = "GCLUSTER";
26174     +    LABEL = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote)):"||_NAME_;
26175     +    end;
26176     +    else do;
26177     +    TYPE= "ROOT";
26178     +    LABEL= _NAME_;
26179     +    end;
26180     +    label TYPE  =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))" ;
26181     +    label LABEL =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_label, noquote))" ;
26182     +    label _NAME_ =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;
26183     +    run;
26184     +
26185     +proc sort data=&outnode;
26186     +     by _NAME_;
26187     +proc sort data=_tmp_GCLUSFREQ;
26188     +     by _NAME_;
26189     +run;
26190     +
26191     +data  &outnode;
26192     +     merge &outnode _tmp_GCLUSFREQ; by _NAME_;
26193     +     if COUNT=. then COUNT=1;
26194     +run;
26195     +
26196     +proc datasets lib = work nolist;
26197     +     delete _tmp_outrsquare _tmp_GCLUSFREQ;
26198     +run;
26199     +
26200     +quit;
26201     +%Mend MakeGClusterConstData;
26202     +
26203     +
26204     +%macro CreateGClusterScoreCode(indata=,  globalclusid=, fileref=);
26205     +
26206     +    data _gscoretmpds;
26207     +          set &indata;
26208     +          if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = 1 ) or (_TYPE_ in ('MEAN' 'STD'));
26209     +          if _TYPE_ = 'MEAN' then _NAME_='MEAN';
26210     +          if _TYPE_ = 'STD' then _NAME_='STD';
26211     +          if _TYPE_ = 'SCORE' then _NAME_ = "GC"||strip(&globalclusid);
26212     +          DROP _TYPE_ _NCL_;
26213     +     run;
26214     +
26215     +    /*  %let gscorefile =  %bquote(&EM_NODEDIR)&EM_DSEP.gclusterscore.sas;
26216     +        GCluster Component &globalclusid ------ */
26217     +
26218     +    filename _file_  "&fileref";
26219     +
26220     +    data _null_;
26221     +        %if &globalclusid eq 1 %then %do;
26222     +          FILE _file_;
26223     +        %end;
26224     +        %else %do;
26225     +          FILE _file_ MOD;
26226     +        %end;
26227     +
26228     +        %let dsid = %sysfunc(open(work._gscoretmpds));
26229     +        %let nvar = %sysfunc(attrn(&dsid, NVAR));
26230     +        %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
26231     +
26232     +        %let k = 1;
26233     +        %do %while(^%sysfunc(fetch(&dsid)));
26234     +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
26235     +                %if &k > 2 %then %do;
26236     +                put "&_name = 0 ; ";
26237     +                %end;
26238     +                %let k = %eval(&k+1);
26239     +        %end;
26240     +
26241     +        %let rc = %sysfunc(rewind(&dsid));
26242     +        %do i= 2 %to &nvar;
26243     +            %let _varname =  %sysfunc(varname(&dsid, &i));
26244     +            %do %while(^%sysfunc(fetch(&dsid)));
26245     +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
26246     +                %if &_name = MEAN %then
26247     +                %let _mean = %sysfunc(getvarn(&dsid, &i));
26248     +                %else %if &_name = STD %then
26249     +                %let _std = %sysfunc(getvarn(&dsid, &i));
26250     +                %else %do;
26251     +                      %let coeff =  %sysfunc(getvarn(&dsid, &i));
26252     +                      %let abscoeff = %sysfunc(abs(&coeff));
26253     +                          %if &abscoeff >  0 %then %do;
26254     +                       put "&_name = &_name+&coeff * (&_varname - &_mean)/&_std;";
26255     +                           %end;
26256     +                 %end;
26257     +             %end;
26258     +             %let rc = %sysfunc(rewind(&dsid));
26259     +
26260     +         %end;
26261     +
26262     +        %let dsid= %sysfunc(close(&dsid));
26263     +       run;
26264     +
26265     +
26266     +       proc datasets lib=work nolist;
26267     +            delete _gscoretmpds;
26268     +       run;
26269     +      quit;
26270     +
26271     +%mend CreateGClusterScoreCode;
26272     +
26273     +
26274     +%macro MakeGClusterCorrelation(Indata=, ngcluster=, gscorecode=, outrsquare=);
26275     +
26276     +   %EM_REGISTER(KEY=GSCORE, TYPE=DATA);
26277     +   %EM_GETNAME(KEY=GSCORE, TYPE=DATA);
26278     +   %EM_REGISTER(KEY=GSCORESTAT, TYPE=DATA);
26279     +   %EM_GETNAME(KEY=GSCORESTAT, TYPE=DATA);
26280     +   %EM_REGISTER(KEY=GSCORETREE, TYPE=DATA);
26281     +   %EM_GETNAME(KEY=GSCORETREE, TYPE=DATA);
26282     +   %EM_REGISTER(KEY=GSCORECORR, TYPE=DATA);
26283     +   %EM_GETNAME(KEY=GSCORECORR, TYPE=DATA);
26284     +   %EM_REGISTER(KEY=GSCORECORRPLOT, TYPE=DATA);
26285     +   %EM_GETNAME(KEY=GSCORECORRPLOT, TYPE=DATA);
26286     +   %EM_REGISTER(KEY=GCLUSLINK, TYPE=DATA);
26287     +   %EM_GETNAME(KEY=GCLUSLINK, TYPE=DATA);
26288     +   %EM_REGISTER(KEY=GCLUSNODE, TYPE=DATA);
26289     +   %EM_GETNAME(KEY=GCLUSNODE, TYPE=DATA);
26290     +
26291     +   filename gsfile "&gscorecode";
26292     +
26293     +   data &EM_USER_GSCORE;
26294     +             set &indata;
26295     +             %include  gsfile;
26296     +        keep
26297     +        %do i=1 %to &ngcluster;
26298     +         %let gcvarname = GC&i;
26299     +         &gcvarname
26300     +        %end;
26301     +     ;
26302     +   run;
26303     +
26304     +   proc varclus data=&EM_USER_GSCORE outstat=&EM_USER_GSCORESTAT outtree=&EM_USER_GSCORETREE
26305     +    %if %upcase(&EM_PROPERTY_CLUSCOMP) eq CENTROID %then %do; centroid %end;
26306     +    %if %upcase(&EM_PROPERTY_CLUSSOURCE) eq COV %then %do; cov %end;
26307     +    %if %upcase(&EM_PROPERTY_CLUSHIERACHY) eq Y %then %do; hi %end;
26308     +    noprint  ;
26309     +     var
26310     +       %do i=1 %to &ngcluster;
26311     +         %let gcvarname = GC&i;
26312     +         &gcvarname
26313     +        %end;
26314     +   ;
26315     +   run;
26316     +
26317     +
26318     +   %MakeVarClusCorrData(statds=&EM_USER_GSCORESTAT, corrds=&EM_USER_GSCORECORR, corrplotds=&EM_USER_GSCORECORRPLOT );
26319     +   data &EM_USER_GSCORECORRPLOT ;
26320     +        set &EM_USER_GSCORECORRPLOT;
26321     +        rename _X_ = X;
26322     +        rename _Y_ = Y;
26323     +        label _X_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
26324     +        label _Y_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
26325     +   run;
26326     +
26327     +   %MakeGClusterConstData(indata=&EM_USER_GSCORETREE, inoutrsq=&outrsquare, outnode=&EM_USER_GCLUSNODE, outlink=&EM_USER_GCLUSLINK);
26328     +
26329     +   data &EM_USER_GSCORETREE;
26330     +        length _NAME_ $32;
26331     +        length _LABEL_ $100;
26332     +        set &EM_USER_GSCORETREE(DROP=_LABEL_);
26333     +        if upcase(substr(strip(_NAME_),1, 2))='GC' then do;
26334     +         _LABEL_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote)):"||_NAME_;
26335     +        end;else do;
26336     +         _LABEL_ = _NAME_;
26337     +        end;
26338     +       label _LABEL_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))";
26339     +
26340     +   run;
26341     +
26342     +   quit;
26343     +
26344     +%mend MakeGClusterCorrelation;
26345     +
26346     +
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(MAIN):  ;
MPRINT(MAIN):   filename temp catalog 'sashelp.emexpl.variableclustering_train.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_TRAIN.SOURCE.
26349     +%macro train;
26351     +   filename temp catalog 'sashelp.emexpl.variableclustering_train1.source';
26352     +   %include temp;
26353     +   filename temp catalog 'sashelp.emexpl.variableclustering_train2.source';
26354     +   %include temp;
26355     +   filename temp catalog 'sashelp.emutil.em_copyfile.source';
26356     +   %include temp;
26357     +   filename temp;
26359     +   %let VARCLUS_MAXNUMOBS = 100000;
26360     +   %let VARCLUS_MAXNUMVAR = 200;
26361     +   %let trainnum = 0;
26362     +   %let error = 0;
26364     +   %if &EM_IMPORT_DATA eq %then %do;
26365     +       %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN,1;
26366     +       %let  error = 1;
26367     +       %goto endtrain;
26368     +   %end;
26370     +    %if (%sysfunc(exist(&EM_IMPORT_DATA)) or %sysfunc(exist(&EM_IMPORT_DATA, VIEW))) < 1 %then %do;
26371     +        %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN,1;
26372     +        %let  error = 1;
26373     +        %goto endline;
26374     +    %end;
26376     +   %let _num_input_interval = %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED);
26377     +   %let _num_input_binary = %eval(&EM_NUM_BINARY_INPUT+&EM_NUM_BINARY_REJECTED);
26378     +   %let _num_input_nominal = %eval(&EM_NUM_NOMINAL_INPUT+&EM_NUM_NOMINAL_REJECTED);
26379     +   %let _num_input_ordinal = %eval(&EM_NUM_ORDINAL_INPUT+&EM_NUM_ORDINAL_REJECTED);
26380     +   %let _num_input_class = %eval(&_num_input_binary+&_num_input_nominal+&_num_input_ordinal);
26381     +   %let _num_input_total = %eval(&_num_input_interval+&_num_input_class);
26383     +   %if (&EM_PROPERTY_INCLUDECLASSVAR eq Y) %then %do;
26384     +        %if  &_num_input_total < 2 %then %do;
26385     +            %let  EMEXCEPTIONSTRING = exception.server.METADATA.USEATLEAST2INPUTREJECT;
26386     +            %let error = 2;
26387     +            %goto endtrain;
26388     +        %end;
26389     +   %end;
26390     +   %else %do;
26391     +         %if  &_num_input_interval < 2 %then %do;
26392     +         %let  EMEXCEPTIONSTRING = exception.server.METADATA.USEATLEAST2INPUTREJECT;
26393     +         %let error = 2;
26394     +         %goto endtrain;
26395     +         %end;
26396     +   %end;
26398     +   %em_checkerror();
26400     +   %if &EMEXCEPTIONSTRING ne %then %do;
26401     +       %goto endtrain;
26402     +   %end;
26404     +   %if (&EM_PROPERTY_INCLUDECLASSVAR eq Y) and (&_num_input_class > 0) %then %do;
26406     +        %EM_GETNAME(key=OUTDUMMY, type=DATA);
26407     +        %MakeDummyVariables( indata=&EM_IMPORT_DATA,
26408     +                             outvar=&EM_USER_OUTDUMMY,
26409     +                             outdata=_newtrainds,
26410     +                             fileref=&EM_FILE_EMFLOWSCORECODE);
26412     +       %if &EM_PROPERTY_SUPPRESSSAMPWARN eq N %then %do;
26413     +           %getNObs(inds=_newtrainds, nobs=_varclus_nobs);
26414     +            %if &_varclus_nobs > &VARCLUS_MAXNUMOBS  %then %do;
26415     +                proc datasets lib=work nolist;
26416     +                delete  _newtrainds;
26417     +                run;
26418     +                quit;
26419     +                %let  EMEXCEPTIONSTRING = exception.server.varclus.sample.warning;
26420     +                %let error = 3;
26421     +               %goto endtrain;
26422     +            %end;
26423     +        %end;
26425     +        %if &EM_PROPERTY_TWOSTAGECLUS eq AUTO %then %do;
26426     +             %getNVar(inds=_newtrainds, nvar=_nvar);
26428     +            %if &_nvar > &VARCLUS_MAXNUMVAR %then %do;
26429     +                %let trainnum = 2;
26430     +            %end;
26431     +            %else %do;
26432     +                %let trainnum = 1;
26433     +            %end;
26434     +        %end;
26435     +    %end;
26436     +    %else %do;
26438     +          %if &EM_PROPERTY_SUPPRESSSAMPWARN eq N %then %do;
26440     +            %getNObs(inds=&EM_IMPORT_DATA, nobs=_varclus_nobs);
26442     +            %if &_varclus_nobs > &VARCLUS_MAXNUMOBS  %then %do;
26444     +                 %let  EMEXCEPTIONSTRING = exception.server.varclus.sample.warning;
26445     +                  %let error = 3;
26446     +                 %goto endtrain;
26447     +            %end;
26448     +        %end;
26451     +         %if &EM_PROPERTY_TWOSTAGECLUS eq AUTO %then %do;
26452     +            /*%getNVar(inds=&EM_IMPORT_DATA, nvar=_nvar);
26453     +              %if &_nvar > &VARCLUS_MAXNUMVAR %then %do;*/
26454     +            %if &EM_NUM_INTERVAL_INPUT > &VARCLUS_MAXNUMVAR %then %do;
26455     +                %let trainnum = 2;
26456     +            %end;
26457     +            %else %do;
26458     +                %let trainnum = 1;
26459     +            %end;
26460     +        %end;
26462     +   %end;
26464     +    %em_checkerror();
26466     +    %if &EMEXCEPTIONSTRING ne %then %do;
26467     +       %let error = 4;
26468     +       %goto endtrain;
26469     +    %end;
26471     +    %CreateVarclusMeta(trainnum=&trainnum);
26473     +    %if &error > 0 %then  %goto endtrain;
26475     +       /* when only EM_PROPERTY_TWOSTAGECLUS eq AUTO &_triannum will be 1 or 2  */
26477     +       %if (&trainnum = 1 ) or %upcase(&EM_PROPERTY_TWOSTAGECLUS) = NO %then %do;
26478     +           %train1;
26479     +       %end;
26480     +       %if (&trainnum = 2 ) or %upcase(&EM_PROPERTY_TWOSTAGECLUS) = YES %then %do;
26481     +           %train2;
26482     +       %end;
26484     +      filename _in  "&EM_FILE_EMFLOWSCORECODE";
26485     +      filename _out "&EM_FILE_EMPUBLISHSCORECODE";
26486     +      data _null_;
26487     +         length line $20000;
26488     +         file _out lrecl=20000;
26489     +         fid=fopen("_in",'i',20000,'v');
26490     +         if fid > 0  then do;
26491     +            do while(^fread(fid));
26492     +               rlen = frlen(fid);
26493     +               rc= fget(fid,line,20000);
26494     +               start = length(line)-length(left(line))+1;
26495     +               line=strip(line);
26496     +               if line ne 'delete;' then do;
26497     +                  put @start line;
26498     +               end;
26499     +            end;
26500     +            if fid > 0  then rc=fclose(fid);
26501     +         end;
26502     +      run;
26503     +      filename _in;
26504     +      filename _out;
26506     +   %endtrain:
26509     +%mend train;
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emexpl.variableclustering_train1.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_TRAIN1.SOURCE.
26511     +%macro VarClus(indata=,
26512     +               outstat=,
26513     +               outtree=,
26514     +               vars=,
26515     +               freq=,
26516     +               weight=,
26517     +               includeclassvar=
26518     +               );
26520     +   %if &vars eq %then
26521     +       %let vars = %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED;
26523     +        /*Add by ruzhan, May 28, 2013*/
26524     +        ods graphics on;
26525     +        %let odspath =;
26526     +        data _null_;
26527     +            path = pathname('WORK');
26528     +            call symput('odspath', path);
26529     +        run;
26530     +        ods listing gpath="&odspath";
26531     +        ods output DENDROGRAM=&outtree;
26532     +       proc varclus data = &indata outstat= &outstat
26533     +        %if %upcase(&EM_PROPERTY_CLUSCOMP) eq CENTROID %then %do; centroid %end;
26534     +        %if %upcase(&EM_PROPERTY_CLUSSOURCE) eq COV %then %do; cov %end;
26535     +        %if %upcase(&EM_PROPERTY_CLUSHIERACHY) eq Y %then %do; hi %end;
26536     +        /*-----------------------
26537     +        %if %upcase(&EM_PROPERTY_MAXCLUS) ne DEFAULT %then %do;
26538     +            %let maxc = %sysevalf(&EM_PROPERTY_MAXCLUS, int);
26539     +            %if &maxc > 1 %then %do;     maxc=&maxc %end;
26540     +       %end;
26541     +       -------------------------*/
26542     +       %if (&EM_PROPERTY_MAXCLUS ne . )  and (%upcase(&EM_PROPERTY_MAXCLUS) ne DEFAULT) %then %do;
26543     +            maxc = &EM_PROPERTY_MAXCLUS
26544     +       %end;
26546     +       /*------------------------------------------------------------------------------------------------------
26547     +        (%upcase(&EM_PROPERTY_MAXCLUS) ne DEFAULT) is needed because of diagram conversion from Em12.1 to 12.3
26548     +        ------------------------------------------------------------------------------------------------------*/
26550     +       %if (%upcase(&EM_PROPERTY_CLUSCOMP) ne CENTROID) and
26551     +           ( ( &EM_PROPERTY_MAXEIGEN ne . )  and (%upcase(&EM_PROPERTY_MAXEIGEN) ne DEFAULT) ) %then %do;
26552     +            maxeigen = &EM_PROPERTY_MAXEIGEN
26553     +       %end;
26555     +       %if &EM_PROPERTY_PROPORTION ne 0  and (%upcase(&EM_PROPERTY_PROPORTION) ne DEFAULT) %then %do;
26556     +            proportion = &EM_PROPERTY_PROPORTION
26557     +       %end;
26558     +       %if %upcase(&EM_PROPERTY_PRINTOPTION) eq SUMMARY %then %do;
26559     +               summary
26560     +       %end;
26562     +       %if %upcase(&EM_PROPERTY_PRINTOPTION) eq SHORT %then %do;
26563     +           short
26564     +       %end;
26565     +        %if %upcase(&EM_PROPERTY_PRINTOPTION) eq ALL %then %do;
26566     +           corr trace simple
26567     +       %end;
26568     +       %if %upcase(&EM_PROPERTY_PRINTOPTION) eq NONE %then %do;
26569     +          noprint
26570     +       %end;
26571     +        /*Comment out by ruzhan, May 28, 2013*/
26572     +       /*       outtree=&outtree*/
26573     +       ;
26574     +        var %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED
26576     +      %if &includeclassvar eq Y %then %do;
26577     +          %let dsid = %sysfunc(open(&EM_USER_OUTDUMMY));
26578     +          %if &dsid > 0 %then %do;
26579     +             %let nvar = %sysfunc(attrn(&dsid, NVAR));
26580     +              %do i = 2 %to &nvar;
26581     +                  %let varname = %sysfunc(varname(&dsid, &i));
26582     +                   &varname
26583     +              %end;
26585     +          %end;
26586     +      %end;
26588     +      ;
26589     +      /*------------------------
26590     +      %if &freq ne  %then %do;
26591     +          freq &freq;
26592     +      %end;
26593     +      %if &weight ne  %then %do;
26594     +          weight &weight;
26595     +      %end;
26596     +      ----------------------------*/
26597     +      %if %EM_FREQ ne %then %do;
26598     +           Freq %EM_FREQ;
26599     +      %end;
26600     +      ;
26601     +    run;
26602     +    ods graphics off;
26603     +    %endline:
26604     +    quit;
26605     +%mend VarClus;
26607     +%macro Train1;
26609     +   %EM_GETNAME(key=OUTCORRPLOT, type=DATA) ;
26610     +   %EM_GETNAME(key=OUTCORR, type=DATA) ;
26611     +   %EM_GETNAME(key=OUTSTAT, type=DATA) ;
26612     +   %EM_GETNAME(key=OUTGROUP, type=DATA) ;
26613     +   %EM_GETNAME(key=OUTSTATPLOT, type=DATA) ;
26614     +   %EM_GETNAME(key=OUTTREE, type=DATA) ;
26615     +   %EM_GETNAME(key=OUTRSQUARE, type=DATA) ;
26616     +   %EM_GETNAME(key=OUTCLUSSTRUCT, type=DATA) ;
26617     +   %EM_GETNAME(key=OUTCLUSCORR, type=DATA) ;
26618     +   %EM_GETNAME(key=OUTCLUSCORRPLOT, type=DATA) ;
26619     +   %EM_GETNAME(key=OUTCLUSRSQUARE, type=DATA) ;
26620     +   %EM_GETNAME(key=OUTLINK, type=DATA) ;
26621     +   %EM_GETNAME(key=OUTNODE, type=DATA) ;
26623     +   /*
26624     +     %let VARCLUS_MAXNUMOBS = 100;
26625     +     %let VARCLUS_MAXNUMVAR = 200;
26626     +   */
26628     +   /* Train
26630     +   %if &EM_IMPORT_DATA eq %then %do;
26631     +       %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN,1;
26632     +       %goto endtrain1;
26633     +   %end;
26635     +   %if  &EM_NUM_INTERVAL_INPUT < 2 %then %do;
26636     +        %let  EMEXCEPTIONSTRING = exception.server.METADATA.USEATLEAST2INPUTREJECT;
26637     +        %goto endtrain1;
26638     +   %end;
26639     +   */
26640     +   %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
26641     +       /* moved this to pretrain ------------
26643     +        %EM_GETNAME(key=OUTDUMMY, type=DATA);
26644     +        %MakeDummyVariables( indata=&EM_IMPORT_DATA,
26645     +                             outvar=&EM_USER_OUTDUMMY,
26646     +                             outdata=_newtrainds,
26647     +                             fileref=&EM_FILE_EMFLOWSCORECODE);
26649     +        %if &EM_PROPERTY_SUPPRESSSAMPWARN eq N %then %do;
26650     +            %getNVarNObs(inds=_newtrainds, nvar=_nvar, nobs=_nobs);
26651     +            %if &_nobs > &VARCLUS_MAXNUMOBS ne %then %do;
26652     +                %let  EMEXCEPTIONSTRING = exception.server.varclus.sample.warning
26653     +                %goto endtrain;
26654     +            %end;
26655     +        %end;
26657     +        +-------------------------------------*/
26659     +        %if (%sysfunc(exist(_newtrainds)) or %sysfunc(exist(_newtrainds, VIEW))) < 1 %then %do;
26660     +        /*when there is no class var and &EM_PROPERTY_INCLUDECLASSVAR eq Y
26661     +          There is no _newtrainds */
26662     +         %VarClus( indata=&EM_IMPORT_DATA,
26663     +                  outstat=&EM_USER_OUTSTAT,
26664     +                  outtree = &EM_USER_OUTTREE,
26665     +                  includeclassvar=N
26666     +                 );
26667     +        %end;
26668     +        %else %do;
26669     +        %VarClus( indata=_newtrainds,
26670     +                  outstat=&EM_USER_OUTSTAT,
26671     +                  outtree = &EM_USER_OUTTREE,
26672     +                  includeclassvar=Y
26673     +                 );
26674     +         proc datasets lib=work nolist;
26675     +              delete  _newtrainds;
26676     +         run;
26677     +         %end;
26678     +    %end;
26679     +    %else %do;
26681     +        /*----- moved this to pretrain ------------
26682     +        %if &EM_PROPERTY_SUPPRESSSAMPWARN eq N %then %do;
26683     +            %getNVarNObs(inds=&EM_IMPORT_DATA, nvar=_nvar, nobs=_nobs);
26684     +            %if &_nobs > &VARCLUS_MAXNUMOBS ne %then %do;
26685     +                 %let  EMEXCEPTIONSTRING = exception.server.varclus.sample.warning;
26686     +                 %goto endtrain;
26687     +            %end;
26688     +        %end;
26689     +        +-------------------------------------*/
26691     +        %VarClus(indata=&EM_IMPORT_DATA,
26692     +                  outstat=&EM_USER_OUTSTAT,
26693     +                  outtree =&EM_USER_OUTTREE,
26694     +                  includeclassvar=N
26695     +               );
26697     +   %end;
26699     +   %em_checkerror();
26701     +   %if &EMEXCEPTIONSTRING ne %then %do;
26702     +       %goto endtrain1;
26703     +   %end;
26704     +    /*
26705     +    %FindClusNum(statds=&EM_USER_OUTSTAT, groupds=&EM_USER_OUTGROUP, minvariation=&EM_PROPERTY_MINVARIATION);
26706     +    */
26708     +    %getNclusfromTrain(inoutstat=&EM_USER_OUTSTAT, nc=_nclus);
26710     +    %let gid=;
26712     +    /*--- To make the main result table ----------------------*/
26714     +    %MakeInterClusCorrData(indata=&EM_USER_OUTSTAT, globalclusid=&gid, outdata=&EM_USER_OUTCLUSCORR, ncluster=&_nclus, RSquare=Y);
26715     +    %FindNextClosestClusByCluster(indata=&EM_USER_OUTCLUSCORR, outdata=_nextClusRSq, globalclusid=&gid, ncluster=&_nclus);
26716     +    %MakeOwnRSquare(indata=&EM_USER_OUTSTAT, globalclusid=&gid, outdata=_ownRsq, ncluster=&_nclus);
26717     +    %MakeClusStructCorrData(indata=&EM_USER_OUTSTAT, globalclusid=&gid, outdata=&EM_USER_OUTCLUSSTRUCT , ncluster=&_nclus, Rsquare=Y);
26718     +    %FindNextClosestClusByVar(indata=&EM_USER_OUTCLUSSTRUCT, outdata=_nextVarRSq, globalclusid=&gid, ncluster=&_nclus);
26719     +    %MakeVarClusResultTable(indata1=_ownRsq, indata2=_nextVarRsq, indata3=_nextClusRSq, outdata=&EM_USER_OUTRSQUARE, globalclusid=&gid, ncluster=&_nclus, selectedcomp=&EM_PROPERTY_EXPORTEDCOMP);
26721     +   /* Inter Cluster Correlation Plot ------------------------*/
26723     +    %MakeInterClusCorrData(indata=&EM_USER_OUTSTAT, globalclusid=&gid, outdata=&EM_USER_OUTCLUSCORRPLOT, ncluster=&_nclus, RSquare=N);
26724     +    %MakePlotDataFromCorrTable(indata=&EM_USER_OUTCLUSCORRPLOT, outdata=&EM_USER_OUTCLUSCORRPLOT, globalclusid=&gid);
26726     +   /* Create some other data sets for results ----*/
26728     +   %MakeStatPlotData(statds=&EM_USER_OUTSTAT , outstatplotds=&EM_USER_OUTSTATPLOT);
26729     +   %MakeVarClusCorrData(statds=&EM_USER_OUTSTAT, corrds=&EM_USER_OUTCORR, corrplotds=&EM_USER_OUTCORRPLOT);
26730     +   %MakeClusConstellData(indata=&EM_USER_OUTRSQUARE, outlink=&EM_USER_OUTLINK, outnode=&EM_USER_OUTNODE);
26732     +  /*---- move this to Score action ------------
26733     +   %MakeDeltaCode(groupds=&EM_USER_OUTRSQUARE, DeltaCodeFile=&EM_FILE_CDELTA_TRAIN);
26734     +   */
26736     +   /* create score code at training time */
26737     +   %CreateScoreCode(indata=&EM_USER_OUTSTAT, ncluscomp=&_nclus, fileref=&EM_FILE_EMFLOWSCORECODE);
26738     +   %endtrain1:
26739     +%mend Train1;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emexpl.variableclustering_train2.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_TRAIN2.SOURCE.
26742     +%macro VarClus2( indata=,
26743     +                 outdata=,
26744     +                 outstat =outstat,
26745     +                 outrsquare=outrsquare,
26746     +                 outtree = outtree,
26747     +                 outclusstruct = outclusstruct,
26748     +                 outcluscorr =outcluscorr,
26749     +                 outcluscorrplot =outcluscorrplot,
26750     +                 outclusrsquare =outclusrsquare,
26751     +                 outstatplot = outstatplot,
26752     +                 outcorr = outcorr,
26753     +                 outcorrplot = outcorrplot,
26754     +                 clusdata=,
26755     +                 outnode=outnode,
26756     +                 outlink=outlink,
26757     +                 ngroup =1  );
26758     +         %if (%sysfunc(exist(&indata)) or %sysfunc(exist(&indata, VIEW))) < 1 %then %do;
26759     +              %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN,1;
26760     +              %goto endline;
26761     +         %end;
26763     +        %global numglobalcluster;
26764     +        %let  numglobalcluster = &ngroup;
26765     +        %let  gscorefile =  %bquote(&EM_NODEDIR)&EM_DSEP.gclusterscore.sas;
26766     +        %do vci =1 %to &ngroup;
26767     +           data tmp_clusdata;
26768     +                set &clusdata;
26769     +                if CLUSTER ne &vci then delete;
26770     +           run;
26771     +           %let outstatds = &outstat.&vci;
26772     +           %let outrsquareds = &outrsquare.&vci;
26773     +           %let outtreeds = &outtree.&vci;
26774     +           %let outclusstuctds = &outclusstruct.&vci;
26775     +           %let outcluscorrds = &outcluscorr.&vci;
26776     +           %let outcluscorrplotds = &outcluscorrplot.&vci;
26777     +           %let outclusrsquareds = &outclussquare.&vci;
26778     +           %let outstatplotds = &outstatplot.&vci;
26779     +           %let outcorrds = &outcorr.&vci;
26780     +           %let outcorrplotds = &outcorrplot.&vci;
26781     +           %let outnodeds = &outnode.&vci;
26782     +           %let outlinkds = &outlink.&vci;
26784     +           %EM_REGISTER(KEY=&outstatds, TYPE=DATA);
26785     +           %EM_GETNAME(KEY=&outstatds, TYPE=DATA);
26786     +           %let emuseroutstat = &EM_USER_&outstatds;
26788     +           %EM_REGISTER(KEY=&outtreeds, TYPE=DATA);
26789     +           %EM_GETNAME(KEY=&outtreeds, TYPE=DATA);
26790     +           %let emuserouttree = &EM_USER_&outtreeds;
26792     +           %EM_REGISTER(KEY=&outcluscorrds, TYPE=DATA);
26793     +           %EM_GETNAME(KEY=&outcluscorrds, TYPE=DATA);
26794     +           %let emuseroutcluscorr = &EM_USER_&outcluscorrds;
26796     +           %EM_REGISTER(KEY=&outclusstuctds, TYPE=DATA);
26797     +           %EM_GETNAME(KEY=&outclusstuctds, TYPE=DATA);
26798     +           %let emuseroutclusstruct = &EM_USER_&outclusstuctds;
26800     +           %EM_REGISTER(KEY=&outrsquareds, TYPE=DATA);
26801     +           %EM_GETNAME(KEY=&outrsquareds, TYPE=DATA);
26802     +           %let emuseroutrsquare = &EM_USER_&outrsquareds;
26804     +           %EM_REGISTER(KEY=&outcluscorrplotds, TYPE=DATA);
26805     +           %EM_GETNAME(KEY=&outcluscorrplotds, TYPE=DATA);
26806     +           %let emuseroutcluscorrplot = &EM_USER_&outcluscorrplotds;
26808     +           %EM_REGISTER(KEY=&outstatplotds, TYPE=DATA);
26809     +           %EM_GETNAME(KEY=&outstatplotds, TYPE=DATA);
26810     +           %let emuseroutstatplot = &EM_USER_&outstatplotds;
26812     +           %EM_REGISTER(KEY=&outcorrds, TYPE=DATA);
26813     +           %EM_GETNAME(KEY=&outcorrds, TYPE=DATA);
26814     +           %let emuseroutcorr = &EM_USER_&outcorrds;
26816     +           %EM_REGISTER(KEY=&outcorrplotds, TYPE=DATA);
26817     +           %EM_GETNAME(KEY=&outcorrplotds, TYPE=DATA);
26818     +           %let emuseroutcorrplot = &EM_USER_&outcorrplotds;
26820     +           %EM_REGISTER(KEY=&outnodeds, TYPE=DATA);
26821     +           %EM_GETNAME(KEY=&outnodeds, TYPE=DATA);
26822     +           %let emuseroutnode = &EM_USER_&outnodeds;
26824     +           %EM_REGISTER(KEY=&outlinkds, TYPE=DATA);
26825     +           %EM_GETNAME(KEY=&outlinkds, TYPE=DATA);
26826     +           %let emuseroutlink = &EM_USER_&outlinkds;
26828     +           /*Add by ruzhan, May 28, 2013*/
26829     +           ods graphics on;
26830     +            %let odspath =;
26831     +            data _null_;
26832     +                path = pathname('WORK');
26833     +                call symput('odspath', path);
26834     +            run;
26835     +            ods listing gpath="&odspath";
26837     +           ods output DENDROGRAM=&emuserouttree;
26839     +           proc varclus data=&indata outstat=&emuseroutstat
26840     +            %if %upcase(&EM_PROPERTY_CLUSCOMP) eq CENTROID %then %do; centroid %end;
26841     +            %if %upcase(&EM_PROPERTY_CLUSSOURCE) eq COV %then %do; cov %end;
26842     +            %if %upcase(&EM_PROPERTY_CLUSHIERACHY) eq Y %then %do; hi %end;
26843     +            %if (&EM_PROPERTY_MAXCLUS ne .)  and (%upcase(&EM_PROPERTY_MAXCLUS) ne DEFAULT) %then %do;
26844     +                  maxc=&EM_PROPERTY_MAXCLUS
26845     +           %end;
26847     +            %if (%upcase(&EM_PROPERTY_CLUSCOMP) ne CENTROID) and
26848     +                ( (&EM_PROPERTY_MAXEIGEN ne .)  and (%upcase(&EM_PROPERTY_MAXEIGEN) ne DEFAULT)) %then %do;
26849     +            maxeigen = &EM_PROPERTY_MAXEIGEN
26850     +            %end;
26852     +           %if (&EM_PROPERTY_PROPORTION ne 0)  and (%upcase(&EM_PROPERTY_PROPORTION) ne DEFAULT) %then %do;
26853     +                proportion = &EM_PROPERTY_PROPORTION
26854     +           %end;
26855     +           %if %upcase(&EM_PROPERTY_PRINTOPTION) eq SUMMARY %then %do;
26856     +               summary
26857     +           %end;
26858     +           %if %upcase(&EM_PROPERTY_PRINTOPTION) eq SHORT %then %do;
26859     +               short
26860     +           %end;
26861     +            %if %upcase(&EM_PROPERTY_PRINTOPTION) eq ALL %then %do;
26862     +               corr trace simple
26863     +           %end;
26864     +           %if %upcase(&EM_PROPERTY_PRINTOPTION) eq NONE %then %do;
26865     +               noprint
26866     +           %end;
26867     +            /*Comment out by ruzhan, May 28, 2013*/
26868     +              /*outtree=&emuserouttree*/
26869     +           ;
26870     +           var
26871     +           %let dsid=%sysfunc(open(work.tmp_clusdata));
26872     +           %let vn_name =%sysfunc(varnum(&dsid, VARIABLE));
26873     +                %do %while(^%sysfunc(fetch(&dsid)));
26874     +                    %let _varname= %sysfunc(getvarc(&dsid, &vn_name));
26875     +                    &_varname
26876     +                %end;
26877     +            %let dsid = %sysfunc(close(&dsid));
26878     +           ;
26879     +           %if %EM_FREQ ne %then %do;
26880     +           Freq %EM_FREQ;
26881     +           %end;
26882     +           run;
26883     +            ods graphics off;
26884     +            %getNclusfromTrain(inoutstat=&emuseroutstat, nc=_nclus);
26886     +            %let gid=&vci;
26887     +            /*--- To make the main result table ----------------------*/
26888     +            %MakeInterClusCorrData(indata=&emuseroutstat, globalclusid=&gid, outdata=&emuseroutcluscorr, ncluster=&_nclus, RSquare=Y);
26889     +            %FindNextClosestClusByCluster(indata=&emuseroutcluscorr, outdata=_nextClusRSq, globalclusid=&gid, ncluster=&_nclus);
26890     +            %MakeOwnRSquare(indata=&emuseroutstat, globalclusid=&gid, outdata=_ownRsq, ncluster=&_nclus);
26891     +            %MakeClusStructCorrData(indata=&emuseroutstat, globalclusid=&gid, outdata=&emuseroutclusstruct , ncluster=&_nclus, Rsquare=Y);
26892     +            %FindNextClosestClusByVar(indata=&emuseroutclusstruct, outdata=_nextVarRSq, globalclusid=&gid, ncluster=&_nclus);
26893     +            %MakeVarClusResultTable(indata1=_ownRsq, indata2=_nextVarRsq, indata3=_nextClusRSq, outdata=&emuseroutrsquare, globalclusid=&gid, ncluster=&_nclus, selectedcomp=&EM_PROPERTY_EXPORTEDCOMP);
26895     +            /* Inter Cluster Correlation Plot ------------------------*/
26897     +            %MakeInterClusCorrData(indata=&emuseroutstat, globalclusid=&gid, outdata=&emuseroutcluscorrplot, ncluster=&_nclus, RSquare=N);
26898     +            %MakePlotDataFromCorrTable(indata=&emuseroutcluscorrplot, outdata=&emuseroutcluscorrplot, globalclusid=&gid);
26900     +           /* Create some other data sets for results ---------------*/
26902     +           %MakeStatPlotData(statds=&emuseroutstat , outstatplotds=&emuseroutstatplot);
26903     +           %MakeVarClusCorrData(statds=&emuseroutstat, corrds=&emuseroutcorr, corrplotds=&emuseroutcorrplot);
26904     +           %MakeClusConstellData(indata=&emuseroutrsquare, outlink=&emuseroutlink, outnode=&emuseroutnode);
26906     +           %CreateScoreCode2(indata=&emuseroutstat, ncluscomp=&_nclus, globalclusid=&gid, fileref=&EM_FILE_EMFLOWSCORECODE);
26908     +           %CreateGClusterScoreCode(indata=&emuseroutstat,  globalclusid=&gid, fileref=&gscorefile);
26910     +           %if &vci = 1 %then %do;
26911     +           data &EM_USER_OUTRSQUARE;
26912     +                set &emuseroutrsquare;
26913     +           run;
26914     +           %end;
26915     +           %else %do;
26916     +           data &EM_USER_OUTRSQUARE;
26917     +                set &EM_USER_OUTRSQUARE &emuseroutrsquare;
26918     +           run;
26919     +           %end;
26920     +           quit;
26921     +       %end;
26923     +       /*---- move this to Score action ------------
26924     +       %MakeDeltaCode2(groupds=&EM_USER_OUTRSQUARE, DeltaCodeFile=&EM_FILE_CDELTA_TRAIN);
26925     +       */
26927     +       /* Make Score Gcluster component & correlation  */
26928     +       %MakeGClusterCorrelation(Indata=&indata, ngcluster=&ngroup, gscorecode=&gscorefile, outrsquare=&EM_USER_OUTRSQUARE);
26930     +       quit;
26931     +       %endline:
26932     +%mend VarClus2;
26935     +%macro Train2;
26937     +   %EM_GETNAME(key=OUTCORRPLOT, type=DATA) ;
26938     +   %EM_GETNAME(key=OUTCORR, type=DATA) ;
26939     +   %EM_GETNAME(key=OUTSTAT, type=DATA) ;
26940     +   %EM_GETNAME(key=OUTGROUP, type=DATA) ;
26941     +   %EM_GETNAME(key=OUTSTATPLOT, type=DATA) ;
26942     +   %EM_GETNAME(key=OUTTREE, type=DATA) ;
26943     +   %EM_GETNAME(key=OUTRSQUARE, type=DATA) ;
26944     +   %EM_GETNAME(key=OUTCLUSSTRUCT, type=DATA) ;
26945     +   %EM_GETNAME(key=OUTCLUSCORR, type=DATA) ;
26946     +   %EM_GETNAME(key=OUTCLUSCORRPLOT, type=DATA) ;
26947     +   %EM_GETNAME(key=OUTCLUSRSQUARE, type=DATA) ;
26948     +   %EM_GETNAME(key=GOUTSTAT, type=DATA) ;
26949     +   %EM_GETNAME(key=GOUTTREE, type=DATA) ;
26950     +   %EM_GETNAME(key=GOUTCORR, type=DATA) ;
26951     +   %EM_GETNAME(key=GOUTGROUP, type=DATA) ;
26952     +   %EM_GETNAME(key=GOUTNODE, type=DATA) ;
26953     +   %EM_GETNAME(key=GOUTLINK, type=DATA) ;
26954     +   %EM_GETNAME(key=VARCLUSMETA, type=DATA) ;
26958     +    /* Train */
26960     +   /* moved to pretrain ------------
26962     +   %if &EM_IMPORT_DATA eq %then %do;
26963     +       %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN,1;
26964     +       %goto endtrain2;
26965     +   %end;
26967     +   %if  &EM_NUM_INTERVAL_INPUT < 2 %then %do;
26968     +        %let  EMEXCEPTIONSTRING = exception.server.METADATA.USEATLEAST2INPUTREJECT;
26969     +        %goto endtrain2;
26970     +   %end;
26971     +   +-------------------------------------------*/
26973     +    %let _num_input_interval = %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED);
26976     +    %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
26978     +        /*----- moved to pretrain ------------
26980     +        %EM_GETNAME(key=OUTDUMMY, type=DATA);
26981     +        %MakeDummyVariables( indata=&EM_IMPORT_DATA,
26982     +                             outvar=&EM_USER_OUTDUMMY,
26983     +                             outdata=_newtrainds,
26984     +                             fileref=&EM_FILE_EMFLOWSCORECODE,
26985     +                              ndummyvars=_ndummyvars
26986     +                            );
26988     +        %if &EM_PROPERTY_SUPPRESSSAMPWARN eq N %then %do;
26989     +            %getNVarNObs(inds=_newtrainds, nvar=_nvar, nobs=_nobs);
26990     +            %if &_nobs > &VARCLUS_MAXNUMOBS  %then %do;
26991     +                %let  EMEXCEPTIONSTRING = exception.server.varclus.sample.warning
26992     +                %goto endtrain;
26993     +            %end;
26994     +        %end;
26996     +        +---------------------------------------*/
26997     +        %if (%sysfunc(exist(_newtrainds)) or %sysfunc(exist(_newtrainds, VIEW))) < 1 %then %do;
26998     +        /*when there is no class var and &EM_PROPERTY_INCLUDECLASSVAR eq Y
26999     +          There is no _newtrainds */
27000     +        %MakeCorrelation(    indata=&EM_IMPORT_DATA,
27001     +                             outstat=&EM_USER_GOUTSTAT,
27002     +                             corrmatrix=Y,
27003     +                             outcorr=&EM_USER_GOUTCORR,
27004     +                             includeclassvar=N,
27005     +                             freq =%EM_FREQ
27006     +                          );
27007     +        %getInitialGClusterNumber(ninput=&_num_input_interval, ngc=_ngc);
27009     +        %end;
27010     +        %else %do;
27011     +         %MakeCorrelation(   indata=_newtrainds,
27012     +                             outstat=&EM_USER_GOUTSTAT,
27013     +                             corrmatrix=Y,
27014     +                             outcorr=&EM_USER_GOUTCORR,
27015     +                             includeclassvar=Y,
27016     +                             freq =%EM_FREQ
27017     +                          );
27018     +        %getInitialGClusterNumber(ninput=&_num_input_interval, ndummy=&_ndummyvars, ngc=_ngc);
27020     +        %end;
27022     +    %end;
27023     +    %else %do;
27025     +        /* moved to pretrain -------------------
27027     +         %if &EM_PROPERTY_SUPPRESSSAMPWARN eq N %then %do;
27028     +            %getNVarNObs(inds=&EM_IMPORT_DATA, nvar=_nvar, nobs=_nobs);
27029     +            %if &_nobs > &VARCLUS_MAXNUMOBS  %then %do;
27030     +                %let  EMEXCEPTIONSTRING = exception.server.varclus.sample.warning
27031     +                %goto endtrain;
27032     +            %end;
27033     +        %end;
27034     +         +------------------------------------------*/
27036     +        %MakeCorrelation( indata=&EM_IMPORT_DATA,
27037     +                          outstat=&EM_USER_GOUTSTAT,
27038     +                          corrmatrix=Y,
27039     +                          outcorr=&EM_USER_GOUTCORR,
27040     +                          includeclassvar=N,
27041     +                          freq =%EM_FREQ
27042     +                          );
27043     +        %getInitialGClusterNumber(ninput=&_num_input_interval, ngc=_ngc);
27044     +    %end;
27046     +   %UpdateOutStatCorrToDistance(indata=&EM_USER_GOUTSTAT, /* indata should be a outstat from proc varclus */
27047     +                                rsquare = N
27048     +                                );
27049     +   %HierClusWithCorr( indata=&EM_USER_GOUTSTAT ,
27050     +                      ncluster=&_ngc,
27051     +                      method = Ward,
27052     +                      outtree =&EM_USER_GOUTTREE,
27053     +                      idvar = _VAR_,
27054     +                      outdata=&EM_USER_GOUTGROUP,
27055     +                      rescore = N,
27056     +                      newncluster=_newnclus
27057     +                        );
27059     +   /* store the number of global cluster */
27061     +   data &EM_USER_VARCLUSMETA;
27062     +        set &EM_USER_VARCLUSMETA;
27063     +        NGCluster = &_newnclus;
27064     +   run;
27066     +   %MakeGobalConstellData(indata=&EM_USER_GOUTGROUP, outlink=&EM_USER_GOUTLINK, outnode=&EM_USER_GOUTNODE);
27068     +   %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
27069     +        %if (%sysfunc(exist(_newtrainds)) or %sysfunc(exist(_newtrainds, VIEW))) < 1 %then %do;
27070     +            %VarClus2(indata=&EM_IMPORT_DATA,
27071     +                 clusdata=&EM_USER_GOUTGROUP,
27072     +                 ngroup=&_newnclus);
27073     +         %end;
27074     +         %else %do;
27075     +             %VarClus2(indata=_newtrainds,
27076     +                 clusdata=&EM_USER_GOUTGROUP,
27077     +                 ngroup=&_newnclus);
27079     +         %end;
27081     +   %end;
27082     +   %else %do;
27083     +       %VarClus2(indata=&EM_IMPORT_DATA,
27084     +                 clusdata=&EM_USER_GOUTGROUP,
27085     +                 ngroup=&_newnclus);
27086     +   %end;
27088     +   %em_checkerror();
27089     +   %if &EMEXCEPTIONSTRING ne %then %do;
27090     +       %put &em_codebar;
27091     +       %put Error: Variable clustering failed.;
27092     +       %put &em_codebar;
27093     +       %goto endtrain2;
27094     +   %end;
27095     +   /*
27096     +    %FindClusNum(statds=&EM_USER_OUTSTAT, groupds=&EM_USER_OUTGROUP, minvariation=&EM_PROPERTY_MINVARIATION);
27097     +   */
27098     +   %endtrain2:
27099     +%mend Train2;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename temp catalog 'sashelp.emutil.em_copyfile.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMUTIL.EM_COPYFILE.SOURCE.
27101     +%macro em_copyfile(infref=, outfref=, append=N);
27102     +
27103     +   %if %sysfunc(fileref(&infref))=0 and %sysfunc(fileref(&outfref))<=0 %then %do;
27104     +
27105     +       %let omode =;
27106     +       %if &append=Y %then
27107     +           %let omode = MOD;
27108     +       data _null_;
27109     +          length line $20000;
27110     +          file &outfref &omode lrecl=20000;
27111     +          fid=fopen("&infref",'i',20000,'v');
27112     +          if fid > 0  then do;
27113     +             do while(^fread(fid));
27114     +                rlen = frlen(fid);
27115     +                rc= fget(fid,line,20000);
27116     +                start = length(line)-length(left(line))+1;
27117     +                line=strip(line);
27118     +                put @start line;
27119     +             end;
27120     +             if fid > 0  then rc=fclose(fid);
27121     +          end;
27122     +       run;
27123     +
27124     +   %end;
27125     +%mend em_copyfile;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(EM_CHECKERROR):   proc display c=sashelp.emutil.checkerror.scl;
MPRINT(EM_CHECKERROR):   run;

27126      %let SYSCC = 0;
NOTE: PROCEDURE DISPLAY used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CHECKERROR):   
MPRINT(TRAIN):  ;
MPRINT(GETNOBS):   data _null_;
MPRINT(GETNOBS):   set EMWS1.Varsel_TRAIN end=eof;
MPRINT(GETNOBS):   if eof then call symput("_varclus_nobs", _N_);
MPRINT(GETNOBS):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      4:40   
NOTE: View EMWS1.VARSEL_TRAIN.VIEW used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      
NOTE: There were 2979 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 2979 observations read from the data set EMWS1.VARSEL_TRAIN.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.04 seconds
      

MPRINT(GETNOBS):   quit;
MPRINT(TRAIN):  ;
MPRINT(EM_CHECKERROR):   proc display c=sashelp.emutil.checkerror.scl;
MPRINT(EM_CHECKERROR):   run;

27127      %let SYSCC = 0;
NOTE: PROCEDURE DISPLAY used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CHECKERROR):   
MPRINT(TRAIN):  ;
MPRINT(CREATEVARCLUSMETA):  ;
MPRINT(CREATEVARCLUSMETA):   data EMWS1.VarClus_VARCLUSMETA;
MPRINT(CREATEVARCLUSMETA):   length TrainNum 8.;
MPRINT(CREATEVARCLUSMETA):   length NewTrain $8;
MPRINT(CREATEVARCLUSMETA):   length NGCluster 8.;
MPRINT(CREATEVARCLUSMETA):   length ExportedComp $16;
MPRINT(CREATEVARCLUSMETA):   length HideVariable $8;
MPRINT(CREATEVARCLUSMETA):   TrainNum = 1;
MPRINT(CREATEVARCLUSMETA):   NewTrain = "Y";
MPRINT(CREATEVARCLUSMETA):   ExportedComp = "BESTVARWITHCOMP";
MPRINT(CREATEVARCLUSMETA):   HideVariable = "Y";
MPRINT(CREATEVARCLUSMETA):   NGCluster = 0;
MPRINT(CREATEVARCLUSMETA):   run;

NOTE: The data set EMWS1.VARCLUS_VARCLUSMETA has 1 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(CREATEVARCLUSMETA):   quit;
MPRINT(TRAIN):  ;
MPRINT(TRAIN1):   ;
MPRINT(TRAIN1):   ;
MPRINT(TRAIN1):   ;
MPRINT(TRAIN1):   ;
MPRINT(TRAIN1):   ;
MPRINT(TRAIN1):   ;
MPRINT(TRAIN1):   ;
MPRINT(TRAIN1):   ;
MPRINT(TRAIN1):   ;
MPRINT(TRAIN1):   ;
MPRINT(TRAIN1):   ;
MPRINT(TRAIN1):   ;
MPRINT(TRAIN1):   ;
MPRINT(VARCLUS):   ods graphics on;
MPRINT(VARCLUS):   data _null_;
MPRINT(VARCLUS):   path = pathname('WORK');
MPRINT(VARCLUS):   call symput('odspath', path);
MPRINT(VARCLUS):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(VARCLUS):   ods listing gpath="C:\Users\JOSECA~1\AppData\Local\Temp\SAS Temporary Files\_TD7224_DESKTOP-97HB97B_\Prc2                                                                                                                  ";
MPRINT(VARCLUS):   ods output DENDROGRAM=EMWS1.VarClus_OUTTREE;
MPRINT(VARCLUS):   proc varclus data = EMWS1.Varsel_TRAIN outstat= EMWS1.VarClus_OUTSTAT hi short ;
MPRINT(VARCLUS):   var
MPRINT(EM_INTERVAL_INPUT):   CLAGE DEBTINC MORTDUE VALUE
MPRINT(VARCLUS):   ;
MPRINT(VARCLUS):   ;
MPRINT(VARCLUS):   run;

WARNING: 889 of 2979 observations in data set EMWS1.VARSEL_TRAIN omitted due to missing values.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: View EMWS1.VARSEL_TRAIN.VIEW used (Total process time):
      real time           9.08 seconds
      cpu time            0.28 seconds
      
NOTE: There were 2979 observations read from the data set EMWS1.PART_TRAIN.
NOTE: The data set EMWS1.VARCLUS_OUTTREE has 6 observations and 3 variables.
NOTE: The data set EMWS1.VARCLUS_OUTSTAT has 26 observations and 7 variables.
NOTE: The PROCEDURE VARCLUS printed page 2.
NOTE: PROCEDURE VARCLUS used (Total process time):
      real time           9.16 seconds
      cpu time            0.28 seconds
      

MPRINT(VARCLUS):   ods graphics off;
MPRINT(VARCLUS):   quit;
MPRINT(TRAIN1):  ;
MPRINT(EM_CHECKERROR):   proc display c=sashelp.emutil.checkerror.scl;
MPRINT(EM_CHECKERROR):   run;

27128      %let SYSCC = 0;
NOTE: PROCEDURE DISPLAY used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CHECKERROR):   
MPRINT(TRAIN1):  ;
MPRINT(GETNCLUSFROMTRAIN):   data _null_;
MPRINT(GETNCLUSFROMTRAIN):   set EMWS1.VarClus_OUTSTAT end=eof;
MPRINT(GETNCLUSFROMTRAIN):   if eof then do;
MPRINT(GETNCLUSFROMTRAIN):   call symput("_nclus", _ncl_);
MPRINT(GETNCLUSFROMTRAIN):   end;
MPRINT(GETNCLUSFROMTRAIN):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      5:214   
NOTE: There were 26 observations read from the data set EMWS1.VARCLUS_OUTSTAT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN1):  ;
MPRINT(MAKEINTERCLUSCORRDATA):   data EMWS1.VarClus_OUTCLUSCORR(drop= _NCL_ _TYPE_);
MPRINT(MAKEINTERCLUSCORRDATA):   set EMWS1.VarClus_OUTSTAT;
MPRINT(MAKEINTERCLUSCORRDATA):   if ^(strip(_NCL_) eq 2 and strip(_TYPE_) eq 'CCORR') then delete;
MPRINT(MAKEINTERCLUSCORRDATA):   _NAME_ = upcase(_NAME_);
MPRINT(MAKEINTERCLUSCORRDATA):   rename _NAME_ = Cluster;
MPRINT(MAKEINTERCLUSCORRDATA):   label _NAME_ = "Nombre de clúster";
MPRINT(MAKEINTERCLUSCORRDATA):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      7:15   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      7:9   
NOTE: There were 26 observations read from the data set EMWS1.VARCLUS_OUTSTAT.
NOTE: The data set EMWS1.VARCLUS_OUTCLUSCORR has 2 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEINTERCLUSCORRDATA):   data corr_tmp;
MPRINT(MAKEINTERCLUSCORRDATA):   set EMWS1.VarClus_OUTCLUSCORR;
MPRINT(MAKEINTERCLUSCORRDATA):   run;

NOTE: There were 2 observations read from the data set EMWS1.VARCLUS_OUTCLUSCORR.
NOTE: The data set WORK.CORR_TMP has 2 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEINTERCLUSCORRDATA):   data EMWS1.VarClus_OUTCLUSCORR;
MPRINT(MAKEINTERCLUSCORRDATA):   set EMWS1.VarClus_OUTCLUSCORR;
MPRINT(MAKEINTERCLUSCORRDATA):   rename CLAGE = CLUS1;
MPRINT(MAKEINTERCLUSCORRDATA):   *label &_name ="Cluster &i_1";
MPRINT(MAKEINTERCLUSCORRDATA):   label CLAGE = "Clúster 1";
MPRINT(MAKEINTERCLUSCORRDATA):   rename DEBTINC = CLUS2;
MPRINT(MAKEINTERCLUSCORRDATA):   *label &_name ="Cluster &i_1";
MPRINT(MAKEINTERCLUSCORRDATA):   label DEBTINC = "Clúster 2";
MPRINT(MAKEINTERCLUSCORRDATA):   keep Cluster CLAGE DEBTINC ;
MPRINT(MAKEINTERCLUSCORRDATA):   run;

NOTE: There were 2 observations read from the data set EMWS1.VARCLUS_OUTCLUSCORR.
NOTE: The data set EMWS1.VARCLUS_OUTCLUSCORR has 2 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEINTERCLUSCORRDATA):   quit;
MPRINT(MAKEINTERCLUSCORRDATA):   data corr_tmp;
MPRINT(MAKEINTERCLUSCORRDATA):   set EMWS1.VarClus_OUTCLUSCORR;
MPRINT(MAKEINTERCLUSCORRDATA):   run;

NOTE: There were 2 observations read from the data set EMWS1.VARCLUS_OUTCLUSCORR.
NOTE: The data set WORK.CORR_TMP has 2 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEINTERCLUSCORRDATA):   data EMWS1.VarClus_OUTCLUSCORR;
MPRINT(MAKEINTERCLUSCORRDATA):   set EMWS1.VarClus_OUTCLUSCORR;
MPRINT(MAKEINTERCLUSCORRDATA):   CLUS1 = CLUS1**2;
MPRINT(MAKEINTERCLUSCORRDATA):   CLUS2 = CLUS2**2;
MPRINT(MAKEINTERCLUSCORRDATA):   run;

NOTE: There were 2 observations read from the data set EMWS1.VARCLUS_OUTCLUSCORR.
NOTE: The data set EMWS1.VARCLUS_OUTCLUSCORR has 2 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEINTERCLUSCORRDATA):   proc datasets lib = work nolist;
MPRINT(MAKEINTERCLUSCORRDATA):   delete corr_tmp;
MPRINT(MAKEINTERCLUSCORRDATA):   run;

NOTE: Deleting WORK.CORR_TMP (memtype=DATA).
MPRINT(MAKEINTERCLUSCORRDATA):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN1):  ;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   proc sort data =EMWS1.VarClus_OUTCLUSCORR out=_tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   by cluster;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   run;

NOTE: There were 2 observations read from the data set EMWS1.VARCLUS_OUTCLUSCORR.
NOTE: The data set WORK._TMPCLUSRSQ has 2 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   proc transpose data =_tmpclusRsq out=_tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   by cluster;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   run;

NOTE: There were 2 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 4 observations and 4 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   proc sort data=_tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   by _NAME_ col1;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   run;

NOTE: There were 4 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 4 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   data _tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   length _NAME_ $32;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   set _tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   by _NAME_;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   _NAME_ = upcase(_NAME_);
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   if last._NAME_ then delete;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   run;

NOTE: There were 4 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 2 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   data _nextClusRSq;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   set _tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   by _NAME_;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   Cluster = upcase(Cluster);
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   if last._NAME_ then output;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   *label COL1 = 'R-Sqaure with Next Cluster Component';
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   label COL1 = "R-cuadrado con siguiente componente clúster" ;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   rename COL1 = RSqWithNextClusComp;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   Cluster = upcase(Cluster);
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   rename Cluster = ClosestCluster;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   *label Cluster = "Next Closest Cluster";
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   label Cluster = "Siguiente clúster más cercano" ;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   rename _NAME_ = Variable;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   *label _NAME_ = "Variable";
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   label _NAME_ = "Variable" ;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   run;

NOTE: There were 2 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._NEXTCLUSRSQ has 2 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   proc datasets lib = work nolist;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   delete _tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   run;

NOTE: Deleting WORK._TMPCLUSRSQ (memtype=DATA).
MPRINT(FINDNEXTCLOSESTCLUSBYCLUSTER):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN1):  ;
MPRINT(MAKEOWNRSQUARE):   data _tmpds(drop= _NCL_);
MPRINT(MAKEOWNRSQUARE):   set EMWS1.VarClus_OUTSTAT;
MPRINT(MAKEOWNRSQUARE):   if ^(strip(_NCL_) eq 2 and strip(_TYPE_) in ('GROUP','RSQUARED')) then delete;
MPRINT(MAKEOWNRSQUARE):   _NAME_ = "CLUS";
MPRINT(MAKEOWNRSQUARE):   rename _NAME_ = Cluster;
MPRINT(MAKEOWNRSQUARE):   label _NAME_ = "Nombre de clúster";
MPRINT(MAKEOWNRSQUARE):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      2:77   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      2:71   
NOTE: There were 26 observations read from the data set EMWS1.VARCLUS_OUTSTAT.
NOTE: The data set WORK._TMPDS has 2 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEOWNRSQUARE):   proc transpose data =_tmpds out =_ownRsq;
MPRINT(MAKEOWNRSQUARE):   run;

NOTE: There were 2 observations read from the data set WORK._TMPDS.
NOTE: The data set WORK._OWNRSQ has 4 observations and 3 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEOWNRSQUARE):   data _ownRsq(drop=COL1);
MPRINT(MAKEOWNRSQUARE):   length Cluster $32;
MPRINT(MAKEOWNRSQUARE):   length _NAME_ $32;
MPRINT(MAKEOWNRSQUARE):   set _ownRsq;
MPRINT(MAKEOWNRSQUARE):   _NAME_ = upcase(_NAME_);
MPRINT(MAKEOWNRSQUARE):   rename _NAME_=Variable;
MPRINT(MAKEOWNRSQUARE):   *label _NAME_="Variable";
MPRINT(MAKEOWNRSQUARE):   label _NAME_ = "Variable" ;
MPRINT(MAKEOWNRSQUARE):   label Cluster = "Clúster" ;
MPRINT(MAKEOWNRSQUARE):   label GCluster = "Clúster global" ;
MPRINT(MAKEOWNRSQUARE):   Cluster = "CLUS"||strip(COL1);
MPRINT(MAKEOWNRSQUARE):   rename COL2 = RSqWithOwnClusComp;
MPRINT(MAKEOWNRSQUARE):   *label COL2 = "R-Square With Own Cluster Component";
MPRINT(MAKEOWNRSQUARE):   label COL2 = "R-cuadrado con componente clúster propio" ;
MPRINT(MAKEOWNRSQUARE):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      12:35   
NOTE: Variable GCluster is uninitialized.
NOTE: There were 4 observations read from the data set WORK._OWNRSQ.
NOTE: The data set WORK._OWNRSQ has 4 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEOWNRSQUARE):   proc sort data =_ownRsq;
MPRINT(MAKEOWNRSQUARE):   by Cluster RSqWithOwnClusComp;
MPRINT(MAKEOWNRSQUARE):   run;

NOTE: There were 4 observations read from the data set WORK._OWNRSQ.
NOTE: The data set WORK._OWNRSQ has 4 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEOWNRSQUARE):   proc datasets lib = work nolist;
MPRINT(MAKEOWNRSQUARE):   delete _tmpds;
MPRINT(MAKEOWNRSQUARE):   run;

NOTE: Deleting WORK._TMPDS (memtype=DATA).
MPRINT(MAKEOWNRSQUARE):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN1):  ;
MPRINT(MAKECLUSSTRUCTCORRDATA):   data EMWS1.VarClus_OUTCLUSSTRUCT(drop= _NCL_ _TYPE_);
MPRINT(MAKECLUSSTRUCTCORRDATA):   set EMWS1.VarClus_OUTSTAT;
MPRINT(MAKECLUSSTRUCTCORRDATA):   if ^(strip(_NCL_) eq 2 and strip(_TYPE_) eq 'STRUCTUR') then delete;
MPRINT(MAKECLUSSTRUCTCORRDATA):   _NAME_ = upcase(_NAME_);
MPRINT(MAKECLUSSTRUCTCORRDATA):   rename _NAME_ = Cluster;
MPRINT(MAKECLUSSTRUCTCORRDATA):   label _NAME_ = "Clúster" ;
MPRINT(MAKECLUSSTRUCTCORRDATA):   label GCluster = "Clúster global" ;
MPRINT(MAKECLUSSTRUCTCORRDATA):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      4:40   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      4:34   
NOTE: Variable GCluster is uninitialized.
NOTE: There were 26 observations read from the data set EMWS1.VARCLUS_OUTSTAT.
NOTE: The data set EMWS1.VARCLUS_OUTCLUSSTRUCT has 2 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(MAKECLUSSTRUCTCORRDATA):   data corr_tmp;
MPRINT(MAKECLUSSTRUCTCORRDATA):   set EMWS1.VarClus_OUTCLUSSTRUCT;
MPRINT(MAKECLUSSTRUCTCORRDATA):   run;

NOTE: There were 2 observations read from the data set EMWS1.VARCLUS_OUTCLUSSTRUCT.
NOTE: The data set WORK.CORR_TMP has 2 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKECLUSSTRUCTCORRDATA):   data EMWS1.VarClus_OUTCLUSSTRUCT;
MPRINT(MAKECLUSSTRUCTCORRDATA):   set EMWS1.VarClus_OUTCLUSSTRUCT;
MPRINT(MAKECLUSSTRUCTCORRDATA):   CLAGE = CLAGE**2;
MPRINT(MAKECLUSSTRUCTCORRDATA):   DEBTINC = DEBTINC**2;
MPRINT(MAKECLUSSTRUCTCORRDATA):   MORTDUE = MORTDUE**2;
MPRINT(MAKECLUSSTRUCTCORRDATA):   VALUE = VALUE**2;
MPRINT(MAKECLUSSTRUCTCORRDATA):   run;

NOTE: There were 2 observations read from the data set EMWS1.VARCLUS_OUTCLUSSTRUCT.
NOTE: The data set EMWS1.VARCLUS_OUTCLUSSTRUCT has 2 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKECLUSSTRUCTCORRDATA):   proc datasets lib = work nolist;
MPRINT(MAKECLUSSTRUCTCORRDATA):   delete corr_tmp;
MPRINT(MAKECLUSSTRUCTCORRDATA):   run;

NOTE: Deleting WORK.CORR_TMP (memtype=DATA).
MPRINT(MAKECLUSSTRUCTCORRDATA):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN1):  ;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   proc sort data =EMWS1.VarClus_OUTCLUSSTRUCT out=_tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   by cluster;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   run;

NOTE: There were 2 observations read from the data set EMWS1.VARCLUS_OUTCLUSSTRUCT.
NOTE: The data set WORK._TMPCLUSRSQ has 2 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   proc transpose data =_tmpclusRsq out=_tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   by cluster;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   run;

NOTE: There were 2 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 8 observations and 3 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   proc sort data=_tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   by _NAME_ COL1;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   run;

NOTE: There were 8 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 8 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   data _tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   length _NAME_ $32;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   set _tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   by _NAME_;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   _NAME_ = upcase(_NAME_);
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   if last._NAME_ then delete;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   run;

NOTE: There were 8 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 4 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   proc sort data=_tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   by _NAME_ COL1;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   run;

NOTE: There were 4 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 4 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   data _nextVarRSq;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   set _tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   by _NAME_;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   Cluster = upcase(Cluster);
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   if last._NAME_ then output;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   *label COL1 = 'R-Sqaure with Next Cluster Component';
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   label COL1 = "R-cuadrado con siguiente componente clúster" ;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   rename COL1 = RSqWithNextClusComp;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   Cluster = upcase(Cluster);
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   rename Cluster = ClosestCluster;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   *label Cluster = "Next Closest Cluster";
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   label Cluster = "Siguiente clúster más cercano" ;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   rename _NAME_ = Variable;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   label _NAME_ = "Variable" ;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   run;

NOTE: There were 4 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._NEXTVARRSQ has 4 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   proc datasets lib = work nolist;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   delete _tmpclusRsq;
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   run;

NOTE: Deleting WORK._TMPCLUSRSQ (memtype=DATA).
MPRINT(FINDNEXTCLOSESTCLUSBYVAR):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN1):  ;
MPRINT(MAKEVARCLUSRESULTTABLE):   proc sort data =_ownRsq;
MPRINT(MAKEVARCLUSRESULTTABLE):   by Variable;
MPRINT(MAKEVARCLUSRESULTTABLE):   run;

NOTE: There were 4 observations read from the data set WORK._OWNRSQ.
NOTE: The data set WORK._OWNRSQ has 4 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(MAKEVARCLUSRESULTTABLE):   proc sort data =_nextVarRsq;
MPRINT(MAKEVARCLUSRESULTTABLE):   by Variable;
MPRINT(MAKEVARCLUSRESULTTABLE):   run;

NOTE: There were 4 observations read from the data set WORK._NEXTVARRSQ.
NOTE: The data set WORK._NEXTVARRSQ has 4 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSRESULTTABLE):   data EMWS1.VarClus_OUTRSQUARE;
MPRINT(MAKEVARCLUSRESULTTABLE):   merge _ownRsq _nextVarRsq;
MPRINT(MAKEVARCLUSRESULTTABLE):   by Variable;
MPRINT(MAKEVARCLUSRESULTTABLE):   length Type $16;
MPRINT(MAKEVARCLUSRESULTTABLE):   Type = 'Variable';
MPRINT(MAKEVARCLUSRESULTTABLE):   *label Type ='Type';
MPRINT(MAKEVARCLUSRESULTTABLE):   label Type = "Tipo" ;
MPRINT(MAKEVARCLUSRESULTTABLE):   run;

NOTE: There were 4 observations read from the data set WORK._OWNRSQ.
NOTE: There were 4 observations read from the data set WORK._NEXTVARRSQ.
NOTE: The data set EMWS1.VARCLUS_OUTRSQUARE has 4 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSRESULTTABLE):   data _nextClusRSq;
MPRINT(MAKEVARCLUSRESULTTABLE):   set _nextClusRSq ;
MPRINT(MAKEVARCLUSRESULTTABLE):   length RSqWithOwnClusComp 8.;
MPRINT(MAKEVARCLUSRESULTTABLE):   Cluster = Variable;
MPRINT(MAKEVARCLUSRESULTTABLE):   RSqWithOwnClusComp = 1;
MPRINT(MAKEVARCLUSRESULTTABLE):   *label RSqWithOwnClusComp = "R-Square With Own Cluster Component";
MPRINT(MAKEVARCLUSRESULTTABLE):   label RSqWithOwnClusComp = "R-cuadrado con componente clúster propio" ;
MPRINT(MAKEVARCLUSRESULTTABLE):   length Type $16;
MPRINT(MAKEVARCLUSRESULTTABLE):   Type = 'ClusterComp';
MPRINT(MAKEVARCLUSRESULTTABLE):   label Type = "Tipo" ;
MPRINT(MAKEVARCLUSRESULTTABLE):   ;
MPRINT(MAKEVARCLUSRESULTTABLE):   run;

NOTE: There were 2 observations read from the data set WORK._NEXTCLUSRSQ.
NOTE: The data set WORK._NEXTCLUSRSQ has 2 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(MAKEVARCLUSRESULTTABLE):   proc sort data=EMWS1.VarClus_OUTRSQUARE;
MPRINT(MAKEVARCLUSRESULTTABLE):   by Cluster;
MPRINT(MAKEVARCLUSRESULTTABLE):   run;

NOTE: There were 4 observations read from the data set EMWS1.VARCLUS_OUTRSQUARE.
NOTE: The data set EMWS1.VARCLUS_OUTRSQUARE has 4 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSRESULTTABLE):   proc sort data =_nextClusRSq;
MPRINT(MAKEVARCLUSRESULTTABLE):   by Cluster;
MPRINT(MAKEVARCLUSRESULTTABLE):   run;

NOTE: There were 2 observations read from the data set WORK._NEXTCLUSRSQ.
NOTE: The data set WORK._NEXTCLUSRSQ has 2 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSRESULTTABLE):   data EMWS1.VarClus_OUTRSQUARE;
MPRINT(MAKEVARCLUSRESULTTABLE):   set EMWS1.VarClus_OUTRSQUARE _nextClusRSq;
MPRINT(MAKEVARCLUSRESULTTABLE):   by Cluster;
MPRINT(MAKEVARCLUSRESULTTABLE):   run;

NOTE: There were 4 observations read from the data set EMWS1.VARCLUS_OUTRSQUARE.
NOTE: There were 2 observations read from the data set WORK._NEXTCLUSRSQ.
NOTE: The data set EMWS1.VARCLUS_OUTRSQUARE has 6 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSRESULTTABLE):   data EMWS1.VarClus_OUTRSQUARE;
MPRINT(MAKEVARCLUSRESULTTABLE):   set EMWS1.VarClus_OUTRSQUARE;
MPRINT(MAKEVARCLUSRESULTTABLE):   length RsqRatio 8.;
MPRINT(MAKEVARCLUSRESULTTABLE):   length Selected $8;
MPRINT(MAKEVARCLUSRESULTTABLE):   *label RSqRatio = "1-R**2 Ratio";
MPRINT(MAKEVARCLUSRESULTTABLE):   label RSqRatio = "1-R2 Ratio" ;
MPRINT(MAKEVARCLUSRESULTTABLE):   *label Selected = "Variable Selected";
MPRINT(MAKEVARCLUSRESULTTABLE):   label Selected = "Variable seleccionada" ;
MPRINT(MAKEVARCLUSRESULTTABLE):   RsqRatio = (1-RSqWithOwnClusComp)/(1-RSqWithNextClusComp);
MPRINT(MAKEVARCLUSRESULTTABLE):   Selected ='YES';
MPRINT(MAKEVARCLUSRESULTTABLE):   rename _LABEL_ = Label;
MPRINT(MAKEVARCLUSRESULTTABLE):   label _LABEL_ = "Etiqueta" ;
MPRINT(MAKEVARCLUSRESULTTABLE):   run;

NOTE: There were 6 observations read from the data set EMWS1.VARCLUS_OUTRSQUARE.
NOTE: The data set EMWS1.VARCLUS_OUTRSQUARE has 6 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSRESULTTABLE):   quit;
MPRINT(TRAIN1):  ;
MPRINT(MAKEINTERCLUSCORRDATA):   data EMWS1.VarClus_OUTCLUSCORRPLOT(drop= _NCL_ _TYPE_);
MPRINT(MAKEINTERCLUSCORRDATA):   set EMWS1.VarClus_OUTSTAT;
MPRINT(MAKEINTERCLUSCORRDATA):   if ^(strip(_NCL_) eq 2 and strip(_TYPE_) eq 'CCORR') then delete;
MPRINT(MAKEINTERCLUSCORRDATA):   _NAME_ = upcase(_NAME_);
MPRINT(MAKEINTERCLUSCORRDATA):   rename _NAME_ = Cluster;
MPRINT(MAKEINTERCLUSCORRDATA):   label _NAME_ = "Nombre de clúster";
MPRINT(MAKEINTERCLUSCORRDATA):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      71199:90   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      71199:84   
NOTE: There were 26 observations read from the data set EMWS1.VARCLUS_OUTSTAT.
NOTE: The data set EMWS1.VARCLUS_OUTCLUSCORRPLOT has 2 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEINTERCLUSCORRDATA):   data corr_tmp;
MPRINT(MAKEINTERCLUSCORRDATA):   set EMWS1.VarClus_OUTCLUSCORRPLOT;
MPRINT(MAKEINTERCLUSCORRDATA):   run;

NOTE: There were 2 observations read from the data set EMWS1.VARCLUS_OUTCLUSCORRPLOT.
NOTE: The data set WORK.CORR_TMP has 2 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.03 seconds
      

MPRINT(MAKEINTERCLUSCORRDATA):   data EMWS1.VarClus_OUTCLUSCORRPLOT;
MPRINT(MAKEINTERCLUSCORRDATA):   set EMWS1.VarClus_OUTCLUSCORRPLOT;
MPRINT(MAKEINTERCLUSCORRDATA):   rename CLAGE = CLUS1;
MPRINT(MAKEINTERCLUSCORRDATA):   *label &_name ="Cluster &i_1";
MPRINT(MAKEINTERCLUSCORRDATA):   label CLAGE = "Clúster 1";
MPRINT(MAKEINTERCLUSCORRDATA):   rename DEBTINC = CLUS2;
MPRINT(MAKEINTERCLUSCORRDATA):   *label &_name ="Cluster &i_1";
MPRINT(MAKEINTERCLUSCORRDATA):   label DEBTINC = "Clúster 2";
MPRINT(MAKEINTERCLUSCORRDATA):   keep Cluster CLAGE DEBTINC ;
MPRINT(MAKEINTERCLUSCORRDATA):   run;

NOTE: There were 2 observations read from the data set EMWS1.VARCLUS_OUTCLUSCORRPLOT.
NOTE: The data set EMWS1.VARCLUS_OUTCLUSCORRPLOT has 2 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEINTERCLUSCORRDATA):   quit;
MPRINT(MAKEINTERCLUSCORRDATA):   proc datasets lib = work nolist;
MPRINT(MAKEINTERCLUSCORRDATA):   delete corr_tmp;
MPRINT(MAKEINTERCLUSCORRDATA):   run;

NOTE: Deleting WORK.CORR_TMP (memtype=DATA).
MPRINT(MAKEINTERCLUSCORRDATA):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN1):  ;
MPRINT(MAKEPLOTDATAFROMCORRTABLE):   proc sort data =EMWS1.VarClus_OUTCLUSCORRPLOT;
MPRINT(MAKEPLOTDATAFROMCORRTABLE):   by cluster;
MPRINT(MAKEPLOTDATAFROMCORRTABLE):   run;

NOTE: There were 2 observations read from the data set EMWS1.VARCLUS_OUTCLUSCORRPLOT.
NOTE: The data set EMWS1.VARCLUS_OUTCLUSCORRPLOT has 2 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEPLOTDATAFROMCORRTABLE):   proc transpose data =EMWS1.VarClus_OUTCLUSCORRPLOT out=EMWS1.VarClus_OUTCLUSCORRPLOT(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
MPRINT(MAKEPLOTDATAFROMCORRTABLE):   by cluster;
MPRINT(MAKEPLOTDATAFROMCORRTABLE):   run;

NOTE: There were 2 observations read from the data set EMWS1.VARCLUS_OUTCLUSCORRPLOT.
NOTE: The data set EMWS1.VARCLUS_OUTCLUSCORRPLOT has 4 observations and 3 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEPLOTDATAFROMCORRTABLE):   data EMWS1.VarClus_OUTCLUSCORRPLOT;
MPRINT(MAKEPLOTDATAFROMCORRTABLE):   set EMWS1.VarClus_OUTCLUSCORRPLOT;
MPRINT(MAKEPLOTDATAFROMCORRTABLE):   label x= "Clúster" ;
MPRINT(MAKEPLOTDATAFROMCORRTABLE):   label Y= "Clúster" ;
MPRINT(MAKEPLOTDATAFROMCORRTABLE):   label Correlation = "Correlación" ;
MPRINT(MAKEPLOTDATAFROMCORRTABLE):   run;

NOTE: There were 4 observations read from the data set EMWS1.VARCLUS_OUTCLUSCORRPLOT.
NOTE: The data set EMWS1.VARCLUS_OUTCLUSCORRPLOT has 4 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN1):  ;
MPRINT(MAKESTATPLOTDATA):   data varclus_tmp(drop=_NAME_ _NCL_) ;
MPRINT(MAKESTATPLOTDATA):   set EMWS1.VarClus_OUTSTAT;
MPRINT(MAKESTATPLOTDATA):   where _type_ in('MEAN', 'STD', 'N');
MPRINT(MAKESTATPLOTDATA):   run ;

NOTE: There were 3 observations read from the data set EMWS1.VARCLUS_OUTSTAT.
      WHERE _type_ in ('MEAN', 'N', 'STD');
NOTE: The data set WORK.VARCLUS_TMP has 3 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKESTATPLOTDATA):   proc transpose data=varclus_tmp out=EMWS1.VarClus_OUTSTATPLOT;
MPRINT(MAKESTATPLOTDATA):   id _TYPE_ ;
MPRINT(MAKESTATPLOTDATA):   run ;

NOTE: There were 3 observations read from the data set WORK.VARCLUS_TMP.
NOTE: The data set EMWS1.VARCLUS_OUTSTATPLOT has 4 observations and 4 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKESTATPLOTDATA):   data EMWS1.VarClus_OUTSTATPLOT;
MPRINT(MAKESTATPLOTDATA):   set EMWS1.VarClus_OUTSTATPLOT(obs=1000);
MPRINT(MAKESTATPLOTDATA):   label _name_= "Nombre";
MPRINT(MAKESTATPLOTDATA):   label _label_= "Etiqueta" ;
MPRINT(MAKESTATPLOTDATA):   if MEAN ne 0 then SCALEDSTD= STD / MEAN ;
MPRINT(MAKESTATPLOTDATA):   else SCALEDSTD= STD ;
MPRINT(MAKESTATPLOTDATA):   label SCALEDSTD = "STD escalado";
MPRINT(MAKESTATPLOTDATA):   run ;

NOTE: Variable _label_ is uninitialized.
NOTE: There were 4 observations read from the data set EMWS1.VARCLUS_OUTSTATPLOT.
NOTE: The data set EMWS1.VARCLUS_OUTSTATPLOT has 4 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKESTATPLOTDATA):   proc sort data=EMWS1.VarClus_OUTSTATPLOT;
MPRINT(MAKESTATPLOTDATA):   by descending SCALEDSTD ;
MPRINT(MAKESTATPLOTDATA):   run ;

NOTE: There were 4 observations read from the data set EMWS1.VARCLUS_OUTSTATPLOT.
NOTE: The data set EMWS1.VARCLUS_OUTSTATPLOT has 4 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKESTATPLOTDATA):   proc datasets lib=work nolist mt=(DATA VIEW);
MPRINT(MAKESTATPLOTDATA):   delete varclus_tmp;
MPRINT(MAKESTATPLOTDATA):   run;

NOTE: Deleting WORK.VARCLUS_TMP (memtype=DATA).
MPRINT(MAKESTATPLOTDATA):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN1):  ;
MPRINT(MAKEVARCLUSCORRDATA):   data EMWS1.VarClus_OUTCORR(drop=_TYPE_ _NCL_) ;
MPRINT(MAKEVARCLUSCORRDATA):   set EMWS1.VarClus_OUTSTAT;
MPRINT(MAKEVARCLUSCORRDATA):   where _type_ eq 'CORR' ;
MPRINT(MAKEVARCLUSCORRDATA):   run ;

NOTE: There were 4 observations read from the data set EMWS1.VARCLUS_OUTSTAT.
      WHERE _type_='CORR';
NOTE: The data set EMWS1.VARCLUS_OUTCORR has 4 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSCORRDATA):   proc sort data=EMWS1.VarClus_OUTCORR;
MPRINT(MAKEVARCLUSCORRDATA):   by _NAME_ ;
MPRINT(MAKEVARCLUSCORRDATA):   run ;

NOTE: There were 4 observations read from the data set EMWS1.VARCLUS_OUTCORR.
NOTE: The data set EMWS1.VARCLUS_OUTCORR has 4 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSCORRDATA):   proc transpose data=EMWS1.VarClus_OUTCORR out=EMWS1.VarClus_OUTCORRPLOT name=_TMP_;
MPRINT(MAKEVARCLUSCORRDATA):   BY _NAME_ ;
MPRINT(MAKEVARCLUSCORRDATA):   run ;

NOTE: There were 4 observations read from the data set EMWS1.VARCLUS_OUTCORR.
NOTE: The data set EMWS1.VARCLUS_OUTCORRPLOT has 16 observations and 3 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSCORRDATA):   data EMWS1.VarClus_OUTCORRPLOT;
MPRINT(MAKEVARCLUSCORRDATA):   length _Y_ $100;
MPRINT(MAKEVARCLUSCORRDATA):   set EMWS1.VarClus_OUTCORRPLOT;
MPRINT(MAKEVARCLUSCORRDATA):   if _LABEL_ ne '' then _Y_=_LABEL_ ;
MPRINT(MAKEVARCLUSCORRDATA):   else _Y_=_TMP_ ;
MPRINT(MAKEVARCLUSCORRDATA):   run ;

NOTE: Variable _LABEL_ is uninitialized.
NOTE: There were 16 observations read from the data set EMWS1.VARCLUS_OUTCORRPLOT.
NOTE: The data set EMWS1.VARCLUS_OUTCORRPLOT has 16 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSCORRDATA):   data varclus_match(rename=(_TMP_= _NAME_ _LABEL_=_X_));
MPRINT(MAKEVARCLUSCORRDATA):   set EMWS1.VarClus_OUTCORRPLOT;
MPRINT(MAKEVARCLUSCORRDATA):   where _LABEL_ ne '' ;
MPRINT(MAKEVARCLUSCORRDATA):   keep _TMP_ _LABEL_ ;
MPRINT(MAKEVARCLUSCORRDATA):   run ;

NOTE: There were 0 observations read from the data set EMWS1.VARCLUS_OUTCORRPLOT.
      WHERE _LABEL_ not = ' ';
NOTE: The data set WORK.VARCLUS_MATCH has 0 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSCORRDATA):   data _null_;
MPRINT(MAKEVARCLUSCORRDATA):   nobs=0;
MPRINT(MAKEVARCLUSCORRDATA):   dsid = open('varclus_match');
MPRINT(MAKEVARCLUSCORRDATA):   if dsid then do;
MPRINT(MAKEVARCLUSCORRDATA):   nobs = attrn(dsid, 'NOBS');
MPRINT(MAKEVARCLUSCORRDATA):   dsid = close(dsid);
MPRINT(MAKEVARCLUSCORRDATA):   end;
MPRINT(MAKEVARCLUSCORRDATA):   call symput ('CORR_NOBS', nobs);
MPRINT(MAKEVARCLUSCORRDATA):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      7:246   
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(MAKEVARCLUSCORRDATA):   proc sort data=EMWS1.VarClus_OUTCORRPLOT;
MPRINT(MAKEVARCLUSCORRDATA):   by _name_;
MPRINT(MAKEVARCLUSCORRDATA):   run ;

NOTE: There were 16 observations read from the data set EMWS1.VARCLUS_OUTCORRPLOT.
NOTE: The data set EMWS1.VARCLUS_OUTCORRPLOT has 16 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSCORRDATA):   data EMWS1.VarClus_OUTCORRPLOT(keep= _NAME_ _Y_ col1 rename=(_NAME_=_X_ col1=Correlation)) ;
MPRINT(MAKEVARCLUSCORRDATA):   set EMWS1.VarClus_OUTCORRPLOT;
MPRINT(MAKEVARCLUSCORRDATA):   label _NAME_ = "Variable" ;
MPRINT(MAKEVARCLUSCORRDATA):   label _Y_ = "Variable" ;
MPRINT(MAKEVARCLUSCORRDATA):   label col1 = "Correlación";
MPRINT(MAKEVARCLUSCORRDATA):   run ;

NOTE: There were 16 observations read from the data set EMWS1.VARCLUS_OUTCORRPLOT.
NOTE: The data set EMWS1.VARCLUS_OUTCORRPLOT has 16 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(MAKEVARCLUSCORRDATA):   proc sort data=EMWS1.VarClus_OUTCORRPLOT;
MPRINT(MAKEVARCLUSCORRDATA):   by _X_ _Y_;
MPRINT(MAKEVARCLUSCORRDATA):   run ;

NOTE: There were 16 observations read from the data set EMWS1.VARCLUS_OUTCORRPLOT.
NOTE: The data set EMWS1.VARCLUS_OUTCORRPLOT has 16 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKEVARCLUSCORRDATA):   proc datasets lib=work nolist mt=(DATA VIEW);
MPRINT(MAKEVARCLUSCORRDATA):   delete varclus_match;
MPRINT(MAKEVARCLUSCORRDATA):   run;

NOTE: Deleting WORK.VARCLUS_MATCH (memtype=DATA).
MPRINT(MAKEVARCLUSCORRDATA):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN1):  ;
MPRINT(MAKECLUSCONSTELLDATA):   data EMWS1.VarClus_OUTLINK(drop = Selected);
MPRINT(MAKECLUSCONSTELLDATA):   set EMWS1.VarClus_OUTRSQUARE;
MPRINT(MAKECLUSCONSTELLDATA):   LINKID = _N_;
MPRINT(MAKECLUSCONSTELLDATA):   label LINKID = "ID del enlace";
MPRINT(MAKECLUSCONSTELLDATA):   if strip(upcase(Cluster)) eq strip(upcase(Variable)) then Variable = ClosestCluster;
MPRINT(MAKECLUSCONSTELLDATA):   run;

NOTE: There were 6 observations read from the data set EMWS1.VARCLUS_OUTRSQUARE.
NOTE: The data set EMWS1.VARCLUS_OUTLINK has 6 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKECLUSCONSTELLDATA):   data EMWS1.VarClus_OUTNODE(keep=NODEID TYPE LABEL);
MPRINT(MAKECLUSCONSTELLDATA):   set EMWS1.VarClus_OUTRSQUARE;
MPRINT(MAKECLUSCONSTELLDATA):   length TYPE $16;
MPRINT(MAKECLUSCONSTELLDATA):   rename Variable = NODEID;
MPRINT(MAKECLUSCONSTELLDATA):   label Variable= "ID de nodo";
MPRINT(MAKECLUSCONSTELLDATA):   if strip(upcase(Cluster)) eq strip(upcase(Variable)) then TYPE = "CLUSTER";
MPRINT(MAKECLUSCONSTELLDATA):   else TYPE="VARIABLE";
MPRINT(MAKECLUSCONSTELLDATA):   label TYPE = "Tipo de nodo";
MPRINT(MAKECLUSCONSTELLDATA):   run;

NOTE: There were 6 observations read from the data set EMWS1.VARCLUS_OUTRSQUARE.
NOTE: The data set EMWS1.VARCLUS_OUTNODE has 6 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(MAKECLUSCONSTELLDATA):   quit;
MPRINT(TRAIN1):  ;
MPRINT(CREATESCORECODE):  ;
MPRINT(CREATESCORECODE):   data EMWS1.VarClus_OUTSTATSCORE;
MPRINT(CREATESCORECODE):   set EMWS1.VarClus_OUTSTAT;
MPRINT(CREATESCORECODE):   if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = 2 ) or (_TYPE_ in ('MEAN' 'STD'));
MPRINT(CREATESCORECODE):   if _TYPE_ = 'MEAN' then _NAME_='MEAN';
MPRINT(CREATESCORECODE):   if _TYPE_ = 'STD' then _NAME_='STD';
MPRINT(CREATESCORECODE):   DROP _TYPE_ _NCL_;
MPRINT(CREATESCORECODE):   run;

NOTE: There were 26 observations read from the data set EMWS1.VARCLUS_OUTSTAT.
NOTE: The data set EMWS1.VARCLUS_OUTSTATSCORE has 4 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(CREATESCORECODE):   filename _file_ "C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMFLOWSCORE.sas";
MPRINT(CREATESCORECODE):   data _null_;
MPRINT(CREATESCORECODE):   FILE _file_ MOD;
MPRINT(CREATESCORECODE):   put ' ';
MPRINT(CREATESCORECODE):   put '/*-------------------------------------------------*/';
MPRINT(CREATESCORECODE):   put '/* ' "Código de puntuación de Varclus" '*/';
MPRINT(CREATESCORECODE):   put '/*-------------------------------------------------*/';
MPRINT(CREATESCORECODE):   put ' ';
MPRINT(CREATESCORECODE):   put "Clus1 = 0 ; /*---" "Componente clúster 1" "------ */";
MPRINT(CREATESCORECODE):   put "Clus2 = 0 ; /*---" "Componente clúster 2" "------ */";
MPRINT(CREATESCORECODE):   put "Clus1 = Clus1+0.14843081095784 * (CLAGE - 185.203137466648)/84.0599022477296;";
MPRINT(CREATESCORECODE):   put "Clus2 = Clus2+1 * (DEBTINC - 34.3660953561507)/8.76078284183153;";
MPRINT(CREATESCORECODE):   put "Clus1 = Clus1+0.50256406910821 * (MORTDUE - 75057.8942583732)/43088.6722812176;";
MPRINT(CREATESCORECODE):   put "Clus1 = Clus1+0.50727788479825 * (VALUE - 107078.16937799)/52493.0066397462;";
MPRINT(CREATESCORECODE):   run;

NOTE: The file _FILE_ is:
      Filename=C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMFLOWSCORE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=07 de marzo de 2021 14H02,
      Create Time=07 de marzo de 2021 13H48

NOTE: 11 records were written to the file _FILE_.
      The minimum record length was 1.
      The maximum record length was 79.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN1):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename _in "C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMFLOWSCORE.sas";
MPRINT(TRAIN):   filename _out "C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMPUBLISHSCORE.sas";
MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   length line $20000;
MPRINT(TRAIN):   file _out lrecl=20000;
MPRINT(TRAIN):   fid=fopen("_in",'i',20000,'v');
MPRINT(TRAIN):   if fid > 0 then do;
MPRINT(TRAIN):   do while(^fread(fid));
MPRINT(TRAIN):   rlen = frlen(fid);
MPRINT(TRAIN):   rc= fget(fid,line,20000);
MPRINT(TRAIN):   start = length(line)-length(left(line))+1;
MPRINT(TRAIN):   line=strip(line);
MPRINT(TRAIN):   if line ne 'delete;' then do;
MPRINT(TRAIN):   put @start line;
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   if fid > 0 then rc=fclose(fid);
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   run;

NOTE: The file _OUT is:
      Filename=C:\Jose\DM_ang\Workspaces\EMWS1\VarClus\EMPUBLISHSCORE.sas,
      RECFM=V,LRECL=20000,File Size (bytes)=0,
      Last Modified=07 de marzo de 2021 14H02,
      Create Time=07 de marzo de 2021 13H48

NOTE: 11 records were written to the file _OUT.
      The minimum record length was 1.
      The maximum record length was 79.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   filename _in;
NOTE: Fileref _IN has been deassigned.
MPRINT(TRAIN):   filename _out;
NOTE: Fileref _OUT has been deassigned.
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: VarClus;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
27129      *------------------------------------------------------------*;
27130      * End TRAIN: VarClus;
27131      *------------------------------------------------------------*;
27132      

27133      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
27134      * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
27135      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
27136      ;
MPRINT(EM_DIAGRAM):   ;
27137      ;
MPRINT(EM_DIAGRAM):   ;
27138      ;
MPRINT(EM_DIAGRAM):   ;
27139      ;
MPRINT(EM_DIAGRAM):   ;
27140      quit;
MPRINT(EM_DIAGRAM):   quit;
27141      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
27142      * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
27143      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
27144      /*; *"; *'; */
27145      ;
MPRINT(EM_DIAGRAM):   ;
27146      run;
MPRINT(EM_DIAGRAM):   run;
27147      quit;
MPRINT(EM_DIAGRAM):   quit;
27148      /* Reset EM Options */
27149      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
27150      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
27151      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
