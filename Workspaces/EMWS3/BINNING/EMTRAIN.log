MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "14 de marzo de 2021" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "13H51" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Log de entrenamiento";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* Log de entrenamiento
Fecha:                14 de marzo de 2021
Hora:                13H51
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O1RH3WU1 "C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O1RH3WU1 new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "14 de marzo de 2021" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "13H51" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "Usuario:                Jose Caloca";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "Sitio:                70115216";
MPRINT(EM_DIAGRAM):   put "Plataforma:            X64_10PRO";
MPRINT(EM_DIAGRAM):   put "Versión de mantenimiento: 9.04.01M6P111518";
MPRINT(EM_DIAGRAM):   put "Versión de EM:          15.1";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "14 de marzo de 2021" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "13H51" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "Usuario:                Jose Caloca";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Salida de entrenamiento";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Salida de puntuación";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Salida del informe";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
35453      proc freq data=EMWS3.BINNING_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS3.BINNING_VariableSet noprint;
35454      table ROLE*LEVEL/out=WORK.BINNINGMETA;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.BINNINGMETA;
35455      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 14 observations read from the data set EMWS3.BINNING_VARIABLESET.
NOTE: The data set WORK.BINNINGMETA has 5 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.05 seconds
      cpu time            0.01 seconds
      

35456      proc print data=WORK.BINNINGMETA label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.BINNINGMETA label noobs;
35457      var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
35458      label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "Rol" LEVEL = "Nivel de medida" COUNT = "Número de ocurrencias";
35459      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
35460      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "Resumen de variables";
MPRINT(EM_DIAGRAM):   run;
35461      run;

NOTE: There were 5 observations read from the data set WORK.BINNINGMETA.
NOTE: The PROCEDURE PRINT printed page 7.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

35462      title10;
MPRINT(EM_DIAGRAM):   title10;
35463      %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * BINNING: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * BINNING: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'DM_ang';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'decision_tree';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   set EMWS3.Ids_EMINFO;
MPRINT(EM_DIAGRAM):   where key in('HPDMSAMPLE', 'IDSTABLE');
MPRINT(EM_DIAGRAM):   if key = 'HPDMSAMPLE' then call symput('_ForceGrid', '1');
MPRINT(EM_DIAGRAM):   else call symput('_IDS_TABLE', DATA);
MPRINT(EM_DIAGRAM):   run;
MPRINT(HPDM_PERFORMANCE):  ;
PERFORMANCE  DETAILS
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
35811      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
35812      * BINNING: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * BINNING: Generation of macros and macro variables;
35813      * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
35814      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;

35815      %let EMEXCEPTIONSTRING=;
35816      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
35817      * TRAIN: BINNING;
MPRINT(EM_DIAGRAM):   * TRAIN: BINNING;
35818      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
35819      %let EM_ACTION = TRAIN;
35820      %let syscc = 0;
35821      %macro main;
35822      
35823        filename temp catalog 'sashelp.emmdfy.binning_macros.source';
35824        %include temp;
35825        filename temp;
35826      
35827        %setProperties;
35828      
35829        %if %upcase(&EM_ACTION) = CREATE %then %do;
35830          filename temp catalog 'sashelp.emmdfy.binning_create.source';
35831          %include temp;
35832          filename temp;
35833      
35834          %create;
35835        %end;
35836      
35837         %else
35838         %if %upcase(&EM_ACTION) = TRAIN %then %do;
35839      
35840             filename temp catalog 'sashelp.emmdfy.binning_train.source';
35841             %include temp;
35842             filename temp;
35843             %train;
35844         %end;
35845      
35846        %else
35847        %if %upcase(&EM_ACTION) = SCORE %then %do;
35848          filename temp catalog 'sashelp.emmdfy.binning_score.source';
35849          %include temp;
35850          filename temp;
35851      
35852          %score;
35853      
35854        %end;
35855      
35856        %else
35857        %if %upcase(&EM_ACTION) = REPORT %then %do;
35858      
35859             filename temp catalog 'sashelp.emmdfy.binning_report.source';
35860             %include temp;
35861             filename temp;
35862      
35863             %report;
35864         %end;
35865      
35866         %doendm:
35867      %mend main;
35868      
35869      %main;
MPRINT(EM_DIAGRAM):    
MPRINT(MAIN):   filename temp catalog 'sashelp.emmdfy.binning_macros.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMDFY.BINNING_MACROS.SOURCE.
35871     +%macro SetProperties;
35873     +     /* IGN options */
35874     +     %em_checkmacro(name=EM_PROPERTY_APPLYLEVELRULE, value=N, global=Y);
35875     +     %em_checkmacro(name=EM_PROPERTY_BINMETHOD,  value=QUANTILE, global=Y);
35876     +     %em_checkmacro(name=EM_PROPERTY_NUMBINS,    value=4, global=Y);
35878     +     %em_checkmacro(name=EM_PROPERTY_MISSINGASLEVEL, value=Y, global=Y);
35879     +     %em_checkmacro(name=EM_PROPERTY_PRECISION,    value=2, global=Y);
35880     +     %em_checkmacro(name=EM_PROPERTY_CREATEGROUPING, value=N, global=Y);
35881     +     %em_checkmacro(name=EM_PROPERTY_CREATEMETHOD, value=OVERWRITE, global=Y);
35882     +     %em_checkmacro(name=EM_PROPERTY_IMPORTGROUPING, value=N, global=Y);
35883     +     %em_checkmacro(name=EM_PROPERTY_IMPORTDATA, value=, global=Y);
35884     +     %em_checkmacro(name=EM_PROPERTY_FREEZE, value=N, global=Y);
35885     +     %em_checkmacro(name=EM_PROPERTY_VARSELMETHOD, value=GINI, global=Y);
35886     +     %em_checkmacro(name=EM_PROPERTY_GINICUTOFF,   value=20.0, global=Y);
35887     +     %em_checkmacro(name=EM_PROPERTY_GRPMSMNT,     value=ORDINAL, global=Y);
35888     +     %em_checkmacro(name=EM_PROPERTY_MAXVAR,       value=10, global=Y);
35889     +     %em_checkmacro(name=EM_PROPERTY_CLASSGROUPRARE, value=Y, global=Y);
35890     +     %em_checkmacro(name=EM_PROPERTY_GROUPCUTOFF,    value=0.5, global=Y);
35891     +     %em_checkmacro(name=EM_PROPERTY_GROUPMISSING,   value=N, global=Y);
35893     +     %em_checkmacro(name=EM_PROPERTY_INTTARGETMETHOD, value=CUTMEAN, global=Y);
35894     +     %em_checkmacro(name=EM_PROPERTY_USERCUTVALUE, value=0.2, global=Y);
35895     +     %em_checkmacro(name=EM_PROPERTY_RejectIntTarget, value=N, global=Y);
35898     +%mend SetProperties;
35899     +%macro appendfiles(fileref1, fileref2);
35900     +     data _null_;
35901     +       length c $256;
35902     +       fid1=fopen("&fileref1",'A');
35903     +       fid2=fopen("&fileref2",'I');
35904     +       cval = finfo(fid2,'lrecl');
35905     +       put cval= fid1= fid2=;
35906     +       if (fid2 > 0) then
35907     +         do while(fread(fid2)=0);
35908     +           rc = fget(fid2,c,256);
35909     +           _msg_=sysmsg();
35910     +           /* put rc= c= _msg_=; */
35911     +           rc = fput(fid1,strip(c));
35912     +           rc = fwrite(fid1);
35913     +         end;
35914     +         _msg_=sysmsg();
35915     +         put _msg_=;
35916     +       rc = fclose(fid1);
35917     +       rc = fclose(fid2);
35918     +     run;
35919     +%mend appendfiles;
35921     +%macro buildOptScoreCode;
35923     +    %em_register(key=BINCODE, type=FOLDER);
35925     +    filename x catalog 'sashelp.emutil.em_deldir.source';
35926     +    %inc x;
35927     +    filename x;
35928     +    %delDir(folder=%nrbquote(&em_user_bincode));
35930     +    data _null_; length rc $200;
35931     +       rc = dcreate('BINCODE', "&EM_NODEDIR");
35932     +    run;
35934     +    %if ^%sysfunc(exist(class_nosv)) %then %goto doendu;
35936     +    %let dsid = %sysfunc(open(class_nosv));
35937     +    %let nameNum    = %sysfunc(varnum(&dsid, DISPLAY_VAR));
35938     +    %let grpnameNum = %sysfunc(varnum(&dsid, _grp_variable_));
35940     +    %let oldname=;
35941     +    %do %while(^%sysfunc(fetch(&dsid)));
35942     +        %let name    = %sysfunc(getvarc(&dsid, &nameNum));
35943     +        %let grpname = %sysfunc(getvarc(&dsid, &grpnameNum));
35945     +        %if &name ne &oldname %then %do;
35946     +             filename _F1 "&em_user_bincode&em_dsep.&grpname..sas" MOD;
35947     +             data _null_;
35948     +                length string $1024 flag endflag 8;
35949     +                retain string flag endflag;
35950     +                set class_nosv end=eof;
35951     +                where DISPLAY_VAR ="&name";
35952     +                by _variable_ _group_;
35953     +                file _F1;
35954     +                index = kindex(_variable_, "BIN_");
35955     +                if index gt 0 then do;
35956     +                   if first._variable_ then do;
35957     +                      put ' ';
35958     +                      put "&EM_CODEBAR;";
35959     +                      string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
35960     +                      put string;
35961     +                      put "&EM_CODEBAR;";
35963     +                      if origLabel ne "" then do;
35964     +                            string = 'LABEL '!!strip(_grp_variable_)!!' = ';
35965     +                            put string;
35966     +                            string = tranwrd(origLabel,"'","''");
35967     +                            string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
35968     +                            put string;
35969     +                      end;
35970     +                      else do;
35971     +                             string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
35972     +                             put string;
35973     +                      end;
35975     +                      put ' ';
35977     +                      string =  "if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
35978     +                      put string;
35979     +                      string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
35980     +                      put string;
35981     +                      put "end;";
35982     +                      string = "else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
35983     +                      put string;
35984     +                   end;
35985     +                   if first._group_ then do;
35986     +                      flag = 0;
35987     +                      endflag = 1;
35988     +                      if ^first._variable_ then do;
35989     +                         put "else";
35990     +                      end;
35991     +                      if LB ne . then do;
35992     +                         string = "if "!!strip(LB)!!" <= "!!strip(DISPLAY_VAR);
35993     +                      end;
35994     +                      else do;
35995     +                         flag = 1;
35996     +                         string = "if";
35997     +                      end;
35998     +                   end;
35999     +                   if last._Group_ then do;
36000     +                      if UB ne . then do;
36001     +                        if flag ne 1 then do;
36002     +                          string = strip(string)!!" AND "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
36003     +                        end;
36004     +                        else do;
36005     +                          string = "if "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
36006     +                        end;
36007     +                      end;
36008     +                      else do;
36009     +                         if flag=1 then do;
36010     +                            string = strip(DISPLAY_VAR) ;
36011     +                            string = strip(string)!!'='!!strip(_split_Value_)!!" then do;";
36012     +                            endflag=0;
36013     +                            string="";
36014     +                         end;
36015     +                         else do;
36016     +                            string = strip(string)!!" then do;";
36017     +                         end;
36018     +                      end;
36019     +                      put string;
36020     +                      string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
36021     +                      put string;
36022     +                      if endflag eq 1 then do;
36023     +                        put "end;";
36024     +                      end;
36025     +                   end;
36026     +                   if last._variable_ then do;
36027     +                     string = "end;";
36028     +                     put string;
36029     +                   end;
36031     +                end;
36032     +                else do;
36033     +                   _split_value_ = tranwrd(_split_value_,"'","''");
36034     +                   if first._group_ then do;
36035     +                      flag=0;
36036     +                      if ^first._variable_ then
36037     +                         put 'else';
36038     +                      else do;
36039     +                         put ' ';
36040     +                         put "&EM_CODEBAR;";
36041     +                         string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
36042     +                         put string;
36043     +                         put "&EM_CODEBAR;";
36045     +                         if origLabel ne "" then do;
36046     +                               string = 'LABEL '!!strip(_grp_variable_)!!' = ';
36047     +                               put string;
36048     +                               string = tranwrd(origLabel,"'","''");
36049     +                               string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
36050     +                               put string;
36051     +                         end;
36052     +                         else do;
36053     +                               string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
36054     +                               put string;
36055     +                         end;
36057     +                         put ' ';
36059     +                         if format ne '' then do;
36060     +                            if first._variable_ then do;
36061     +                               string = "_UFormat200 = put("!!strip(DISPLAY_VAR)!!","!!strip(format)!!");";
36062     +                               put string;
36063     +                               string = '%dmnormip(_UFormat200);';
36064     +                               put string;
36066     +                               string ="if MISSING(_UFormat200) then do;";
36067     +                               put string;
36068     +                               string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
36069     +                               put string;
36070     +                               put "end;";
36072     +                               string="else if NOT MISSING(_UFormat200) then do;";
36073     +                               put string;
36075     +                            end;
36076     +                         end;
36077     +                         else do;
36078     +                            if type = 'N' then do;
36079     +                              string ="if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
36080     +                              put string;
36081     +                              string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
36082     +                              put string;
36083     +                              put "end;";
36085     +                              string="else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
36086     +                              put string;
36087     +                            end;
36088     +                            else if type='C' then do;
36089     +                              string = "_UFormat200 = "||strip(DISPLAY_VAR)||";";
36090     +                              put string;
36091     +                              string = '%dmnormip(_UFormat200);';
36092     +                              put string;
36094     +                              string ="if MISSING(_UFormat200) then do;";
36095     +                              put string;
36096     +                              string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
36097     +                              put string;
36098     +                              put "end;";
36100     +                              string="else if NOT MISSING(_UFormat200) then do;";
36101     +                              put string;
36102     +                              string = '%dmnormip(_UFormat200);';
36103     +                              put string;
36104     +                           end;
36105     +                         end;
36106     +                      end;
36107     +                      if format ne '' OR type='C' then do;
36108     +                        string = "if (_UFormat200 eq '"!!strip(_split_value_)!!"'";
36109     +                      end;
36110     +                      else do;
36111     +                        string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
36112     +                      end;
36113     +                   end;
36114     +                   else do;
36115     +                      if flag ne 1 then do;
36116     +                       if format ne '' OR type='C' then do;
36117     +                         tempstring = strip(string)!!" OR _UFormat200 eq '"!!strip(_split_value_)!!"'";
36118     +                       end;
36119     +                       else do;
36120     +                         tempstring = strip(string)!!" OR "!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
36121     +                       end;
36122     +                         length = length(tempstring);
36124     +                         if length < 195 then do;
36125     +                            string = tempstring;
36126     +                         end;
36127     +                         else do;
36129     +                            string = strip(string);
36130     +                            put string;
36131     +                            string = ") then do;";
36132     +                            put string;
36134     +                            string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
36135     +                            put string;
36136     +                            put "end;";
36138     +                            put 'else';
36139     +                            if format ne '' OR type='C' then do;
36140     +                              string = "if (_UFormat200 eq '"!!strip(_split_value_)!!"'";
36141     +                            end;
36142     +                            else do;
36143     +                              string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
36144     +                            end;
36145     +                         end;
36146     +                      end;
36147     +                   end;
36149     +                   if last._group_ then do;
36150     +                      string = strip(string);
36151     +                      put string;
36153     +                      string = ") then do;";
36154     +                      put string;
36156     +                      string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
36157     +                      put string;
36158     +                      put "end;";
36159     +                   end;
36161     +                   if last._variable_ then do;
36162     +                     put "else do;";
36164     +                     string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
36165     +                     put string;
36167     +                     put "end;";
36168     +                     put "end;";
36169     +                   end;
36170     +                end;
36171     +             run;
36173     +             %let oldname = &name;
36174     +        %end;
36175     +    %end;
36176     +    %let dsid = %sysfunc(close(&dsid));
36178     +    filename _F1 "&em_user_bincode&em_dsep._ALL_.sas";
36179     +    data _null_;
36180     +       file _F1;
36181     +       put "length _UFormat200 $200;";
36182     +       put "drop _UFormat200;";
36183     +       put "_UFormat200='';";
36184     +    run;
36185     +    filename _F1;
36187     +   %em_register(key=EMSCOREVAR, type=DATA);
36188     +   %let scorevarDs = %scan(&em_user_emscorevar, 2, .);
36189     +   proc datasets lib=&em_lib nolist;
36190     +      delete &scorevarDs;
36191     +   run;
36192     +   quit;
36194     +   %let filrf=mydir;
36195     +   %let rc=%sysfunc(filename(filrf,&em_user_bincode));
36196     +   %let did=%sysfunc(dopen(&filrf));
36198     +   %if &did %then %do;  %PUT  did= &did;
36199     +       %let memcount=%sysfunc(dnum(&did));
36200     +       %if &memcount > 0 %then %do;
36201     +           data &em_user_emscorevar;
36202     +              length Name $32 formula $70 file $200;
36203     +              keep NAME Formula file;
36204     +              formula  = '';
36205     +           %if %sysfunc(fileexist(&em_user_bincode&em_dsep._ALL_.sas)) %then %do;
36206     +               name=''; file="BINCODE&em_dsep._ALL_.sas";
36207     +               output;
36208     +           %end;
36209     +           %do i=1 %to &memcount;
36210     +               %let name =%nrbquote(%sysfunc(dread(&did,&i)));
36211     +               %let newvar = %scan(&name, 1, .);
36212     +               %if "&newvar" ne "_ALL_" %then %do;
36213     +                   name = "&newvar"; file="BINCODE&em_dsep&name";
36214     +                   output;
36215     +               %end;
36216     +           %end;
36218     +           run;
36219     +       %end;
36220     +       %let did = %sysfunc(dclose(&did));
36221     +  %end;
36223     +   %doendu:
36224     +%mend buildOptScoreCode;
36227     +%macro buildScoreCode(flowCode, publishCode);
36230     +  filename x "&flowCode";
36232     +  proc sort data=&EM_USER_SPLITVALS; by display_var _split_Value_; run;
36233     +  proc sort data=&EM_USER_BINMAPPINGS; by display_var bin; run;
36234     +  proc sort data=&EM_USER_coarse out=tempcoarse; by display_var _group_; run;
36236     +  data temp;
36237     +    merge &EM_USER_SPLITVALS &EM_USER_BINMAPPINGS(rename=(BIN=_SPLIT_VALUE_ BIN_NAME=_VARIABLE_));
36238     +    by display_var _Split_value_;
36239     +     if upcase(_Split_value_) ne 'MISSING';
36240     +   run;
36242     +   data temp_missing;
36243     +     merge &EM_USER_SPLITVALS(rename=(_GROUP_=MISSGRP)) &EM_USER_BINMAPPINGS(rename=(
36244     +          BIN=_SPLIT_VALUE_ BIN_NAME=_VARIABLE_));
36245     +     by display_var _Split_value_;
36246     +     if upcase(_Split_value_) eq 'MISSING';
36247     +     keep _variable_ display_var missgrp;
36248     +   run;
36250     +   proc sort data=temp_missing; by display_var missgrp; run;
36252     +   data temp_missing;
36253     +     merge temp_missing(in=_a) tempcoarse(rename=(_GROUP_=MISSGRP));
36254     +     by display_var missgrp;
36255     +     if ^_a then delete;
36256     +     keep _variable_ display_var missgrp ;
36257     +   run;
36259     +   data temp;
36260     +     merge temp temp_missing;
36261     +     by display_var;
36262     +     if display_Var eq '' then delete;
36263     +    run;
36265     +    /* pull in wtev values */
36266     +    proc sort data=&EM_USER_varmappings out=tempmappings; by _variable_; run;
36267     +    proc sort data=&EM_IMPORT_DATA_CMETA out=tempcmeta; by NAME; run;
36268     +    proc sort data=temp;  by display_var _group_; run;
36270     +   data temp;
36271     +      merge temp tempcoarse(keep=display_var _group_  role) ;
36272     +      by display_var _group_;
36273     +    run;
36275     +    data temp;
36276     +      merge temp tempmappings(rename=(_variable_ = display_var)) tempcmeta(keep=NAME FORMAT TYPE LABEL rename=(NAME=display_var LABEL=origLabel));
36277     +      by display_var;
36279     +      if _group_ = . then delete;
36280     +      if _variable_ = '' then delete;
36281     +    run;
36283     +    proc sort data=temp out=class;
36284     +       by _variable_ _group_ LB;
36285     +    run;
36287     +    data _null_;
36288     +      file X;
36290     +      put "length _UFormat200 $200;";
36291     +      put "drop _UFormat200;";
36292     +      put "_UFormat200='';";
36293     +    run;
36295     +    data class_nosv;
36296     +      set class;
36297     +      if upcase(role)="INPUT";
36298     +    run;
36300     +    data _null_;
36301     +       file X MOD;
36302     +       length string $1024 flag endflag 8;
36303     +       retain string flag endflag;
36304     +       set class_nosv end=eof;
36305     +       by _variable_ _group_;
36307     +       index = kindex(_variable_, "BIN_");
36308     +       if index gt 0 then do;
36310     +         if first._variable_ then do;
36311     +            put ' ';
36312     +            put "&EM_CODEBAR;";
36313     +            string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
36314     +            put string;
36315     +            put "&EM_CODEBAR;";
36318     +            if origLabel ne "" then do;
36319     +              string = 'LABEL '!!strip(_grp_variable_)!!' = ';
36320     +              put string;
36321     +              string = tranwrd(origLabel,"'","''");
36322     +              string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
36323     +              put string;
36324     +            end;
36325     +            else do;
36326     +             string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
36327     +             put string;
36328     +            end;
36330     +            put ' ';
36332     +            string =  "if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
36333     +            put string;
36334     +            string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
36335     +            put string;
36336     +            put "end;";
36337     +            string = "else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
36338     +            put string;
36339     +          end;
36340     +           if first._group_ then do;
36341     +              flag = 0;
36342     +              endflag = 1;
36343     +              if ^first._variable_ then do;
36344     +                put "else";
36345     +              end;
36346     +              if LB ne . then do;
36347     +                 string = "if "!!strip(LB)!!" <= "!!strip(DISPLAY_VAR);
36348     +              end;
36349     +              else do;
36350     +                 flag = 1;
36351     +                 string = "if";
36352     +              end;
36354     +           end;
36355     +           if last._Group_ then do;
36356     +              if UB ne . then do;
36357     +                if flag ne 1 then do;
36358     +                  string = strip(string)!!" AND "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
36359     +                end;
36360     +                else do;
36361     +                  string = "if "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
36362     +                end;
36363     +              end;
36364     +              else do;
36365     +                 if flag=1 then do;
36366     +                   string = strip(DISPLAY_VAR) ;
36367     +                   string = strip(string)!!'='!!strip(_split_Value_)!!" then do;";
36368     +                   endflag = 0;
36369     +                   string="";
36370     +                 end;
36371     +                 else do;
36372     +                   string = strip(string)!!" then do;";
36373     +                 end;
36374     +              end;
36375     +              put string;
36377     +              string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
36378     +              put string;
36379     +              if endflag eq 1 then do;
36380     +                put "end;";
36381     +              end;
36382     +           end;
36383     +           if last._variable_ then do;
36384     +             string = "end;";
36385     +             put string;
36386     +           end;
36387     +       end;
36388     +       else do;
36389     +           _split_value_ = tranwrd(_split_value_,"'","''");
36390     +           if first._group_ then do;
36391     +              flag=0;
36392     +              if ^first._variable_ then
36393     +                 put 'else';
36394     +              else do;
36395     +                 put ' ';
36396     +                 put "&EM_CODEBAR;";
36397     +                 string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
36398     +                 put string;
36399     +                 put "&EM_CODEBAR;";
36401     +                 if origLabel ne "" then do;
36402     +                   string = 'LABEL '!!strip(_grp_variable_)!!' = ';
36403     +                   put string;
36404     +                   string = tranwrd(origLabel,"'","''");
36405     +                   string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
36406     +                   put string;
36407     +                 end;
36408     +                 else do;
36409     +                   string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
36410     +                   put string;
36411     +                 end;
36413     +                 put ' ';
36415     +                if format ne '' then do;
36416     +                  if first._variable_ then do;
36417     +                    string = "_UFormat200 = put("!!strip(DISPLAY_VAR)!!","!!strip(format)!!");";
36418     +                    put string;
36419     +                    string = '%dmnormip(_UFormat200);';
36420     +                    put string;
36422     +                     string ="if MISSING(_UFormat200) then do;";
36423     +                     put string;
36424     +                     string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
36425     +                     put string;
36426     +                     put "end;";
36428     +                     string="else if NOT MISSING(_UFormat200) then do;";
36429     +                     put string;
36431     +                  end;
36432     +                end;
36433     +                else do;
36434     +                     if type = 'N' then do;
36435     +                       string ="if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
36436     +                       put string;
36437     +                       string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
36438     +                       put string;
36439     +                       put "end;";
36441     +                       string="else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
36442     +                       put string;
36444     +                     end;
36445     +                     else if type='C' then do;
36446     +                        string = "_UFormat200 = "||strip(DISPLAY_VAR)||";";
36447     +                        put string;
36448     +                        string = '%dmnormip(_UFormat200);';
36449     +                        put string;
36451     +                        string ="if MISSING(_UFormat200) then do;";
36452     +                        put string;
36453     +                        string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
36454     +                        put string;
36455     +                        put "end;";
36457     +                        string="else if NOT MISSING(_UFormat200) then do;";
36458     +                        put string;
36459     +                        string = '%dmnormip(_UFormat200);';
36460     +                        put string;
36461     +                    end;
36462     +                end;
36463     +              end;
36464     +              if format ne '' OR type='C' then do;
36465     +                string = "if (_UFormat200 eq '"!!strip(_split_value_)!!"'";
36466     +              end;
36467     +              else do;
36468     +                string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
36469     +              end;
36470     +           end;
36471     +           else do;
36472     +              if flag ne 1 then do;
36473     +                if format ne '' OR type='C' then do;
36474     +                  tempstring = strip(string)!!" OR _UFormat200 eq '"!!strip(_split_value_)!!"'";
36475     +                end;
36476     +                else do;
36477     +                  tempstring = strip(string)!!" OR "!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
36478     +                end;
36479     +                length = klength(tempstring);
36481     +                if length < 195 then do;
36482     +                   string = tempstring;
36483     +                end;
36484     +                else do;
36486     +                   string = strip(string);
36487     +                   put string;
36488     +                   string = ") then do;";
36489     +                   put string;
36491     +                   string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
36492     +                   put string;
36493     +                   put "end;";
36495     +                 /*  string = strip(string)||",'...';"; */
36497     +                   put 'else';
36498     +                   if format ne '' OR type='C' then do;
36499     +                     string = "if (_UFormat200 eq '"!!strip(_split_value_)!!"'";
36500     +                   end;
36501     +                   else do;
36502     +                     string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
36503     +                   end;
36506     +                end;
36507     +              end;
36508     +           end;
36510     +           if last._group_ then do;
36511     +              string = strip(string);
36512     +              put string;
36513     +              string = ") then do;";
36514     +              put string;
36516     +              string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
36517     +              put string;
36518     +              put "end;";
36519     +           end;
36521     +           if last._variable_ then do;
36522     +             put "else do;";
36524     +             string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
36525     +             put string;
36527     +             put "end;";
36528     +             put "end;";
36529     +           end;
36530     +         *end;
36531     +       end;
36532     +    run;
36534     +    /* generate PublishCode the same as flowscorecode */
36535     +    filename Y "&publishCode";
36537     +    /* if publishCode already exists, wipe it out first */
36538     +    %if %sysfunc(fexist(Y)) eq 1 %then %do;
36539     +      %let rc = %sysfunc(fdelete(Y));
36540     +    %end;
36542     +    %appendfiles(Y, X);
36544     +    %if %EM_BINARY_TARGET= %then %do;
36545     +      %if %symexist(EM_NUM_INTERVAL_TARGET)=0 %then %do;
36546     +         %em_varMacro(name=EM_INTERVAL_TARGET, metadata=&EM_DATA_variableSet, where=%nrbquote(ROLE="TARGET" and LEVEL="INTERVAL" and (USE="Y" or USE="D")), nummacro=em_num_interval_Target);
36547     +      %end;
36548     +      %let ibn_inttarget=%EM_INTERVAL_TARGET;
36549     +      %let ibn_inttarget_orig = &ibn_inttarget;
36551     +      %if %symexist(IGNBinTarget)=0 %then %do;
36552     +         %global ignbintarget ignfreqvar;
36553     +         filename temp catalog 'sashelp.emutil.em_getvarname.source';
36554     +         %include temp;
36555     +         filename temp;
36556     +         %getVarName(&EM_IMPORT_DATA, BIN_%substr(&ibn_inttarget,1,%sysfunc(min(%length(&ibn_inttarget),28))), IGNBinTarget);
36558     +         %if &EM_PROPERTY_INTTARGETMETHOD = DUPFREQ %then %do;
36559     +            %getVarName(&EM_IMPORT_DATA, _FREQ_, ignfreqvar);
36560     +         %end;
36561     +      %end;
36562     +      %if &EM_PROPERTY_INTTARGETMETHOD = CUTMEAN %then %do;
36563     +         proc sql noprint;
36564     +            %if %EM_FREQ ne %then %do;
36565     +               select sum(&ibn_inttarget * %EM_FREQ) / sum(%EM_FREQ)
36566     +            %end;
36567     +            %else %do;
36568     +               select mean(&ibn_inttarget)
36569     +            %end;
36570     +            into :ignbincut trimmed from &EM_IMPORT_DATA;
36571     +         quit;
36572     +      %end;
36574     +      %let dsid=%sysfunc(open(&EM_IMPORT_DATA,i));
36575     +      %if &dsid %then %do;
36576     +         %let tarlabel=%trim(%sysfunc(varlabel(&dsid,%sysfunc(varnum(&dsid,&ibn_inttarget)))));
36577     +         %let rc=%sysfunc(close(&dsid));
36578     +      %end;
36579     +      %if %length(&tarlabel)=0 %then %let tarlabel = &ibn_inttarget;
36581     +      data _null_;
36582     +         file x mod;
36583     +         put ' ';
36585     +         %if &EM_PROPERTY_INTTARGETMETHOD = CUTMEAN %then %do;
36586     +             put "&EM_CODEBAR;";
36587     +             %let note = Mean Cutoff Binary Transformation for Target;
36588     +             put "* &note;";
36589     +             put "&EM_CODEBAR;";
36590     +         %end;
36591     +         %else %if &EM_PROPERTY_INTTARGETMETHOD = CUTUSER %then %do;
36592     +             put "&EM_CODEBAR;";
36593     +             %let note = User-Specified Cutoff Binary Transformation for Target;
36594     +             put "* &note;";
36595     +             put "&EM_CODEBAR;";
36596     +             %let ignbincut = &EM_PROPERTY_USERCUTVALUE;
36597     +         %end;
36598     +         put "if &ibn_inttarget = . then &IGNBinTarget = .;";
36599     +         put "else do;";
36600     +         put "   if &ibn_inttarget > &ignbincut then &IGNBinTarget=1;";
36601     +         put "   else &IGNBinTarget=0;";
36602     +         put "end;";
36604     +         put "label &IGNBinTarget = 'Binary: %nrbquote(%substr(&tarlabel,1,192))';";
36605     +      run;
36607     +      filename deltaref "&EM_FILE_CDELTA_TRAIN";
36609     +      %if &EM_PROPERTY_RejectIntTarget = Y %then %do;
36611     +         data _null_;
36612     +            file deltaref;
36613     +            put "if name='&ibn_inttarget_orig' then role='REJECTED';";
36614     +            put "if name='&IGNBinTarget' then do;";
36615     +            put "   role='TARGET';";
36616     +            put "   level='BINARY';";
36617     +            put "end;";
36618     +         run;
36620     +      %end;
36621     +      %else %do;
36623     +         data _null_;
36624     +            file deltaref;
36625     +            put "if name='&ibn_inttarget_orig' then role='TARGET';";
36626     +            put "if name='&IGNBinTarget' then do;";
36627     +            put "   role='REJECTED';";
36628     +            put "   level='BINARY';";
36629     +            put "end;";
36630     +         run;
36631     +      %end;
36633     +      filename deltaref;
36635     +   %end;
36637     +    filename X;
36638     +    filename Y;
36640     +    %buildOptScoreCode;
36642     +    proc datasets library=work nolist;
36643     +      delete class class_nosv temp temp_missing tempmappings tempcmeta;
36644     +    run;
36645     +    quit;
36647     +%mend buildScoreCode;
36649     +%macro buildMetaCode(DeltaCodeFile=);
36651     +   /* set variable roles based on New Role column in the Results table */
36652     +   data _null_;
36653     +      file &DeltaCodeFile %if %length(%EM_BINARY_TARGET)=0 %then mod;;
36654     +      %let dsid = %sysfunc(open(&EM_USER_RESULTSTABLE));
36655     +      %if &dsid %then %do;
36656     +        %let obs = %sysfunc(fetch(&dsid));
36657     +        %let vnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
36658     +        %let rnum = %sysfunc(VARNUM(&dsid, _new_role_));
36659     +        %let ornum = %sysfunc(VARNUM(&dsid, _role_));
36661     +        %do %while(&obs=0);
36662     +          %let inputname = %sysfunc(getvarc(&dsid, &vnum));
36663     +          %let role      = %upcase(%sysfunc(getvarc(&dsid, &rnum)));
36664     +          %let oldrole   = %upcase(%sysfunc(getvarc(&dsid, &ornum)));
36666     +          /* retrieve grp and woe names from varmappings dataset */
36667     +          %let choice = _VARIABLE_ = "&inputname";
36668     +          %let cdsid = %sysfunc(open(&EM_USER_VARMAPPINGS(where=(&choice))));
36669     +          %let cobs = %sysfunc(fetchobs(&cdsid, 1));
36670     +          %let grpnum = %sysfunc(VARNUM(&cdsid, _GRP_VARIABLE_));
36671     +          %let grpname = %sysfunc(getvarc(&cdsid, &grpnum));
36672     +          %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
36674     +          put "if name = '&inputname' then role='REJECTED';";
36675     +          %if "&role" ne "DEFAULT" %then %do;
36676     +            put "if name = '&grpname' then role='&role';";
36677     +          %end;
36678     +          %else %do;
36679     +            put "if name = '&grpname' then role='&oldrole';";
36680     +          %end;
36681     +          put "if name = '&grpname' then level='&EM_PROPERTY_GRPMSMNT';";
36683     +          %let obs = %sysfunc(fetch(&dsid));
36684     +        %end;
36685     +      %end;
36686     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
36687     +   run;
36689     +   /* drop all vars in the splitvals dataset that aren't present in the varmappings dataset */
36690     +   data _null_;
36691     +      file &DeltaCodeFile MOD;
36693     +      %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
36694     +      %if &sdsid %then %do;
36695     +        %let sobs = %sysfunc(fetch(&sdsid));
36696     +        %do %while(&sobs=0);
36697     +          %let varnum = %sysfunc(VARNUM(&sdsid, _VARIABLE_));
36698     +          %let checkname = %sysfunc(getvarc(&sdsid, &varnum));
36699     +          %let dispvarnum = %sysfunc(VARNUM(&sdsid, DISPLAY_VAR));
36700     +          %let displayvar = %sysfunc(getvarc(&sdsid, &dispvarnum));
36702     +          %let checkgrp = GRP_&checkname;
36703     +          %let lenname = %length(&checkgrp);
36704     +          %if %eval(&lenname-32) > 0 %then %do;
36705     +            %let checkgrp = %substr(&checkgrp, 1, 32);
36706     +          %end;
36708     +          %let choice = _VARIABLE_ ="&checkname";
36709     +          %let vdsid = %sysfunc(open(&EM_USER_VARMAPPINGS(where=(&choice))));
36711     +          /* if var not found in varmappings, delete variables; */
36712     +          /* this could happen when freeze=Y and vars in the frozen dataset aren't in the incoming training data */
36713     +          %if &vdsid eq 0 %then %do;
36714     +            put 'if name="&displayvar" then delete;';
36715     +            %let dispgrp = GRP_&displayvar;
36716     +            put 'if name="&dispgrp" then delete;';
36717     +          %end;
36719     +          %if &vdsid > 0 %then %let vdsid = %sysfunc(close(&vdsid));
36720     +          %let sobs = %sysfunc(fetch(&sdsid));
36721     +        %end;
36722     +      %end;
36723     +      %if &sdsid > 0 %then %let sdsid= %sysfunc(close(&sdsid));
36724     +   run;
36726     +%mend buildMetaCode;
36728     +%macro EM_GENERATE_RESULTSTABLE(coarse, resultstable, varmappings);
36730     +   proc sort data=&coarse out=sortedcoarse nodupkey;
36731     +     by display_var;
36732     +   run;
36733     +   proc sort data=&varmappings nodupkey;
36734     +     by _variable_;
36735     +   run;
36736     +   %if %sysfunc(exist(&resultstable, data)) %then %do;
36737     +     proc sort data=&resultstable; by display_var; run;
36739     +     /* check that _new_role exists - did not exist in earlier releases */
36740     +     %let rds=%sysfunc(open(&resultstable));
36741     +     %let _newrolenum = %sysfunc(VARNUM(&rds, _new_role_));
36742     +     %let rds=%sysfunc(close(&rds));
36743     +   %end;
36745     +   data &resultstable (Keep = display_var _gini_  _role_ _new_role_ procLevel);
36746     +     merge sortedcoarse(in=_a) &varmappings(rename=(_Variable_ = DISPLAY_VAR))
36747     +     %if %sysfunc(exist(&resultstable, data)) %then %do;
36748     +        &resultstable (keep = display_var %if &_newrolenum %then _new_role_; )
36749     +     %end;
36750     +     ;
36751     +     by display_var;
36752     +     length _role_ _new_role_ $10;
36753     +     label display_var = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel , NOQUOTE))"
36754     +           _gini_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_ginistatistic_vlabel , NOQUOTE))"
36755     +           _role_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_calcrole_vlabel, NOQUOTE))"
36756     +           _new_role_ = "%sysfunc(sasmsg(sashelp.dmine, meta_NEWROLE_vlabel, NOQUOTE))"
36757     +           LEVEL      = "%sysfunc(sasmsg(sashelp.dmine, rpt_level_vlabel , NOQUOTE))"
36758     +           ;
36760     +           %if &EM_PROPERTY_VARSELMETHOD eq GINI %then %do;
36761     +             if _gini_ < &EM_PROPERTY_GINICUTOFF then
36762     +                _role_ = "Rejected";
36763     +             else _role_ = "Input";
36764     +           %end;
36765     +           %else %do;
36766     +             _role_ = "Input";
36767     +           %end;
36768     +           if _new_role_ eq "" then _new_role_="Default";
36769     +      if ^_a then do;
36770     +        _gini_ = 0;
36771     +        _role_ = 'Rejected';
36772     +        if _new_role_ eq "" then _new_role_="Default";
36773     +      end;
36774     +   run;
36775     +   proc sort data=&EM_DATA_VARIABLESET out=outlabel(keep=NAME LABEL LEVEL rename=(NAME=display_var LABEL=_label_));
36776     +     by NAME;
36777     +   run;
36778     +   data outlabel;
36779     +     set outlabel;
36780     +     if _label_ = '' then _label_ = _variable_;
36781     +   run;
36782     +   data &resultstable;
36783     +     merge &resultstable(in=_a_) outlabel;
36784     +     by display_Var;
36785     +     if _a_ then output;
36786     +   run;
36787     +   proc datasets library=work nolist;
36788     +     delete sortedcoarse outlabel;
36789     +   run;
36790     +   quit;
36791     +   proc sort data=&resultstable nodupkey;
36792     +      by DESCENDING
36793     +        _gini_ display_Var;
36794     +   run;
36795     +   data &resultstable;
36796     +     set &resultstable;
36798     +     label giniOrder = "%sysfunc(sasmsg(sashelp.dmine, rpt_giniorder_vlabel , NOQUOTE))"
36799     +           LEVEL      = "%sysfunc(sasmsg(sashelp.dmine, rpt_level_vlabel , NOQUOTE))";
36800     +     giniOrder = _N_;
36801     +     _gini_ = round(_GINI_, .001);
36802     +     drop _variable_;
36803     +   run;
36805     +   proc print data=&resultstable label;
36806     +   run;
36808     +   /* merge role, infovalOrder or giniOrder back into Coarse table as well */
36809     +   data &coarse;
36810     +     set &coarse;
36811     +     length role $10;
36812     +     %let dsid = %sysfunc(open(&resultstable));
36813     +     %if &dsid %then %do;
36814     +       %let disnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
36815     +       %let rolenum = %sysfunc(VARNUM(&dsid, _ROLE_));
36816     +       %let orderNum = %sysfunc(VARNUM(&dsid, giniOrder));
36818     +       %let obs = %sysfunc(fetch(&dsid));
36819     +       %do %while(&obs=0);
36820     +          %let displayvar = %sysfunc(getvarc(&dsid, &disnum));
36821     +          %let role       = %sysfunc(getvarc(&dsid, &rolenum));
36822     +          %let order = %sysfunc(getvarn(&dsid, &ordernum));
36824     +                                                                                               if DISPLAY_VAR = "&displayVar" then do;
36825     +            label giniOrder = "%sysfunc(sasmsg(sashelp.dmine, rpt_giniorder_vlabel , NOQUOTE))";
36826     +            giniOrder = &order;
36827     +            role = "&role";
36828     +          end;
36830     +          %let obs = %sysfunc(fetch(&dsid));
36831     +       %end;
36832     +     %end;
36833     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
36834     +   run;
36837     +%mend EM_GENERATE_RESULTSTABLE;
36839     +%macro EM_GENERATE_EXPORTGROUP(exportGrouping, createMethod);
36841     +    /* instantiate the zchar macro to be used in adding bin definition */
36842     +    filename _temp catalog 'sashelp.emmacs.zchar.source';
36843     +    %inc _temp;
36844     +    filename _temp;
36846     +    proc sort data=&EM_USER_FINEDETAILDATA out=sortedfine;
36847     +      by _variable_ binFlag _group_ LB;
36848     +    run;
36850     +    data tempExport;
36851     +      set sortedFine;
36852     +      by _variable_ binFlag _group_;
36853     +      length _split_value_ $200;
36855     +      /* for all binned variables, need to modify the split value to original cutoff as well as change level to interval */
36856     +      if binFlag = 0 then do;
36857     +        index = kindex(_variable_, "BIN_");
36858     +        if index gt 0 then do;
36859     +          _LEVEL_ = "INTERVAL";
36860     +        end;
36861     +        _Split_value_ = _split_value_;
36862     +        output;
36863     +      end;
36864     +      else do;
36865     +         * if last._group_ then do;
36866     +          index = kindex(_variable_, "BIN_");
36867     +          if index gt 0 then do;
36868     +            _LEVEL_ = "INTERVAL";
36869     +          end;
36870     +          _Split_value_ = %zchar(UB);
36871     +          output;
36872     +         * end;
36873     +      end;
36875     +      rename display_Var = _variable_;
36876     +      keep display_var _level_ _group_ _split_value_ binFlag;
36877     +    run;
36879     +    %if &CREATEMETHOD eq OVERWRITE %then %do;
36880     +       data &EXPORTGROUPING;
36881     +         set tempexport;
36882     +       run;
36883     +    %end;
36884     +    %else %do;
36885     +       /* determine if EXPORTGROUPING already exists */
36886     +       %if %sysfunc(exist(&EXPORTGROUPING, DATA)) %then %do;
36887     +         data &EXPORTGROUPING;
36888     +            set &EXPORTGROUPING tempexport;
36889     +         run;
36890     +       %end;
36891     +       %else %do;
36892     +         data &EXPORTGROUPING;
36893     +            set tempexport;
36894     +         run;
36895     +       %end;
36896     +    %end;
36898     +    proc datasets lib=work nolist;
36899     +      delete sortedFine tempexport;
36900     +    run;
36901     +    quit;
36903     +%mend EM_GENERATE_EXPORTGROUP;
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(MAIN):  ;
MPRINT(MAIN):   filename temp catalog 'sashelp.emmdfy.binning_train.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMDFY.BINNING_TRAIN.SOURCE.
36909     +%macro train;
36911     +   /* include training macros */
36912     +   filename trtemp catalog 'sashelp.emmdfy.binning_trainmacros.source';
36913     +   %include trtemp;
36914     +   filename trtemp;
36916     +   /* trick IGN into thinking it is a model node to build decmeta; further down, set %EM_MODEL ASSESS=N
36917     +   %let EM_TOOLTYPE = MODEL; */
36919     +   %if &EM_IMPORT_DATA eq %then %do;
36920     +       %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN, 1;
36921     +       %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, error_nodeTrainRawData_note , NOQUOTE));
36922     +       %put &em_codebar;
36923     +       %put &errmsg;
36924     +       %put &em_codebar;
36925     +       %goto doendm;
36926     +   %end;
36928     +   %if  &EM_NUM_TARGET ne 1 %then %do;
36929     +        %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1BINORINTTARGET;
36930     +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, METADATA.USE1BINORINTTARGET_ERR  , NOQUOTE));
36931     +        %put &em_codebar;
36932     +        %put &errmsg;
36933     +        %put &em_codebar;
36934     +        %goto doendm;
36935     +   %end;
36937     +  %if  &EM_NUM_BINARY_TARGET ne 1 and &EM_NUM_INTERVAL_TARGET ne 1 %then %do;
36938     +        %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1BINORINTTARGET;
36939     +        %put &em_codebar;
36940     +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, METADATA.USE1BINORINTTARGET_ERR, NOQUOTE));
36941     +        %put &errormsg;
36942     +        %put &em_codebar;
36943     +        %goto doendm;
36944     +   %end;
36946     +   /* Initialize property macro variables */
36947     +   %SetProperties;
36948     +   %EM_GETNAME(key=NEWTRAIN, type=DATA);
36950     +   /* check actual num of target levels */
36951     +   %let target_level = %EM_TARGET_LEVEL;
36952     +   %let target_var = %EM_TARGET;
36953     +   %if (&target_Level eq BINARY) %then %do;
36954     +      /* retrieve target information */
36955     +      /* does decmeta exist?  If not, retrieve target information elsewhere */
36956     +      %global target_event;
36957     +      %let target_event=;
36959     +     /* need to check that order is the same in both for cases where they can be out of synch */
36960     +     %if "&EM_DEC_DECMETA" ne "" %then %do;
36961     +         /* retrieve target information */
36962     +         %let dsid=%sysfunc(open(&EM_DEC_DECMETA(where=(_TYPE_='TARGET'))));
36964     +         %let vn_event =%sysfunc(varnum(&dsid, EVENT));
36965     +         %let vn_target_type = %sysfunc(varnum(&dsid, TYPE));
36966     +         %let vn_target_format = %sysfunc(varnum(&dsid, FORMAT));
36967     +         %let vn_target_order = %sysfunc(varnum(&dsid, ORDER));
36969     +         %do %while(^ %sysfunc(fetch(&dsid)));
36970     +            %let temp = %nrbquote(%sysfunc(getvarc(&dsid, &vn_event)));
36971     +            %let Target_Event = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
36972     +            %let Target_Type =  %sysfunc(getvarc(&dsid, &vn_target_type));
36973     +            %let Target_Format = %sysfunc(getvarc(&dsid, &vn_target_format));
36974     +            %let Target_Order_DM = %sysfunc(getvarc(&dsid, &vn_target_order));
36975     +         %end;
36976     +         %let dsid = %sysfunc(close(&dsid));
36977     +     %end;
36978     +     %else %let Target_Order_DM=;
36980     +     /* retrieve type and format from variableset */
36981     +     %let eventorder = DESC;
36982     +     data temp;
36983     +       set &EM_DATA_VARIABLESET;
36984     +       where NAME ="%EM_BINARY_TARGET";
36985     +     run;
36987     +     %let dsid = %sysfunc(open(work.temp));
36988     +     %if &dsid %then %do;
36989     +       %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
36990     +       %let formatnum = %sysfunc(VARNUM(&dsid, FORMAT));
36991     +       %let ordernum  = %sysfunc(VARNUM(&dsid, ORDER));
36992     +       %let obs = %sysfunc(fetchobs(&dsid, 1));
36993     +       %let Target_type = %sysfunc(getvarc(&dsid, &typenum));
36994     +       %let Target_Format = %sysfunc(getvarc(&dsid, &formatnum));
36995     +       %let Target_Order  = %sysfunc(getvarc(&dsid, &ordernum));
36996     +     %end;
36997     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
36999     +     %if "&EM_DEC_DECMETA" eq "" or ("&Target_Order" ne "&Target_Order_DM") %then %do;
37001     +       %if &TARGET_ORDER  = ASC %then %let eventorder = ASC;
37002     +          %else
37003     +       %if &TARGET_ORDER  = DESC %then %let eventorder = DESC;
37004     +          %else
37005     +       %if &TARGET_ORDER  = FMTASC %then %let eventorder = ASCFMT;
37006     +          %else
37007     +       %if &TARGET_ORDER  = FMTDESC %then %let eventorder = DESFMT;
37009     +        /* retrieve target_event and Target_nonEvent values */
37010     +        proc dmdb data=&EM_IMPORT_DATA(where=(^missing(%EM_BINARY_TARGET))) classout=EVENTOUT;
37011     +          target %EM_BINARY_TARGET;
37012     +          class  %EM_BINARY_TARGET(&eventorder);
37013     +        run;
37015     +        data _null_;
37016     +          dsid = open("EVENTOUT");
37017     +          if dsid>0 then do;
37018     +          levelnum = VARNUM(dsid, "LEVEL");
37019     +          if levelnum then do;
37020     +            if ^fetch(dsid) then
37021     +              call symput('TARGET_EVENT',   strip(getvarc(dsid, levelnum)));
37023     +            if ^fetch(dsid) then
37024     +              call symput('TARGET_NONEVENT',strip(getvarc(dsid, levelnum)));
37025     +          end;
37026     +          dsid=close(dsid);
37027     +          end;
37028     +        run;
37029     +        proc datasets library=work nolist;
37030     +           delete eventout;
37031     +        run;
37032     +        quit;
37033     +      %end;
37034     +      %else %do;
37035     +          %let dsid=%sysfunc(open(&EM_DEC_DECDATA(where=(%EM_BINARY_TARGET ne "&Target_Event"))));
37036     +          %let obs = %sysfunc(fetchobs(&dsid, 1));
37037     +           %let vn_nonevent = %sysfunc(varnum(&dsid, %EM_BINARY_TARGET));
37038     +           %let Target_NonEvent= %sysfunc(getvarc(&dsid, &vn_nonevent));
37039     +         %let dsid = %sysfunc(close(&dsid));
37040     +      %end;
37042     +      %global ignbintarget;
37043     +      %let ignbintarget = %EM_BINARY_TARGET;
37045     +      data &EM_USER_NEWTRAIN;
37046     +        set &EM_IMPORT_DATA;
37047     +      run;
37048     +   %end;
37049     +   %else %do; /* preprocessing for interval target */
37050     +      %if &EM_PROPERTY_INTTARGETMETHOD=CUTUSER %then %do;
37051     +         proc dmdb data=&EM_IMPORT_DATA varout=minmax;
37052     +            var &target_var;
37053     +         run;
37055     +         data _null_;
37056     +            set minmax;
37057     +            call symput('tarmax',strip(max));
37058     +            call symput('tarmin',strip(min));
37059     +         run;
37061     +         /* cutoff can equal tarmin but not tarmax */
37062     +         %if %sysevalf(&EM_PROPERTY_USERCUTVALUE >= &tarmax) or %sysevalf(&EM_PROPERTY_USERCUTVALUE < &tarmin) %then %do;
37063     +            %let EMEXCEPTIONSTRING = exception.server.IGN.CUTOFFOUTOFRANGE,&tarmin,&tarmax;
37064     +            %put &em_codebar;
37065     +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, cutoffoutofrange_error, NOQUOTE, &tarmin, &tarmax));
37066     +            %put &errormsg;
37067     +            %put &em_codebar;
37068     +            %goto doendm;
37069     +         %end;
37070     +      %end;
37072     +      %global ignbintarget;
37073     +      %getVarName(&EM_IMPORT_DATA, BIN_%substr(%EM_INTERVAL_TARGET,1,%sysfunc(min(%length(%EM_INTERVAL_TARGET),28))), IGNBinTarget);
37075     +      %EM_IBN_IntTargetTrans(%EM_INTERVAL_TARGET,&EM_PROPERTY_INTTARGETMETHOD,newLevels=igntbinlevs);
37076     +      %if &igntbinlevs ne 2 %then %do;
37077     +         %let EMEXCEPTIONSTRING = exception.server.IGN.NONBINTARGETTRANS;
37078     +         %put &em_codebar;
37079     +         %let errormsg = %sysfunc(sasmsg(sashelp.dmine, nonbintargettrans_error, NOQUOTE));
37080     +         %put &errormsg;
37081     +         %put &em_codebar;
37082     +         %goto doendm;
37083     +      %end;
37085     +      %let Target_Event = 1;
37086     +      %let Target_NonEvent = 0;
37087     +      %let Target_Type = BINARY;
37088     +      %let Target_Format = ;
37090     +   %end;
37092     +   /* data sets */
37093     +   %EM_GETNAME(key=BINDATA,        type=DATA);
37094     +   %EM_GETNAME(key=SPLITVALS,      type=DATA);
37095     +   %EM_GETNAME(key=VARMAPPINGS,    type=DATA);
37096     +   %EM_GETNAME(key=BINMAPPINGS,    type=DATA);
37097     +   %EM_GETNAME(key=COARSE,          type=DATA);
37098     +   %EM_GETNAME(key=FINEDETAILDATA, type=DATA);
37099     +   %EM_GETNAME(key=RESULTSTABLE,   type=DATA);
37101     +   /* files */
37102     +   %EM_GETNAME(key=BINNINGCODE, type=FILE, extension=sas);
37103     +   %EM_GETNAME(key=GROUPMAPPINGSCORECODE, type=FILE, extension=sas);
37105     +   /* if freeze eq Y and no finedetaildata exists, throw an exception */
37106     +   %if &EM_PROPERTY_FREEZE eq Y %then %do;
37107     +     %if %sysfunc(exist(&EM_USER_FINEDETAILDATA, DATA)) ne 1 %then %do;
37108     +        %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOFINEDETAIL;
37109     +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, nofinedetail_error , NOQUOTE));
37111     +        %put &em_codebar;
37112     +        %put &errmsg;
37113     +        %put &em_codebar;
37114     +        %goto doendm;
37115     +     %end;
37116     +   %end;
37118     +   %global useImport;
37119     +   %let useImport = 0;
37121     +   %EM_GETNAME(key=IMPORTSUBSET, type=DATA);
37123     +   %if %sysfunc(exist(&EM_USER_IMPORTSUBSET, DATA)) %then %do;
37124     +     proc datasets library=&EM_LIB nolist;
37125     +       delete &EM_NODEID._IMPORTSUBSET;
37126     +     run;
37127     +     quit;
37128     +   %end;
37130     +   /* if importGrouping=Y, verify that data and all vars exist and are of the correct type */
37131     +   %if &EM_PROPERTY_IMPORTGROUPING eq Y %then %do;
37133     +     /* if import eq Y and no importtable exists, throw an exception */
37134     +     %if %sysfunc(exist(&EM_PROPERTY_IMPORTDATA, DATA)) ne 1 %then %do;
37135     +        %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOIMPORT;
37136     +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, noimport_error , NOQUOTE));
37138     +        %put &em_codebar;
37139     +        %put &errmsg;
37140     +        %put &em_codebar;
37141     +        %goto doendm;
37142     +     %end;
37144     +      %let dsid = %sysfunc(open(&EM_PROPERTY_IMPORTDATA));
37145     +      %if &dsid %then %do;
37146     +         %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
37147     +         %let splitnum = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
37148     +         %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
37149     +         %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
37151     +         %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
37152     +           %let vtype = %sysfunc(VARTYPE(&dsid, &varnuM));
37153     +           %let stype = %sysfunc(VARTYPE(&dsid, &splitnum));
37154     +           %let gtype = %sysfunc(VARTYPE(&dsid, &grpnum));
37155     +           %let ltype = %sysfunc(VARTYPE(&dsid, &lvlnum));
37156     +         %end;
37157     +      %end;
37158     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
37160     +      %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
37161     +        %if ((&vtype eq C) AND (&stype eq C) AND (&gtype eq N) AND (&ltype eq C)) %then %do;
37163     +        /* generate subset of data that contains those vars also found in training data and add display_var information */
37164     +        proc sort data=&EM_PROPERTY_IMPORTDATA out=tempimport;
37165     +           by _VARIABLE_ ;
37166     +        run;
37168     +        proc sort data=&EM_DATA_VARIABLESET out=tempvarset(keep=NAME rename=(NAME=_VARIABLE_));
37169     +          by NAME;
37170     +          where ((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y');
37171     +        run;
37173     +        data &EM_USER_IMPORTSUBSET;
37174     +          merge tempimport(in=_a) tempvarset(in=_b);
37175     +          length display_Var $32;
37176     +          by _VARIABLE_;
37177     +          display_var = _Variable_;
37178     +          if _a and _b then output;
37179     +        run;
37181     +        proc datasets library=work nolist;
37182     +          delete tempimport tempvarset;
37183     +        run;
37184     +        quit;
37186     +        %end;
37187     +      %end;
37188     +   %end;
37190     +   /* set useImport flag if there are obs in the importSubset dataset */
37191     +   %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET));
37192     +   %if &dsid %then %do;
37193     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
37194     +     %if &nobs gt 0 %then %let useimport = 1;
37195     +   %end;
37196     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
37198     +   %global useFreeze;
37199     +   %let useFreeze = 0;
37201     +   /* if Freeze=Y, verify that data and all vars exist and are of the correct type */
37202     +   %EM_GETNAME(key=FREEZESUBSET, type=DATA);
37204     +   %if %sysfunc(exist(&EM_USER_FREEZESUBSET, DATA)) %then %do;
37205     +     proc datasets library=&EM_LIB nolist;
37206     +       delete &EM_NODEID._FREEZESUBSET;
37207     +     run;
37208     +     quit;
37209     +   %end;
37211     +   %if &EM_PROPERTY_FREEZE eq Y %then %do;
37213     +      /* create freezesubset data to contain information on pre-binned data and raw values */
37214     +      %EM_GENERATE_EXPORTGROUP(&EM_USER_FREEZESUBSET, OVERWRITE);
37216     +      %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET));
37217     +      %if &dsid %then %do;
37218     +         %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
37219     +         %let splitnum = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
37220     +         %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
37221     +         %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
37223     +         %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
37224     +           %let vtype = %sysfunc(VARTYPE(&dsid, &varnuM));
37225     +           %let stype = %sysfunc(VARTYPE(&dsid, &splitnum));
37226     +           %let gtype = %sysfunc(VARTYPE(&dsid, &grpnum));
37227     +           %let ltype = %sysfunc(VARTYPE(&dsid, &lvlnum));
37228     +         %end;
37229     +      %end;
37230     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
37232     +      %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
37233     +        %if ((&vtype eq C) AND (&stype eq C) AND (&gtype eq N) AND (&ltype eq C)) %then %do;
37235     +        /* generate subset of data that contains those vars also found in training data */
37236     +        proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze;
37237     +           by _VARIABLE_ ;
37238     +        run;
37240     +        proc sort data=&EM_DATA_VARIABLESET out=tempvarset(keep=NAME rename=(NAME=_VARIABLE_));
37241     +          by NAME;
37242     +          where ((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y');
37243     +        run;
37245     +        data &EM_USER_FREEZESUBSET;
37246     +          merge tempfreeze(in=_a) tempvarset(in=_b);
37247     +          length display_Var $32;
37248     +          by _VARIABLE_;
37249     +          display_var = _Variable_;
37250     +          if _a and _b then output;
37251     +        run;
37253     +        proc datasets library=work nolist;
37254     +          delete tempfreeze tempvarset;
37255     +        run;
37256     +        quit;
37257     +        %end;
37258     +      %end;
37259     +   %end;
37261     +   /* set useFreeze flag if there are obs in the freezeSubset dataset */
37262     +   %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET));
37263     +   %if &dsid %then %do;
37264     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
37265     +     %if &nobs gt 0 %then %let useFreeze = 1;
37266     +   %end;
37267     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
37269     +   /* if finedetail already exists, delete prior to re-run */
37270     +   %if %sysfunc(exist(&EM_USER_FINEDETAILDATA, DATA)) %then %do;
37271     +     proc datasets library=&EM_LIB nolist;
37272     +       delete &EM_NODEID._FINEDETAILDATA;
37273     +     run;
37274     +     quit;
37275     +   %end;
37277     +   data tempvarnames;
37278     +     set &EM_DATA_VARIABLESET;
37279     +     where ((ROLE='INPUT' and USE in('Y', 'D')) or (ROLE='REJECTED' and USE='Y')) and level ne 'UNARY';
37280     +     keep NAME LEVEL LABEL;
37281     +   run;
37283     +   proc dmdb data=tempvarnames outtable=tempmapping nameserver;
37284     +     names NAME;
37285     +     prefix WOE_ GRP_ ;
37286     +   run;
37288     +   proc sort data=tempmapping; by name; run;
37289     +   proc sort data=tempvarnames; by name; run;
37290     +   data tempmapping;
37291     +     merge tempmapping tempvarnames;
37292     +     by NAME;
37293     +     rename LEVEL=procLevel;
37294     +   run;
37296     +   /* generate initial columns of mapping table by setting grpflag=0 */
37297     +   %EM_GENERATE_MAPPING_TABLE;
37299     +   proc datasets library=work nolist;
37300     +     delete tempImport tempScore;
37301     +   run;
37302     +   quit;
37304     +   /* delete splitvals dataset if this existed prior to run */
37305     +   %let nvars=0;
37306     +   %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
37307     +   %if &sdsid > 0 %then %do;
37308     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
37309     +   %end;
37310     +   %if &sdsid > 0 %then  %let sdsid=%sysfunc(close(&sdsid));
37312     +   %if &nvars > 0 %then %do;
37313     +      proc datasets library=&EM_LIB nolist;
37314     +        delete &EM_NODEID._SPLITVALS;
37315     +      run;
37316     +      quit;
37317     +   %end;
37319     +   %global classvars qclassvars;
37320     +   %let classvars=;
37321     +   %let qclassvars=;
37323     +   /* generate the intervalvars and classvars macros */
37324     +   %EM_PRE_BINNING(&EM_USER_NEWTRAIN);
37326     +   /* update varmappings with any changes to procLevel based on discretemid */
37327     +   data &EM_USER_VARMAPPINGS;
37328     +     set &EM_USER_VARMAPPINGS;
37329     +     /* procLevel column to indicate the level used by proc; this handles*/
37330     +     /* cases in which var is marked INTERVAL in metadat but treated as  */
37331     +     /* ordinal in prebinning because of # unique levels                 */
37332     +     %let dsid = %sysfunc(open(work._discretemid));
37333     +     %if &dsid %then %do;
37334     +       %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
37335     +       %let obs = %sysfunc(fetch(&dsid));
37336     +       %do %while(&obs=0);
37337     +          %let varname = %sysfunc(getvarc(&dsid, &varnum));
37338     +          if _variable_ = "&varname" then procLevel = "ORDINAL";
37339     +          %let obs = %sysfunc(fetch(&dsid));
37340     +       %end;
37341     +     %end;
37342     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
37343     +     label procLevel =  "%sysfunc(sasmsg(sashelp.dmine, rpt_proclevel_vlabel , NOQUOTE))";
37344     +   run;
37346     +   /* generate Grp_xxx variables for interval inputs */
37347     +   %if &EM_PROPERTY_BINMETHOD eq QUANTILE %then %do;
37348     +     %EM_QUANTILE_BINNING(&EM_USER_NEWTRAIN, WORK.PCTILE, &EM_USER_BINDATA, &EM_USER_BINNINGCODE);
37350     +   %end;
37351     +   %else %do;
37352     +     %EM_EQUAL_SPACED_BINNING(&EM_USER_NEWTRAIN, &EM_USER_BINDATA, &EM_USER_BINNINGCODE);
37353     +   %end;
37355     +   /* generate GRP_XXX variables for nominal inputs */
37356     +   %EM_CLASSVARS_GROUP(&EM_PROPERTY_CLASSGROUPRARE);
37358     +   /* generate GRP_XXX variables for ordinal inputs */
37359     +   %EM_ORDVARS_GROUP;
37361     +   proc print data=&EM_USER_VARMAPPINGS label;
37362     +     var _VARIABLE_ _GRP_VARIABLE_ ;
37363     +   run;
37365     +   /* add _proc_var_ to varmappings data to know names of processed variables; could be original input, could be bin_xxx */
37366     +   proc sort data=&EM_USER_SPLITVALS out=tempsplitvals nodupkey;
37367     +     by _VARIABLE_;
37368     +   run;
37370     +   data &EM_USER_VARMAPPINGS;
37371     +     set &EM_USER_VARMAPPINGS;
37372     +     length _proc_var_ $32;
37373     +     %let dsid = %sysfunc(open(work.tempsplitvals));
37374     +     %if &dsid %then %do;
37375     +        %let obs = %sysfunc(fetch(&dsid));
37376     +        %do %while(&obs=0);
37377     +          %let dispnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
37378     +          %let dispvar = %sysfunc(getvarc(&dsid, &dispnum));
37379     +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
37380     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
37382     +          if upcase(_VARIABLE_) = %upcase("&dispvar") then _proc_var_ = "&var";
37383     +          %let obs = %sysfunc(fetch(&dsid));
37384     +        %end;
37385     +     %end;
37386     +     if missing(_proc_var_) then _proc_var_=_variable_;
37387     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
37388     +   run;
37390     +   proc datasets library=work nolist;
37391     +     delete sortedbin tempsplitvals;
37392     +   run;
37393     +   quit;
37395     +   /* calculate Fine Detail statistics for each input */
37396     +   %EM_FINE_DETAIL(&EM_USER_BINDATA, &EM_USER_VARMAPPINGS, &EM_USER_FINEDETAILDATA, &EM_USER_SPLITVALS, &EM_USER_BINMAPPINGS);
37398     +   /* apply grouping and create grouped dataset */
37399     +   %EM_CREATE_GROUPING(&EM_USER_BINDATA, &EM_USER_FINEDETAILDATA, &EM_USER_COARSE);
37401     +   /* generate _label_ values in the COARSE dataset from the Scored data */
37402     +   filename Y "&EM_USER_GROUPMAPPINGSCORECODE";
37403     +   %EM_GENERATE_LABELVALUES(Y, &EM_USER_SPLITVALS, &EM_USER_BINMAPPINGS, &EM_USER_COARSE);
37404     +   filename Y;
37406     +   /* set EM_MODEL ASSESS=N to prevent assessment reports from being generated */
37407     +   %EM_MODEL(Target= &ignbintarget, ASSESS=N);
37409     +   /* generate reports */
37410     +   %EM_REPORT(key=COARSE, viewtype=DATA, block=MODEL, description=EVENTRATESTAT, autodisplay=N, spk=N);
37413     +   %doendm:
37414     +%mend train;
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(TRAIN):   filename trtemp catalog 'sashelp.emmdfy.binning_trainmacros.source';
NOTE: %INCLUDE (level 1) file TRTEMP is file SASHELP.EMMDFY.BINNING_TRAINMACROS.SOURCE.
37416     +%macro EM_GENERATE_MAPPING_TABLE;
37418     +  %EM_GETNAME(key=VARMAPPINGS, type=DATA);
37419     +  data &EM_USER_VARMAPPINGS(keep=_variable_  _grp_variable_ procLevel label);
37420     +   length _variable_  _grp_variable_  $32 procLevel $8;
37421     +   set tempmapping;
37422     +   label _variable_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_inputvar_vlabel , NOQUOTE))"
37423     +         _grp_variable_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_grpvar_vlabel , NOQUOTE))";
37425     +         _variable_ = NAME;
37426     +         _grp_variable_ = GRP;
37427     + run;
37429     +%mend EM_GENERATE_MAPPING_TABLE;
37431     +%macro EM_PRE_BINNING(input);
37432     +    /* Determine which of our variables are interval  */
37434     +    data tempvariableset;
37435     +      set &EM_DATA_VARIABLESET;
37436     +      where LEVEL = 'INTERVAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
37437     +    run;
37439     +    /* add all interval vars to the intervalvar macro
37440     +    %let dsid = %sysfunc(open(work.tempvariableset));
37441     +    %if &dsid %then %do;
37442     +       %let varnum = %sysfunc(VARNUM(&dsid, NAME));
37443     +       %let obs = %sysfunc(fetch(&dsid));
37444     +       %do %while(&obs=0);
37445     +          %let varname = %sysfunc(getvarc(&dsid, &varnum));
37446     +          %let intervalvars = &intervalvars &varname;
37447     +          %let obs = %sysfunc(fetch(&dsid));
37448     +       %end;
37449     +    %end;
37450     +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
37451     + */
37453     +   %em_varmacro(name=intervalvars, metadata=tempvariableset, key=NAME, nummacro=num_intvars);
37455     +    /* Determine which variables marked as interval are true interval distributions; */
37456     +    /* intmid contains variables that are actually interval and should be binned; */
37457     +    /* discretemid contains variables that are actually discrete and should NOT be binned */
37458     +    %if %intervalvars ne %then %do;
37459     +      %let _maxlevel = %eval(&EM_PROPERTY_NUMBINS + 1);
37460     +      proc dmdb data=&input classout=_CLASSOUT maxlevel=&_maxlevel;
37461     +        class %intervalvars;
37462     +      run;
37463     +      proc freq data=_CLASSOUT order=DATA noprint;
37464     +         table NAME / OUT= _COUNT(where=(COUNT<&_maxlevel));
37465     +      run;
37467     +      %let _INTBINS=;
37468     +      data _null_;
37469     +        set _COUNT;
37470     +        call symput('_INTBINS',symget('_INTBINS') !! ' ' !! ktrim(kleft(NAME)));
37471     +      run;
37473     +      proc sort data=_CLASSOUT;
37474     +        by NAME;
37475     +      run;
37476     +      proc transpose data=_CLASSOUT out=_OUT(DROP=_NAME_ RENAME=(NAME=VARIABLE)) prefix=_MIDPOINT;
37477     +        var NRAW;
37478     +        by NAME;
37479     +      run;
37481     +      data _null_;
37482     +        dsid = open('_OUT');
37483     +        if dsid then do;
37484     +           call symput('NUMCLASSBARS', kleft(ktrim(put(attrn(dsid, 'NVARS')-1, best12.))));
37485     +           csid = close(dsid);
37486     +        end;
37487     +      run;
37488     +      data _INTMID;
37489     +        set _OUT;
37490     +        keep VARIABLE _MIDPOINT1--_MIDPOINT&numclassbars;
37491     +        %if "&EM_PROPERTY_APPLYLEVELRULE" ne "N" %then %do;
37492     +          if ^indexw("&_INTBINS", VARIABLE) then output;
37493     +        %end;
37494     +      run;
37496     +      %if "&EM_PROPERTY_APPLYLEVELRULE" ne "N" %then %do;
37497     +        data _DISCRETEMID;
37498     +          set _OUT;
37499     +          keep VARIABLE _MIDPOINT1--_MIDPOINT&numclassbars;
37500     +          if indexw("&_INTBINS", VARIABLE) then output;
37501     +        run;
37502     +      %end;
37503     +      %else %do;
37504     +         %if %sysfunc(exist(_discretemid)) %then %do;
37505     +            proc delete data=_discretemid;
37506     +            run;
37507     +         %end;
37508     +      %end;
37510     +      /* add vars from the _DISCRETEMID dataset to the classvars macro
37511     +      %let dsid = %sysfunc(open(WORK._DISCRETEMID));
37512     +      %if &dsid %then %do;
37513     +        %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
37514     +        %let obs = %sysfunc(fetch(&dsid));
37516     +        %do %while(&obs=0);
37517     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
37518     +          %let classvars = &classvars &var;
37519     +          %let qclassvars = &qclassvars "&var";
37520     +          %let obs = %sysfunc(fetch(&dsid));
37521     +        %end;
37522     +      %end;
37523     +      %if &dsid  %then %let dsid = %sysfunc(close(&dsid));
37524     +*/
37525     +    %end;
37526     +    %else %do;
37527     +      %if %sysfunc(exist(_intmid)) %then %do;
37528     +         proc delete data=_intmid;
37529     +         run;
37530     +      %end;
37532     +      %if %sysfunc(exist(_discretemid)) %then %do;
37533     +         proc delete data=_discretemid;
37534     +         run;
37535     +      %end;
37536     +    %end;
37538     +    /* if import grouping then remove interval vars in import data from _INTMID */
37539     +    %if &useImport eq 1 %then %do;
37541     +      proc sort data=&EM_USER_IMPORTSUBSET out=tempsubset nodupkey;
37542     +        by _VARIABLE_;
37543     +      run;
37545     +      data &EM_USER_IMPORTSUBSET;
37546     +        length CODEVAR $32;
37547     +        set &EM_USER_IMPORTSUBSET;
37548     +        if CODEVAR eq '' then CODEVAR=_VARIABLE_;
37549     +      run;
37551     +      proc sort data=&EM_USER_IMPORTSUBSET out=tempsubset nodupkey;
37552     +        by _VARIABLE_;
37553     +      run;
37555     +      %let dsid = %sysfunc(open(work.tempsubset));
37556     +      %let nobs = 0;
37557     +      %if &dsid %then %do;
37558     +        %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
37559     +      %end;
37560     +      %if &dsid %then %let dsid=%sysfunc(close(&dsid));
37562     +      data tempsubset;
37563     +        set tempsubset;
37564     +        length  binVar suffix $32;
37565     +        array binnames{&nobs} $32 _temporary_;
37566     +        retain binVar binnames;
37567     +        by _VARIABLE_;
37569     +        binVar = 'BIN_'!!strip(CODEVAR);
37570     +        binVar = ksubstr(binVar, 1, 32);
37571     +        count = 1;
37573     +        do i=1 to _N_;
37574     +           do while(binvar eq binnames(i));
37575     +              suffix = strip(put(count,best.));
37576     +              binvar = ksubstr(binvar, 1, 32-klength(suffix))!!suffix;
37577     +              count + 1;
37578     +           end;
37579     +        end;
37580     +        binnames(_N_)= binvar;
37581     +        output;
37582     +        drop suffix count i;
37583     +     run;
37585     +     data &EM_USER_IMPORTSUBSET;
37586     +       set &EM_USER_IMPORTSUBSET;
37587     +       length binVar $32;
37589     +        %let dsid = %sysfunc(open(work.tempsubset));
37590     +        %if &dsid %then %do;
37591     +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
37592     +          %let binnum = %sysfunc(VARNUM(&dsid, binVar));
37593     +          %let obs = %sysfunc(fetch(&dsid));
37595     +          %do %while(&obs=0);
37596     +            %let var = %sysfunc(getvarc(&dsid, &varnuM));
37597     +            %let binvar = %sysfunc(getvarc(&dsid, &binnum));
37599     +            if _variable_ = "&var" and _level_="INTERVAL" then binVar="&binvar";
37600     +            %let obs = %sysfunc(fetch(&dsid));
37601     +          %end;
37602     +        %end;
37603     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
37604     +        /* replace _LEVEL_ to ORDINAL for all binned interval vars; */
37605     +        if binVar ne "" then do;
37606     +          _LEVEL_ = "ORDINAL";
37607     +        end;
37609     +      run;
37611     +      %let idsidexists=0;
37612     +      %let idsid = %sysfunc(open(work._intmid));
37613     +      %if &idsid %then %do;
37614     +        %let idsidexists=1;
37615     +        %let idsid = %sysfunc(close(&idsid));
37616     +      %end;
37618     +      %if &idsidexists = 1 %then %do;
37619     +      data _INTMID;
37620     +        set _INTMID;
37622     +        %let dsid = %sysfunc(open(work.tempsubset));
37623     +        %if &dsid %then %do;
37624     +          %let varnum = %sysfunc(VARNUM(&dsid, CODEVAR));
37625     +          %let obs = %sysfunc(fetch(&dsid));
37627     +          %do %while(&obs=0);
37628     +            %let codevar = %sysfunc(getvarc(&dsid, &varnuM));
37629     +            if variable = "&codevar" then delete;
37630     +            %let obs = %sysfunc(fetch(&dsid));
37631     +          %end;
37632     +        %end;
37633     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
37634     +      run;
37635     +      %end;
37637     +      proc datasets library=work nolist;
37638     +        delete tempsubset;
37639     +      run;
37640     +      quit;
37641     +    %end;
37643     +    /* if freeze then remove interval vars in import data from _INTMID */
37644     +    %if &useFreeze eq 1 %then %do;
37646     +      data &EM_USER_FREEZESUBSET;
37647     +        length CODEVAR $32;
37648     +        set &EM_USER_FREEZESUBSET;
37649     +        if CODEVAR eq '' then CODEVAR=_VARIABLE_;
37650     +      run;
37652     +      proc sort data=&EM_USER_FREEZESUBSET out=tempsubset nodupkey;
37653     +        by _VARIABLE_;
37654     +      run;
37656     +      %let dsid = %sysfunc(open(work.tempsubset));
37657     +      %let nobs = 0;
37658     +      %if &dsid %then %do;
37659     +        %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
37660     +      %end;
37661     +      %if &dsid %then %let dsid=%sysfunc(close(&dsid));
37663     +      data tempsubset;
37664     +        set tempsubset;
37665     +        length  binVar suffix $32;
37666     +        array binnames{&nobs} $32 _temporary_;
37667     +        retain binVar binnames;
37668     +        by _VARIABLE_;
37670     +        binVar = 'BIN_'!!strip(CODEVAR);
37671     +        binVar = ksubstr(binVar, 1, 32);
37672     +        count = 1;
37674     +        do i=1 to _N_;
37675     +           do while(binvar eq binnames(i));
37676     +              suffix = strip(put(count,best.));
37677     +              binvar = ksubstr(binvar, 1, 32-klength(suffix))!!suffix;
37678     +              count + 1;
37679     +           end;
37680     +        end;
37681     +        binnames(_N_)= binvar;
37682     +        output;
37683     +        drop suffix count i;
37684     +     run;
37686     +     data &EM_USER_FREEZESUBSET;
37687     +       set &EM_USER_FREEZESUBSET;
37688     +       length binVar $32;
37690     +        %let dsid = %sysfunc(open(work.tempsubset));
37691     +        %if &dsid %then %do;
37692     +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
37693     +          %let binnum = %sysfunc(VARNUM(&dsid, binVar));
37694     +          %let obs = %sysfunc(fetch(&dsid));
37696     +          %do %while(&obs=0);
37697     +            %let var = %sysfunc(getvarc(&dsid, &varnuM));
37698     +            %let binvar = %sysfunc(getvarc(&dsid, &binnum));
37700     +            if _variable_ = "&var" and _level_="INTERVAL" then binVar="&binvar";
37701     +            %let obs = %sysfunc(fetch(&dsid));
37702     +          %end;
37703     +        %end;
37704     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
37706     +        /* replace _LEVEL_ to ORDINAL for all binned interval vars; */
37707     +        if binVar ne "" then do;
37708     +          _LEVEL_ = "ORDINAL";
37709     +        end;
37711     +      run;
37713     +      %let idsidexists= 0;
37714     +      %let idsid = %sysfunc(open(work._intmid));
37715     +      %if &idsid %then %do;
37716     +        %let idsidexists=1;
37717     +        %let idsid = %sysfunc(close(&idsid));
37718     +      %end;
37719     +      %if &idsidexists eq 1 %then %do;
37720     +      data _INTMID;
37721     +        set _INTMID;
37723     +        %let dsid = %sysfunc(open(work.tempsubset));
37724     +        %if &dsid %then %do;
37725     +          %let varnum = %sysfunc(VARNUM(&dsid, CODEVAR));
37726     +          %let obs = %sysfunc(fetch(&dsid));
37728     +          %do %while(&obs=0);
37729     +            %let codevar = %sysfunc(getvarc(&dsid, &varnuM));
37730     +            if variable = "&codevar" then delete;
37731     +            %let obs = %sysfunc(fetch(&dsid));
37732     +          %end;
37733     +        %end;
37734     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
37735     +      run;
37736     +      %end;
37738     +      proc datasets library=work nolist;
37739     +        delete tempsubset;
37740     +      run;
37741     +      quit;
37743     +    %end;
37745     +%mend EM_PRE_BINNING;
37747     +%macro EM_IMPORT_BINNING(binningCode);
37750     +   data tempintimport;
37751     +     set &EM_USER_IMPORTSUBSET;
37752     +     if binflag = 1;
37753     +   run;
37755     +   %let idsid = %sysfunc(open(work.tempintimport));
37756     +   %if &idsid %then %do;
37757     +     %let nvars = %sysfunc(ATTRN(&idsid, NVARS));
37758     +     %let nobs = %sysfunc(ATTRN(&idsid, NOBS));
37759     +   %end;
37760     +   %else %do;
37761     +     %let nvars = 0;
37762     +     %let nobs = 0;
37763     +   %end;
37764     +   %if &idsid %then %let idsid=%sysfunc(close(&idsid));
37766     +   proc datasets library=work nolist;
37767     +     delete tempintimport;
37768     +   run;
37769     +   quit;
37771     +   %if ((&nobs gt 0) and (&nvars gt 0))%then %do;
37773     +      filename X "&binningCode";
37774     +      data _null_;
37775     +        FILE X MOD;
37776     +        %let bin_variables=;
37777     +        %let quote_bin_variables = ;
37778     +        %let choice = binflag = 1;
37779     +        %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET(where=(&choice))));
37780     +        %if &dsid %then %do;
37781     +           %let namenum = %sysfunc(VARNUM(&dsid, CODEVAR));
37782     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
37783     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
37784     +           %let note = %sysfunc(sasmsg(sashelp.dmine, generatingbins_note , NOQUOTE));
37786     +           put "&EM_CODEBAR;";
37787     +           put " &note; ";
37788     +           put "&EM_CODEBAR;";
37790     +           /* retrieve value for first obs */
37791     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
37792     +           %let oldname = %sysfunc(getvarc(&dsid, &namenum));
37793     +           %let value   = %sysfunc(getvarc(&dsid,  &valnum));
37795     +           %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
37796     +           %let i = 1;
37797     +           %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
37798     +             %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
37799     +           %end;
37800     +           %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
37801     +           put " ";
37802     +           put "if &oldname eq . then &binvalue = .;";
37804     +           /* cycle through special codes if they exist */
37805     +           %let index2 = %index(&oldname, SV_);
37806     +           %if &index2 gt 0 %then %do;
37807     +             %let choice = CODEVAR ="&oldname";
37808     +             %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
37809     +             %if &cdsid %then %do;
37810     +                %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
37811     +                %let cobs = %sysfunc(fetch(&cdsid));
37812     +                %do %while(&cobs=0);
37813     +                   %let code = %sysfunc(getvarc(&cdsid, &codenum));
37814     +                    put "else if &oldname eq &code then &binvalue = &code;";
37815     +                   %let cobs = %sysfunc(fetch(&cdsid));
37816     +                %end;
37817     +             %end;
37818     +             %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
37819     +           %end;
37820     +           put "else ";
37821     +           %if "&value" eq "." %then %do;
37822     +             put " &binvalue=&i;";
37823     +           %end;
37824     +           %else %do;
37825     +             put "  if &oldname < &value then &binvalue=&i;";
37826     +           %end;
37828     +           %let i= %eval(&i+1);
37830     +           %let obs = %sysfunc(fetch(&dsid));
37831     +           %do %while(&obs=0);
37832     +              %let namevalue = %sysfunc(getvarc(&dsid, &namenum));
37833     +              %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
37834     +              %let value    = %sysfunc(getvarc(&dsid,  &valnum));
37836     +              %if "&oldname" ne "&namevalue" %then %do;
37838     +                /* if variable has been re-coded for special codes, must include these values as well */
37839     +                put;
37840     +                put "if &namevalue eq . then &binvalue = .;";
37842     +                %let i=1;
37843     +                %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
37844     +                  %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
37845     +                %end;
37846     +                %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
37848     +                /* cycle through special codes if they exist */
37849     +                %let index2 = %index(&namevalue, SV_);
37850     +                %if &index2 gt 0 %then %do;
37851     +                  %let choice = CODEVAR ="&namevalue";
37852     +                  %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
37853     +                  %if &cdsid %then %do;
37854     +                     %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
37855     +                     %let cobs = %sysfunc(fetch(&cdsid));
37856     +                     %do %while(&cobs=0);
37857     +                       %let code = %sysfunc(getvarc(&cdsid, &codenum));
37858     +                       put "else if &namevalue eq &code then &binvalue = &code;";
37859     +                       %let cobs = %sysfunc(fetch(&cdsid));
37860     +                     %end;
37861     +                  %end;
37862     +                %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
37863     +                %end;
37864     +                put "else ";
37865     +                %if "&value" ne "." %then %do;
37866     +                  put "  if &namevalue < &value then &binvalue=&i;";
37867     +                %end;
37868     +                %else %do;
37869     +                  put " &binvalue=&i;";
37870     +                %end;
37872     +              %end;
37873     +              %else %do;
37874     +                put "else ";
37875     +                %if "&value" ne "." %then %do;
37876     +                  put "  if &namevalue < &value then &binvalue=&i;";
37877     +                %end;
37878     +                %else %do;
37879     +                  put "  &binvalue=&i;";
37880     +                %end;
37881     +              %end;
37882     +              %let i = %eval(&i + 1);
37883     +              %let obs = %sysfunc(fetch(&dsid));
37884     +              %let oldname = &namevalue;
37885     +              %let oldbinvalue = &binvalue;
37886     +           %end;
37887     +        %end;
37888     +        %if &dsid >0 %then %let dsid = %sysfunc(close(&dsid));
37890     +      run;
37891     +      filename X;
37892     +      /* generate BINMAPPINGS dataset */
37893     +      data TEMPBINMAPPINGS;
37894     +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
37896     +        %let choice = binflag = 1;
37897     +        %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET(where=(&choice))));
37898     +        %if &dsid %then %do;
37899     +           %let varnum  = %sysfunc(VARNUM(&dsid, _VARIABLE_));
37900     +           %let codenum = %sysfunc(VARNUM(&dsid, CODEVAR));
37901     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
37902     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
37903     +           %let grpnum  = %sysfunc(VARNUM(&dsid, _group_));
37905     +           /* retrieve information from first obs */
37906     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
37907     +           %let oldvar = %sysfunc(getvarc(&dsid, &varnum));
37908     +           %let oldcodevar = %sysfunc(getvarc(&dsid, &codenum));
37909     +           %let oldbinvar  = %sysfunc(getvarc(&dsid, &binnum));
37910     +           %let oldgrpvar = GRP_%sysfunc(ksubstr(&oldbinvar,5));
37911     +           %let oldvalue   = %sysfunc(getvarc(&dsid, &valnum));
37912     +           %let oldgrpvalue = %sysfunc(getvarn(&dsid, &grpnum));
37913     +           %let i = 1;
37915     +           NAME = "&OLDCODEVAR";
37916     +           BIN_NAME = "&OLDBINVAR";
37917     +           GRP_NAME = "&OLDGRPVAR";
37918     +           BIN = "&i";
37919     +           GRP = "&oldgrpvalue";
37920     +           LB = . ;
37921     +           UB = &oldvalue;
37922     +           EM_BIN_LABEL = "&oldvar < &oldvalue" ;
37923     +           DISPLAY_VAR = "&oldvar";
37924     +           output;
37926     +           %let i = 2;
37927     +           %let obs = %sysfunc(fetch(&dsid));
37928     +           %do %while(&obs=0);
37929     +             %let var = %sysfunc(getvarc(&dsid, &varnum));
37930     +             %let codevar = %sysfunc(getvarc(&dsid, &codenum));
37931     +             %let binvar  = %sysfunc(getvarc(&dsid, &binnum));
37932     +             %let grpvar = GRP_%sysfunc(ksubstr(&binvar,5));
37933     +             %let value   = %sysfunc(getvarc(&dsid, &valnum));
37934     +             %let group   = %sysfunc(getvarn(&dsid, &grpnum));
37936     +             %if "&oldvar" ne "&var" %then %do;
37937     +              %let i = 1;
37938     +               %let oldvalue = .;
37939     +             %end;
37941     +             NAME = "&CODEVAR";
37942     +             BIN_NAME = "&BINVAR";
37943     +             GRP_NAME = "&GRPVAR";
37944     +             BIN = "&i";
37945     +             GRP = "&group";
37946     +             LB = &oldvalue ;
37947     +             UB = &value;
37948     +             %if "&oldvalue" ne "." AND "&value" ne "." %then %do;
37949     +               EM_BIN_LABEL = "&oldvalue <= &var < &value" ;
37950     +             %end;
37951     +             %else %do;
37952     +               %if "&oldvalue" eq "." %then %do;
37953     +                 EM_BIN_LABEL = "&var < &value" ;
37954     +               %end;
37955     +               %if "&value" eq "." %then %do;
37956     +                 EM_BIN_LABEL = "&oldvalue <= &var";
37957     +               %end;
37958     +             %end;
37959     +             DISPLAY_VAR = "&var";
37960     +             output;
37962     +             %let oldvar = &var;
37963     +             %let oldcodevar = &codevar;
37964     +             %let oldbinvar = &binvar;
37965     +             %let oldgrpvar = &grpvar;
37966     +             %let oldvalue   = &value;
37967     +             %let oldgrpvalue   = &group;
37968     +             %let i = %eval(&i + 1);
37969     +             %let obs = %sysfunc(fetch(&dsid));
37970     +           %end;
37971     +        %end;
37972     +        %if &dsid %then %let dsid=%sysfunc(close(&dsid));
37973     +      run;
37975     +      data &EM_USER_BINMAPPINGS;
37976     +        set &EM_USER_BINMAPPINGS tempBinMappings;
37977     +        if NAME = "" and BIN_NAME = "" and BIN= "" then delete;
37978     +      run;
37980     +      /* update importsubset with bin values instead of raw values */
37981     +      data &EM_USER_IMPORTSUBSET;
37982     +        set &EM_USER_IMPORTSUBSET;
37984     +        %let dsid = %sysfunc(open(&EM_USER_BINMAPPINGS));
37985     +        %if &dsid %then %do;
37986     +          %let binvarnum = %sysfunc(VARNUM(&dsid, BIN_NAME));
37987     +         %let displaynum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
37988     +          %let binnum    = %sysfunc(VARNUM(&dsid, BIN));
37989     +          %let codenum   = %sysfunc(VARNUM(&dsid, NAME));
37990     +          %let ubnum     = %sysfunc(VARNUM(&dsid, UB));
37991     +          %let lbnum     = %sysfunc(VARNUM(&dsid, LB));
37993     +          %let oldvar = ;
37994     +          %let obs = %sysfunc(fetch(&dsid));
37995     +          %do %while(&obs=0);
37996     +            %let binvar = %sysfunc(getvarc(&dsid, &binvarnum));
37997     +            %let codevar = %sysfunc(getvarc(&dsid, &codenum));
37998     +            %let displayvar = %sysfunc(getvarc(&dsid, &displaynum));
37999     +            %let bin    = %sysfunc(getvarc(&dsid, &binnum));
38000     +            %let ub     = %sysfunc(getvarn(&dsid, &ubnum));
38001     +            %let lb     = %sysfunc(getvarn(&dsid, &lbnum));
38003     +            %if "&oldvar" eq "&displayvar" %then %do;
38004     +              else
38005     +            %end;
38006     +            if BinVar = "&binvar" and _SPLIT_VALUE_ = "&UB" then do;
38007     +               _SPLIT_VALUE_ = "&bin";
38008     +            end;
38009     +            %let oldvar = &displayvar;
38010     +            %let obs = %sysfunc(fetch(&dsid));
38011     +          %end;
38012     +        %end;
38013     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
38014     +      run;
38016     +      proc sort data=&EM_USER_IMPORTSUBSET;
38017     +        by _VARIABLE_ _SPLIT_VALUE_;
38018     +      run;
38020     +      proc datasets library=work nolist;
38021     +        delete tempBinMappings;
38022     +      run;
38023     +      quit;
38024     +  %end;
38025     +%mend EM_IMPORT_BINNING;
38027     +%macro EM_FREEZE_BINNING(binningCode);
38029     +   data tempintfreeze;
38030     +     set &EM_USER_FREEZESUBSET;
38031     +     if binflag = 1;
38032     +   run;
38034     +   %let idsid = %sysfunc(open(work.tempintfreeze));
38035     +   %if &idsid %then %do;
38036     +     %let nvars = %sysfunc(ATTRN(&idsid, NVARS));
38037     +     %let nobs = %sysfunc(ATTRN(&idsid, NOBS));
38038     +   %end;
38039     +   %else %do;
38040     +     %let nvars = 0;
38041     +     %let nobs = 0;
38042     +   %end;
38043     +   %if &idsid %then %let idsid=%sysfunc(close(&idsid));
38045     +   proc datasets library=work nolist;
38046     +     delete tempintimport;
38047     +   run;
38048     +   quit;
38050     +   %if ((&nobs gt 0) and (&nvars gt 0))%then %do;
38052     +      filename X "&binningCode";
38053     +      data _null_;
38054     +        FILE X MOD;
38056     +        %let bin_variables=.;
38057     +        %let quote_bin_variables=.;
38058     +        %let freeze_variables=;
38059     +        %let choice = binflag = 1;
38060     +        %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET(where=(&choice))));
38061     +        %if &dsid %then %do;
38062     +           %let namenum = %sysfunc(VARNUM(&dsid, CODEVAR));
38063     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
38064     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
38065     +           %let vnum    = %sysfunc(VARNUM(&dsid, _variable_));
38067     +           %let note = %sysfunc(sasmsg(sashelp.dmine, generatingfrozenbins_note , NOQUOTE));
38068     +           put "&EM_CODEBAR;";
38069     +           put "&note;";
38070     +           put "&EM_CODEBAR;";
38072     +           /* retrieve value for first obs */
38073     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
38074     +           %let oldname = %sysfunc(getvarc(&dsid, &namenum));
38075     +           %let value   = %sysfunc(getvarc(&dsid,  &valnum));
38076     +           %let variable = %sysfunc(getvarc(&dsid, &vnum));
38078     +           %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
38079     +           %let i = 1;
38080     +           %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
38081     +             %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
38082     +           %end;
38083     +           %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
38084     +           %let FREEZE_VARIABLES = &FREEZE_VARIABLES "&variable";
38086     +           put " ";
38087     +           put "if &oldname eq . then &binvalue = .;";
38089     +           /* cycle through special codes if they exist */
38090     +           %let index2 = %index(&oldname, SV_);
38091     +           %if &index2 gt 0 %then %do;
38092     +             %let choice = CODEVAR ="&oldname";
38093     +             %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
38094     +             %if &cdsid %then %do;
38095     +                %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
38096     +                %let cobs = %sysfunc(fetch(&cdsid));
38097     +                %do %while(&cobs=0);
38098     +                   %let code = %sysfunc(getvarc(&cdsid, &codenum));
38099     +                    put "else if &oldname eq &code then &binvalue = &code;";
38100     +                   %let cobs = %sysfunc(fetch(&cdsid));
38101     +                %end;
38102     +             %end;
38103     +             %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
38104     +           %end;
38105     +           put "else ";
38106     +           %if "&value" eq "." %then %do;
38107     +             put " &binvalue=&i;";
38108     +           %end;
38109     +           %else %do;
38110     +             put "  if &oldname < &value then &binvalue=&i;";
38111     +           %end;
38113     +           %let i= %eval(&i+1);
38115     +           %let obs = %sysfunc(fetch(&dsid));
38116     +           %do %while(&obs=0);
38117     +              %let namevalue = %sysfunc(getvarc(&dsid, &namenum));
38118     +              %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
38119     +              %let value    = %sysfunc(getvarc(&dsid,  &valnum));
38120     +              %let variable = %sysfunc(getvarc(&dsid, &vnum));
38122     +              %if "&oldname" ne "&namevalue" %then %do;
38124     +                /* if variable has been re-coded for special codes, must include these values as well */
38125     +                put;
38126     +                put "if &namevalue eq . then &binvalue = .;";
38128     +                %let i=1;
38129     +                %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
38130     +                  %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
38131     +                %end;
38132     +                %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
38133     +                %let FREEZE_VARIABLES = &FREEZE_VARIABLES "&variable";
38135     +                /* cycle through special codes if they exist */
38136     +                %let index2 = %index(&namevalue, SV_);
38137     +                %if &index2 gt 0 %then %do;
38138     +                  %let choice = CODEVAR ="&namevalue";
38139     +                  %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
38140     +                  %if &cdsid %then %do;
38141     +                     %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
38142     +                     %let cobs = %sysfunc(fetch(&cdsid));
38143     +                     %do %while(&cobs=0);
38144     +                       %let code = %sysfunc(getvarc(&cdsid, &codenum));
38145     +                       put "else if &namevalue eq &code then &binvalue = &code;";
38146     +                       %let cobs = %sysfunc(fetch(&cdsid));
38147     +                     %end;
38148     +                  %end;
38149     +                %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
38150     +                %end;
38151     +                put "else ";
38152     +                %if "&value" ne "." %then %do;
38153     +                  put "  if &namevalue < &value then &binvalue=&i;";
38154     +                %end;
38155     +                %else %do;
38156     +                  put " &binvalue=&i;";
38157     +                %end;
38159     +              %end;
38160     +              %else %do;
38161     +                put "else ";
38162     +                %if "&value" ne "." %then %do;
38163     +                  put "  if &namevalue < &value then &binvalue=&i;";
38164     +                %end;
38165     +                %else %do;
38166     +                  put " &binvalue=&i;";
38167     +                %end;
38168     +              %end;
38169     +              %let i = %eval(&i + 1);
38170     +              %let obs = %sysfunc(fetch(&dsid));
38171     +              %let oldname = &namevalue;
38172     +              %let oldbinvalue = &binvalue;
38173     +           %end;
38174     +        %end;
38175     +        %if &dsid >0 %then %let dsid = %sysfunc(close(&dsid));
38177     +      run;
38178     +      filename X;
38179     +      /* generate BINMAPPINGS dataset */
38180     +      data TEMPBINMAPPINGS;
38181     +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
38183     +        %let choice = binflag = 1;
38184     +        %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET(where=(&choice))));
38185     +        %if &dsid %then %do;
38186     +           %let varnum  = %sysfunc(VARNUM(&dsid, _VARIABLE_));
38187     +           %let codenum = %sysfunc(VARNUM(&dsid, CODEVAR));
38188     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
38189     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
38190     +           %let grpnum  = %sysfunc(VARNUM(&dsid, _group_));
38192     +           /* retrieve information from first obs */
38193     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
38194     +           %let oldvar = %sysfunc(getvarc(&dsid, &varnum));
38195     +           %let oldcodevar = %sysfunc(getvarc(&dsid, &codenum));
38196     +           %let oldbinvar  = %sysfunc(getvarc(&dsid, &binnum));
38197     +           %let oldgrpvar = GRP_%sysfunc(ksubstr(&oldbinvar, 5));
38198     +           %let oldvalue   = %sysfunc(getvarc(&dsid, &valnum));
38199     +           %let oldgrpvalue = %sysfunc(getvarn(&dsid, &grpnum));
38200     +           %let i = 1;
38202     +           NAME = "&OLDCODEVAR";
38203     +           BIN_NAME = "&OLDBINVAR";
38204     +           GRP_NAME = "&OLDGRPVAR";
38205     +           BIN = "&i";
38206     +           GRP = "&oldgrpvalue";
38207     +           LB = . ;
38208     +           UB = &oldvalue;
38209     +           EM_BIN_LABEL = "&oldvar < &oldvalue" ;
38210     +           DISPLAY_VAR = "&oldvar";
38211     +           output;
38213     +           %let i = 2;
38214     +           %let obs = %sysfunc(fetch(&dsid));
38215     +           %do %while(&obs=0);
38216     +             %let var = %sysfunc(getvarc(&dsid, &varnum));
38217     +             %let codevar = %sysfunc(getvarc(&dsid, &codenum));
38218     +             %let binvar  = %sysfunc(getvarc(&dsid, &binnum));
38219     +             %let grpvar = GRP_%sysfunc(ksubstr(&binvar, 5));
38220     +             %let value   = %sysfunc(getvarc(&dsid, &valnum));
38221     +             %let group   = %sysfunc(getvarn(&dsid, &grpnum));
38223     +             %if "&oldvar" ne "&var" %then %do;
38225     +               %let i = 1;
38226     +               %let oldvalue = .;
38227     +             %end;
38229     +             NAME = "&CODEVAR";
38230     +             BIN_NAME = "&BINVAR";
38231     +             GRP_NAME = "&GRPVAR";
38232     +             BIN = "&i";
38233     +             GRP = "&group";
38234     +             LB = &oldvalue ;
38235     +             UB = &value;
38236     +             %if "&oldvalue" ne "." AND "&value" ne "." %then %do;
38237     +               EM_BIN_LABEL = "&oldvalue <= &var < &value" ;
38238     +             %end;
38239     +             %else %do;
38240     +               %if "&oldvalue" eq "." %then %do;
38241     +                 EM_BIN_LABEL = "&var < &value" ;
38242     +               %end;
38243     +               %if "&value" eq "." %then %do;
38244     +                 EM_BIN_LABEL = "&oldvalue <= &var";
38245     +               %end;
38246     +             %end;
38247     +             DISPLAY_VAR = "&var";
38248     +             output;
38250     +             %let oldvar = &var;
38251     +             %let oldcodevar = &codevar;
38252     +             %let oldbinvar = &binvar;
38253     +             %let oldgrpvar = &grpvar;
38254     +             %let oldvalue   = &value;
38255     +             %let oldgrpvalue = &group;
38256     +             %let i = %eval(&i + 1);
38257     +             %let obs = %sysfunc(fetch(&dsid));
38258     +           %end;
38259     +        %end;
38261     +        %if &dsid %then %let dsid=%sysfunc(close(&dsid));
38262     +      run;
38264     +      /* remove obs from EM_USER_BINMAPPINGS that have vars also in tempBinMappings -- prevents duplicate entries */
38265     +      data &EM_USER_BINMAPPINGS;
38266     +        set &EM_USER_BINMAPPINGS;
38267     +        if NAME in (&FREEZE_VARIABLES) then delete;
38268     +      run;
38270     +      data &EM_USER_BINMAPPINGS;
38271     +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
38273     +        set &EM_USER_BINMAPPINGS tempBinMappings;
38274     +        if NAME = "" and BIN_NAME = "" and BIN= "" then delete;
38275     +      run;
38277     +      /* update freezesubset with bin values instead of raw values */
38278     +      data &EM_USER_FREEZESUBSET;
38279     +        set &EM_USER_FREEZESUBSET;
38281     +        %let dsid = %sysfunc(open(&EM_USER_BINMAPPINGS));
38282     +        %if &dsid %then %do;
38283     +          %let binvarnum = %sysfunc(VARNUM(&dsid, BIN_NAME));
38284     +         %let displaynum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
38285     +          %let binnum    = %sysfunc(VARNUM(&dsid, BIN));
38286     +          %let codenum   = %sysfunc(VARNUM(&dsid, NAME));
38287     +          %let ubnum     = %sysfunc(VARNUM(&dsid, UB));
38288     +          %let lbnum     = %sysfunc(VARNUM(&dsid, LB));
38290     +          %let oldvar = ;
38291     +          %let obs = %sysfunc(fetch(&dsid));
38292     +          %do %while(&obs=0);
38293     +            %let binvar = %sysfunc(getvarc(&dsid, &binvarnum));
38294     +            %let codevar = %sysfunc(getvarc(&dsid, &codenum));
38295     +            %let displayvar = %sysfunc(getvarc(&dsid, &displaynum));
38296     +            %let bin    = %sysfunc(getvarc(&dsid, &binnum));
38297     +            %let ub     = %sysfunc(getvarn(&dsid, &ubnum));
38298     +            %let lb     = %sysfunc(getvarn(&dsid, &lbnum));
38300     +            %if "&oldvar" eq "&displayvar" %then %do;
38301     +              else
38302     +            %end;
38303     +            if BinVar = "&binvar" and _SPLIT_VALUE_ = "&UB" then do;
38304     +               _SPLIT_VALUE_ = "&bin";
38305     +            end;
38306     +            %let oldvar =&displayvar;
38307     +            %let obs = %sysfunc(fetch(&dsid));
38308     +          %end;
38309     +        %end;
38310     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
38311     +      run;
38313     +      proc sort data=&EM_USER_FREEZESUBSET;
38314     +        by _VARIABLE_ _SPLIT_VALUE_;
38315     +      run;
38317     +      proc datasets library=work nolist;
38318     +        delete tempBinMappings;
38319     +      run;
38320     +      quit;
38321     +   %end;
38322     +%mend EM_FREEZE_BINNING;
38324     +%macro EM_EQUAL_SPACED_BINNING(input, bindata, binningCode);
38327     +/* initialize new bucket_binning macro */
38328     +filename temp catalog 'sashelp.emapps.bucket_binning.source';
38329     +%include temp;
38330     +filename temp;
38332     +/* create fileref for generation of binningCode */
38333     +filename X "&binningCode";
38335     +/* determine if there are inputs to be binned */
38336     +%let numbinvars = 0;
38337     +%let intdsid = %sysfunc(open(work._intmid));
38338     +%if &intdsid %then %do;
38339     +  %let numbinvars = %sysfunc(ATTRN(&intdsid, NOBS));
38340     +%end;
38341     +%if &intdsid ne %then %let intdsid = %sysfunc(close(&intdsid));
38342     +%if &numbinvars > 0 %then %do;
38345     +/* get data in format needed for quantile_binning macro */
38346     +data work.vartable;
38347     +  set work._intmid;
38348     +  level = "INTERVAL";
38349     +  role  = "INPUT";
38350     +  rename variable=name;
38351     +run;
38353     +/* if freq var exists, add this to vartable so it will be processed by quantile_binning */
38354     +%if %EM_FREQ ne %then %do;
38355     +   data work.freq;
38356     +     name="%EM_FREQ";
38357     +     role="FREQ";
38358     +   run;
38360     +   data work.vartable;
38361     +     set work.vartable work.freq;
38362     +   run;
38363     +%end;
38365     +/* perform bucket binning of data */
38366     +%let precision =  1 / %sysevalf(10**&EM_PROPERTY_PRECISION);
38367     +%em_apps_bucket_binning( &input, work.vartable, &EM_PROPERTY_NUMBINS, &EM_USER_BINMAPPINGS, X, precision=&precision, dropOriginal=Y);
38369     +proc sort data=&EM_USER_BINMAPPINGS; by name lb; run;
38370     +%end;
38371     +%else %do;
38372     +  /* initialize binmappings table */
38373     +  data &EM_USER_BINMAPPINGS;
38374     +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
38375     +  run;
38377     +  data _null_;
38378     +    FILE X;
38380     +    put "&EM_CODEBAR;";
38381     +    %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
38382     +    put "* &note;";
38383     +    put "&EM_CODEBAR;";
38384     +  run;
38386     +%end;
38388     +/* assign display_var values to binmappings table as well as initial group values */
38389     +data &EM_USER_BINMAPPINGS;
38390     +  set &EM_USER_BINMAPPINGS;
38391     +  length display_var $32 grp $8;
38392     +  display_var = name;
38394     +  %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
38395     +    GRP = BIN + 1;
38396     +  %end;
38397     +  %else %do;
38398     +    GRP = BIN;
38399     +  %end;
38400     +run;
38402     +/* de-assign fileref */
38403     +filename X;
38405     +    /* append to binning code those values that were included in the importSubset data */
38406     +    %if &useImport eq 1 %then %do;
38407     +      %EM_IMPORT_BINNING(&binningcode);
38408     +    %end;
38410     +    /* append to binning code those values that were included in the freezeSubset data */
38411     +    %if &useFreeze eq 1 %then %do;
38412     +      %EM_FREEZE_BINNING(&binningcode);
38413     +    %end;
38415     +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
38416     +     by NAME;
38417     +     run;
38419     +     /* create grouping for missing level */
38420     +    data tempmissvalues;
38421     +    run;
38423     +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
38425     +       %if ((&useImport eq 0) OR (&useFreeze eq 0)) %then %do;
38426     +          data tempmissvalues;
38427     +            %if ((&useImport eq 1) OR (&useFreeze eq 1)) %then %do;
38428     +               merge sortedmapping
38429     +              %if &useImport eq 1 %then %do;
38430     +                 &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME))
38431     +              %end;
38432     +              %if &useFreeze eq 1 %then %do;
38433     +                &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME))
38434     +              %end;
38435     +              ;
38436     +              by NAME;
38437     +            %end;
38438     +            %else %do;
38439     +              set sortedmapping;
38440     +            %end;
38441     +            GRP="1";
38442     +            bin="Missing";
38443     +            _split_value_ = "Missing";
38444     +            %if &useImport eq 1 %then %do;
38445     +               if _a then delete;
38446     +            %end;
38447     +            %if &useFreeze eq 1 %then %do;
38448     +               if _b then delete;
38449     +            %end;
38451     +          run;
38452     +      %end;
38453     +      %else %do; /* both 1 */
38454     +         data tempmissvalues1;
38455     +            merge sortedmapping &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME));
38456     +            by NAME;
38457     +            if _a then delete;
38458     +         run;
38460     +         data tempmissvalues;
38461     +            merge tempmissvalues1 &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME));
38462     +            by NAME;
38463     +            GRP="1";
38464     +            bin="Missing";
38465     +            _split_value_ = "Missing";
38466     +            if _b then delete;
38467     +          run;
38469     +          proc delete data=tempmissvalues1;
38470     +          run;
38471     +      %end;
38472     +    %end;
38474     +    /* create binData from binningCode */
38475     +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
38476     +      by NAME;
38477     +    run;
38479     +    filename X "&binningCode";
38480     +    data &bindata;
38481     +      set &input;
38482     +      %inc X;
38483     +    run;
38485     +    filename X;
38487     +    /* create splitvals dataset */
38488     +    data tempsplitvals;
38489     +      set &EM_USER_BINMAPPINGS
38490     +        %let tdsid = %sysfunc(open(work.tempmissvalues));
38491     +        %if &tdsid %then %do;
38492     +          tempmissvalues
38493     +        %end;
38494     +        %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
38495     +      ;
38496     +      length newgroup _group_ 8 _level_ $8;
38497     +      newgroup =.;
38498     +      _LEVEL_ = 'ORDINAL';
38499     +      _Group_ = grp;
38500     +      rename NAME=DISPLAY_VAR BIN=_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
38501     +      keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_;
38502     +    run;
38504     +    data tempsplitvals;
38505     +      set tempsplitvals;
38506     +      _order_ = _N_;
38507     +    run;
38509     +    /* determine if EM_USER_SPLITVALS already exists */
38510     +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
38511     +    %if &sdsid > 0 %then %do;
38512     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
38513     +      %if &nvars > 0 %then %do;
38514     +        proc sql;
38515     +          reset noprint;
38516     +          select count(*) into :nobs from &EM_USER_SPLITVALS;
38517     +        quit;
38518     +      %end;
38519     +      %else %let nobs=0;
38520     +    %end;
38521     +    %else %do;
38522     +       %let nobs=0;
38523     +       %let nvars=0;
38524     +    %end;
38525     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
38527     +    /* if useIMport=1 also include import definitions here as well */
38528     +    %if &useImport eq 1 %then %do;
38529     +      data tempImport;
38530     +        set &EM_USER_IMPORTSUBSET;
38531     +        _variable_ = binVar;
38532     +      run;
38533     +    %end;
38535     +    /* if useFreeze=1 also include import definitions here as well */
38536     +    %if &useFreeze eq 1 %then %do;
38537     +      data tempFreeze;
38538     +        length display_var $32;
38539     +        set &EM_USER_FREEZESUBSET;
38540     +        display_var = _variable_;
38541     +        _variable_ = binVar;
38542     +      run;
38543     +    %end;
38546     +    data &EM_USER_SPLITVALS;
38547     +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
38548     +        set &EM_USER_SPLITVALS tempsplitvals
38549     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
38550     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
38551     +        %end;
38552     +        %if &useFreeze eq 1 %then %do;
38553     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
38554     +        %end;
38555     +        ;
38556     +      %end;
38557     +      %else %do;
38558     +        set tempsplitvals
38559     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
38560     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
38561     +        %end;
38562     +        %if &useFreeze eq 1 %then %do;
38563     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
38564     +        %end;
38565     +        ;
38566     +      %end;
38567     +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _ORDER_;
38568     +    run;
38570     +    /* create temporary mapping dataset of normalized and non-normalized values for char variables*/
38571     +    data tempvariableset;
38572     +      set &EM_DATA_VARIABLESET;
38573     +      where TYPE = 'C';
38574     +    run;
38576     +    /* add all interval vars that aren't special codes to the intervalvar macro
38577     +    %let dsid = %sysfunc(open(work.tempvariableset));
38578     +    %if &dsid %then %do;
38579     +      %let varnum = %sysfunc(VARNUM(&dsid, NAME));
38580     +      %let obs = %sysfunc(fetch(&dsid));
38581     +      %do %while(&obs=0);
38582     +        %let varname = %sysfunc(getvarc(&dsid, &varnum));
38583     +        %let classvars = &classvars &varname;
38584     +        %let qclassvars = &qclassvars "&varname";
38585     +        %let obs = %sysfunc(fetch(&dsid));
38586     +      %end;
38587     +    %end;
38588     +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
38589     +    */
38590     +   %em_varmacro(name=classvars, metadata=tempvariableset, key=NAME, nummacro=num_classvars);
38592     +    %if %classvars ne %then %do;
38593     +      proc dmdb data =&bindata classout=_classout nonorm;
38594     +        class %classvars;
38595     +      run;
38597     +      proc dmdb data=&bindata classout=_classout2;
38598     +       class %classvars;
38599     +      run;
38601     +      proc sort data=_classout; by NAME CRAW; run;
38602     +      proc sort data=_classout2; by NAME CRAW; run;
38604     +      data _classout;
38605     +        length _variable_ $32;
38606     +        merge _classout _classout2 (rename=(LEVEL=_split_value_));
38607     +        _split_value_ = trim(left(_split_value_));
38608     +        LEVEL = trim(left(LEVEL));
38609     +        by NAME CRAW;
38610     +       _variable_ = NAME;
38611     +      run;
38613     +      proc sort data=_classout; by _variable_ _split_value_; run;
38614     +      proc sort data=&EM_USER_SPLITVALS; by _variable_ _split_value_; run;
38616     +      data &EM_USER_SPLITVALS;
38617     +        length _norm_level_ $200 _split_value_ $200;
38618     +        merge &EM_USER_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
38619     +        by _variable_ _split_value_;
38620     +        LEVEL = trim(left(LEVEL));
38621     +        _norm_level_ = trim(left(_norm_level_));
38622     +        _split_value_ = trim(left(_split_value_));
38623     +        if _norm_level_ eq '' then _norm_level_= _split_value_;
38624     +        drop NAME FREQUENCY TYPE CRAW NRAW;
38625     +      run;
38627     +      proc datasets library=work nolist;
38628     +        delete _classout _classout2;
38629     +      run;
38630     +      quit;
38631     +    %end;
38632     +    data &EM_USER_SPLITVALS;
38633     +      set &EM_USER_SPLITVALS;
38634     +      if _norm_level_ eq '' then _norm_level_= _split_value_;
38635     +    run;
38637     +    proc sort data=&EM_USER_SPLITVALS;
38638     +      by DISPLAY_VAR _Group_;
38639     +    run;
38641     +   proc datasets library=work nolist;
38642     +     delete tempBinMappings temp_binmappings tempBinNames tempsplitvals sortedmapping tempmissvalues
38643     +      %if &useImport eq 1 %then %do;
38644     +        tempImport
38645     +      %end;
38646     +      %if &useFreeze eq 1 %then %do;
38647     +        tempFreeze
38648     +      %end;
38649     +     ;
38650     +   run;
38651     +   quit;
38653     +%mend;
38655     +%macro EM_QUANTILE_BINNING(input, pctdata, bindata, binningCode);
38657     +/* initialize new quantile_binning macro */
38658     +filename temp catalog 'sashelp.emapps.quantile_binning.source';
38659     +%include temp;
38660     +filename temp;
38662     +/* generate fileref for quantile_binning macro */
38663     +filename X "&binningCode";
38665     +/* determine if there are inputs to be binned */
38666     +%let numbinvars = 0;
38667     +%let intdsid = %sysfunc(open(work._intmid));
38668     +%if &intdsid %then %do;
38669     +  %let numbinvars = %sysfunc(ATTRN(&intdsid, NOBS));
38670     +%end;
38671     +%if &intdsid ne %then %let intdsid = %sysfunc(close(&intdsid));
38672     +%if &numbinvars > 0 %then %do;
38674     +/* get data in format needed for quantile_binning macro */
38675     +data work.vartable;
38676     +  set work._intmid;
38677     +  level = "INTERVAL";
38678     +  role  = "INPUT";
38679     +  rename variable=name;
38680     +run;
38682     +/* if freq var exists, add this to vartable so it will be processed by quantile_binning */
38683     +%if %EM_FREQ ne %then %do;
38684     +   data work.freq;
38685     +     name="%EM_FREQ";
38686     +     role="FREQ";
38687     +   run;
38689     +   data work.vartable;
38690     +     set work.vartable work.freq;
38691     +   run;
38692     +%end;
38695     +/* perform quantile binning of data */
38696     +%let precision =  1 / %sysevalf(10**&EM_PROPERTY_PRECISION);
38697     +%em_apps_quantile_binning( &input, work.vartable, &EM_PROPERTY_NUMBINS, &EM_USER_BINMAPPINGS, X, precision=&precision, dropOriginal=Y);
38699     +proc sort data=&EM_USER_BINMAPPINGS; by name lb; run;
38700     +%end;
38701     +%else %do;
38702     +  /* initialize binmappings table */
38703     +  data &EM_USER_BINMAPPINGS;
38704     +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
38705     +  run;
38707     +  data _null_;
38708     +    FILE X;
38710     +    put "&EM_CODEBAR;";
38711     +    %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
38712     +    put "* &note;";
38713     +    put "&EM_CODEBAR;";
38714     +  run;
38716     +%end;
38718     +/* assign display_var values to binmappings table as well as initial group values */
38719     +data &EM_USER_BINMAPPINGS;
38720     +  set &EM_USER_BINMAPPINGS;
38721     +  length display_var $32 grp $8;
38722     +  display_var = name;
38724     +  %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
38725     +    GRP = BIN + 1;
38726     +  %end;
38727     +  %else %do;
38728     +    GRP = BIN;
38729     +  %end;
38730     +run;
38732     +/* de-assign fileref */
38733     +filename X;
38735     +    /* append to binning code those values that were included in the importSubset data */
38736     +    %if &useImport eq 1 %then %do;
38737     +      %EM_IMPORT_BINNING(&binningcode);
38738     +    %end;
38740     +    /* append to binning code those values that were included in the freezeSubset data */
38741     +    %if &useFreeze eq 1 %then %do;
38742     +      %EM_FREEZE_BINNING(&binningcode);
38743     +    %end;
38745     +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
38746     +      by NAME;
38747     +    run;
38749     +    /* create grouping for missing level */
38750     +    data tempmissvalues;
38751     +    run;
38753     +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
38755     +       %if ((&useImport eq 0) OR (&useFreeze eq 0)) %then %do;
38756     +             data tempmissvalues;
38757     +               %if ((&useImport eq 1) OR (&useFreeze eq 1)) %then %do;
38758     +                  merge sortedmapping
38759     +                 %if &useImport eq 1 %then %do;
38760     +                    &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME))
38761     +                 %end;
38762     +                 %if &useFreeze eq 1 %then %do;
38763     +                   &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME))
38764     +                 %end;
38765     +                 ;
38766     +                 by NAME;
38767     +               %end;
38768     +               %else %do;
38769     +                 set sortedmapping;
38770     +               %end;
38771     +               GRP="1";
38772     +               bin="Missing";
38773     +               _split_value_ = "Missing";
38774     +               %if &useImport eq 1 %then %do;
38775     +                  if _a then delete;
38776     +               %end;
38777     +               %if &useFreeze eq 1 %then %do;
38778     +                  if _b then delete;
38779     +               %end;
38781     +             run;
38782     +         %end;
38783     +         %else %do; /* both 1 */
38784     +            data tempmissvalues1;
38785     +               merge sortedmapping &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME));
38786     +               by NAME;
38787     +               if _a then delete;
38788     +            run;
38790     +            data tempmissvalues;
38791     +               merge tempmissvalues1 &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME));
38792     +               by NAME;
38793     +               GRP="1";
38794     +               bin="Missing";
38795     +               _split_value_ = "Missing";
38796     +               if _b then delete;
38797     +             run;
38799     +             proc delete data=tempmissvalues1;
38800     +             run;
38801     +         %end;
38802     +     %end;
38804     +    /* create binData from binningCode */
38805     +    filename X "&binningCode";
38807     +    data &bindata;
38808     +      set &input;
38809     +      %inc X;
38810     +    run;
38812     +    filename X;
38814     +    /* create splitvals dataset */
38815     +    data tempsplitvals;
38816     +      set &EM_USER_BINMAPPINGS tempmissvalues;
38817     +      length newgroup _group_ _order_ 8 _level_ $8;
38818     +      newgroup =.;
38819     +      _LEVEL_ = 'ORDINAL';
38820     +      _Group_ = grp;
38821     +      rename NAME=DISPLAY_VAR BIN =_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
38822     +      keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_ _ORDER_;
38823     +    run;
38825     +    data tempsplitvals;
38826     +      set tempsplitvals;
38827     +      _order_ = _N_;
38828     +    run;
38830     +    /* determine if EM_USER_SPLITVALS already exists */
38831     +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
38832     +    %if &sdsid > 0 %then %do;
38833     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
38834     +      %if &nvars > 0 %then %do;
38835     +        proc sql;
38836     +          reset noprint;
38837     +          select count(*) into :nobs from &EM_USER_SPLITVALS;
38838     +        quit;
38839     +      %end;
38840     +      %else %let nobs=0;
38841     +    %end;
38842     +    %else %do;
38843     +       %let nobs=0;
38844     +       %let nvars=0;
38845     +    %end;
38846     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
38848     +    /* if useIMport=1 also include import definitions here as well */
38849     +    %if &useImport eq 1 %then %do;
38850     +      data tempImport;
38851     +        set &EM_USER_IMPORTSUBSET;
38852     +        _variable_ = binVar;
38853     +      run;
38854     +    %end;
38856     +    /* if useFreeze=1 also include frozen definitions here as well */
38857     +    %if &useFreeze eq 1 %then %do;
38858     +      data tempFreeze;
38859     +        length display_var $32;
38860     +        set &EM_USER_FreezeSUBSET;
38861     +        display_var = _variable_;
38862     +        _variable_ = binVar;
38863     +      run;
38864     +    %end;
38866     +    data &EM_USER_SPLITVALS;
38867     +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
38868     +        set &EM_USER_SPLITVALS tempsplitvals
38869     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
38870     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
38871     +        %end;
38872     +        %if &useFreeze eq 1 %then %do;
38873     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
38874     +        %end;
38875     +        ;
38876     +      %end;
38877     +      %else %do;
38878     +        set tempsplitvals
38879     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
38880     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
38881     +        %end;
38882     +        %if &useFreeze eq 1 %then %do;
38883     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
38884     +        %end;
38885     +        ;
38886     +      %end;
38887     +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _order_;
38888     +    run;
38890     +    /* create temporary mapping dataset of normalized and non-normalized values for char variables*/
38891     +    data tempvariableset;
38892     +      set &EM_DATA_VARIABLESET;
38893     +      where LEVEL ^= 'INTERVAL' and TYPE = 'C' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
38894     +    run;
38896     +   %em_varmacro(name=classvars, metadata=tempvariableset, key=NAME, nummacro=num_classvars);
38898     +    /* add all interval vars that aren't special codes to the intervalvar macro
38899     +    %let dsid = %sysfunc(open(work.tempvariableset));
38900     +    %if &dsid %then %do;
38901     +      %let varnum = %sysfunc(VARNUM(&dsid, NAME));
38902     +      %let obs = %sysfunc(fetch(&dsid));
38903     +      %do %while(&obs=0);
38904     +        %let varname = %sysfunc(getvarc(&dsid, &varnum));
38905     +        %let classvars = &classvars &varname;
38906     +        %let qclassvars = &qclassvars "&varname";
38907     +        %let obs = %sysfunc(fetch(&dsid));
38908     +      %end;
38909     +    %end;
38910     +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
38911     +*/
38912     +    %if %classvars ne %then %do;
38913     +      proc dmdb data =&bindata classout=_classout nonorm;
38914     +        class %classvars;
38915     +      run;
38917     +      proc dmdb data=&bindata classout=_classout2;
38918     +       class %classvars;
38919     +      run;
38921     +      proc sort data=_classout; by NAME CRAW; run;
38922     +      proc sort data=_classout2; by NAME CRAW; run;
38924     +      data _classout;
38925     +        length _variable_ $32;
38926     +        merge _classout _classout2 (rename=(LEVEL=_split_value_));
38927     +        by NAME CRAW;
38928     +       _variable_ = NAME;
38929     +      run;
38931     +      proc sort data=_classout; by _variable_ _split_value_; run;
38932     +      proc sort data=&EM_USER_SPLITVALS; by _variable_ _split_value_; run;
38934     +      data &EM_USER_SPLITVALS;
38935     +        length _norm_level_ $200 _split_value_ $200;
38936     +        merge &EM_USER_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
38937     +        by _variable_ _split_value_;
38938     +        LEVEL = trim(left(LEVEL));
38939     +        _split_value_ = trim(left(_split_value_));
38940     +        _norm_level_ = trim(left(_norm_level_));
38941     +        if _norm_level_ eq '' then _norm_level_= _split_value_;
38942     +        drop NAME FREQUENCY TYPE CRAW NRAW;
38943     +      run;
38945     +      proc datasets library=work nolist;
38946     +        delete _classout _classout2;
38947     +      run;
38948     +      quit;
38949     +    %end;
38951     +    data &EM_USER_SPLITVALS;
38952     +      set &EM_USER_SPLITVALS;
38953     +      if _norm_level_ eq '' then _norm_level_= _split_value_;
38954     +    run;
38957     +    proc sort data=&EM_USER_SPLITVALS;
38958     +      by DISPLAY_VAR _Group_;
38959     +    run;
38961     +    proc datasets library=work nolist;
38962     +      delete sortedmapping tempsplitvals tempmissvalues
38963     +      %if &useImport eq 1 %then %do;
38964     +        tempImport
38965     +      %end;
38966     +      %if &useFreeze eq 1 %then %do;
38967     +        tempFreeze
38968     +      %end;
38969     +      ;
38970     +    run;
38971     +    quit;
38972     +/*
38973     +%end;
38974     +%else %do;
38975     +    data &bindata;
38976     +      set &input;
38977     +    run;
38978     +%end;
38979     +*/
38980     +%mend EM_QUANTILE_BINNING;
38982     +%macro EM_ORDVARS_GROUP;
38984     +   /* retrieve all ordinal variables from the incoming dataset */
38985     +   proc sort data=&EM_DATA_VARIABLESET out=tempvariableset;
38986     +     by NAME;
38987     +     where LEVEL = 'ORDINAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
38988     +   run;
38990     +   /* add all vars marked as interval that are actually class vars to this data */
38991     +   %let nobs = 0;
38992     +   %let dsid = %sysfunc(open(WORK._DISCRETEMID));
38993     +   %if &dsid %then %do;
38994     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
38995     +     %if &nobs gt 0 %then %do;
38997     +     data tempvars;
38998     +       set &EM_DATA_VARIABLESET;
38999     +       if NAME in (
39000     +         %let obs = %sysfunc(fetch(&dsid));
39001     +         %do %while(&obs=0);
39002     +           %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
39003     +           %let varname = %sysfunc(GETVARC(&dsid, &varnum));
39004     +           "&varname"
39005     +           %let obs = %sysfunc(fetch(&dsid));
39006     +         %end;
39007     +        );
39008     +     run;
39009     +     data tempvariableset;
39010     +       set tempvariableset tempvars;
39011     +     run;
39012     +     %end;
39013     +   %end;
39014     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
39016     +   %if &useImport eq 1 %then %do;
39017     +     /* remove all variables from tempvariableset that are included in the importsubset */
39018     +     proc sort data=&EM_USER_IMPORTSUBSET out=tempimport(rename=(_VARIABLE_ = NAME));
39019     +       by _VARIABLE_ ;
39020     +     run;
39021     +     proc sort data=tempvariableset; by NAME; run;
39023     +     data tempvariableset;
39024     +       merge tempimport(in=_a) tempvariableset(in=_b);
39025     +       by NAME;
39026     +       if ^_a then output;
39027     +     run;
39028     +   %end;
39030     +   %if &useFreeze eq 1 %then %do;
39031     +     /* remove all variables from tempvariableset that are included in the freezesubset */
39032     +     proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze(rename=(_VARIABLE_ = NAME));
39033     +       by _VARIABLE_ ;
39034     +     run;
39035     +     proc sort data=tempvariableset; by NAME; run;
39037     +     data tempvariableset;
39038     +       merge tempfreeze(in=_a) tempvariableset(in=_b);
39039     +       by NAME;
39040     +       if ^_a then output;
39041     +     run;
39042     +   %end;
39044     +   /* get dataset of distinct values for the ordinal variable */
39045     +   %let nobs = 0;
39046     +   %let dsid = %sysfunc(open(WORK.tempvariableset));
39047     +   %if &dsid %then %do;
39048     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
39049     +     %if &nobs gt 0 %then %do;
39050     +         %let obs = %sysfunc(fetch(&dsid));
39051     +         %do %while(&obs=0);
39052     +           %let varnum = %sysfunc(VARNUM(&dsid, NAME));
39053     +           %let varname = %sysfunc(GETVARC(&dsid, &varnum));
39054     +           %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
39055     +           %let input_type = %sysfunc(getvarc(&dsid, &typenum));
39056     +           %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
39057     +           %let input_fmt = %sysfunc(getvarc(&dsid, &fmtnum));
39058     +           %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
39059     +           %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
39060     +           %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
39062     +           data temp;
39063     +             set &EM_USER_BINDATA(keep=&varname);
39064     +             %if &input_fmt ne %then %do;
39065     +               %dmnormcp(put(&varname, &input_fmt), _norm);
39066     +             %end;
39067     +             %else %do;
39068     +               %dmnormcp(&varname, _norm);
39069     +             %end;
39070     +             keep &varname _norm;
39071     +           run;
39073     +          proc dmdb data=temp classout=_classout2;
39074     +           class _norm;
39075     +         run;
39076     +         proc sort data=_classout2; by LEVEL; run;
39078     +         /* re-order numeric inputs based on non-normalized values */
39079     +         %if &input_type eq N %then %do;
39080     +           proc sort data=temp nodupkey; by _norm; run;
39081     +           data varvals;
39082     +             merge temp _classout2(rename=(LEVEL=_norm));
39083     +             by _norm;
39084     +             if craw='' and _norm ne '.' then delete;
39085     +             keep &varname _norm nraw craw;
39086     +           run;
39088     +           proc sort data=varvals; by &varname; run;
39089     +         %end;
39090     +         %else %do;
39091     +           data varvals;
39092     +              set _classout2(rename=(LEVEL=_norm));
39093     +              if _norm='' then delete;
39094     +              if _norm='.' then delete;
39095     +              keep _norm;
39096     +           run;
39097     +         %end;
39098     +         data varvals;
39099     +           set varvals;
39100     +           if &varname="." then delete;
39101     +           if upcase(&varname) = "MISSING" then delete;
39102     +         run;
39104     +          /* generate Splitvals Data */
39105     +          data tempsplitvals;
39106     +            length DISPLAY_VAR _VARIABLE_ $32 _Split_value_ $200 newgroup _group_ _order_ 8 _level_ $8 _norm_level_ $200 ;
39108     +            %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
39109     +              DISPLAY_VAR="&varname";
39110     +              _VARIABLE_ ="&varname";
39111     +              newgroup   =.;
39112     +              _group_    =1;
39113     +              _Split_Value_="Missing";
39114     +              _level_    ="ORDINAL";
39115     +              output;
39116     +              %let group=2;
39117     +            %end;
39118     +            %else %let group=1;
39120     +            %let vdsid = %sysfunc(open(WORK.VARVALS));
39121     +            %if &vdsid %then %do;
39122     +            %let namenum = %sysfunc(VARNUM(&vdsid, _norm));
39123     +            /*%let group = 2;*/
39124     +            %let vobs = %sysfunc(fetch(&vdsid));
39125     +            %do %while(&vobs=0);
39126     +                %let nameval = %bquote(%upcase(%sysfunc(getvarc(&vdsid, &namenum))));
39128     +                DISPLAY_VAR   = "&varname";
39129     +                _variable_    = "&varname";
39130     +                newgroup      = .;
39131     +                _group_       = &group;
39132     +                _split_value_ = "&nameval";
39133     +                _level_       = 'ORDINAL';
39134     +                output;
39136     +              %let group = %eval(&group + 1);
39137     +              %let vobs = %sysfunc(fetch(&vdsid));
39138     +            %end;
39139     +            %if &vdsid %then %let vdsid = %sysfunc(close(&vdsid));
39140     +          run;
39142     +          /* determine if EM_USER_SPLITVALS already exists */
39143     +          %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
39144     +          %if &sdsid > 0 %then %do;
39145     +            %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
39146     +            %if &nvars > 0 %then %do;
39147     +               proc sql;
39148     +                reset noprint;
39149     +                select count(*) into :nobs from &EM_USER_SPLITVALS;
39150     +               quit;
39151     +            %end;
39152     +            %else %let nobs=0;
39153     +            %end;
39154     +            %else %do;
39155     +              %let nobs=0;
39156     +              %let nvars=0;
39157     +            %end;
39158     +          %end;
39159     +          %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
39161     +          /* if tempsplitvals doesn't exist; create empty data set */
39162     +          %let sdsid = %sysfunc(open(work.tempsplitvals));
39163     +          %if &sdsid <= 0 %then %do;
39164     +            data tempsplitvals;
39165     +              length DISPLAY_VAR _VARIABLE_ $32 _Split_value_ $200 newgroup _group_ 8 _level_ $8 ;
39166     +            run;
39167     +          %end;
39168     +          %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
39170     +          data tempsplitvals;
39171     +            set tempsplitvals;
39172     +            _order_ = _N_;
39173     +          run;
39175     +          %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
39176     +             proc sort data = &EM_USER_SPLITVALS; by _variable_ _split_value_; run;
39177     +             proc sort data = tempsplitvals nodupkey; by _variable_ _split_Value_ _group_; run;
39178     +          %end;
39180     +          data &EM_USER_SPLITVALS;
39181     +           %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
39182     +             merge &EM_USER_SPLITVALS tempsplitvals;
39183     +             by _variable_ _split_value_;
39184     +           %end;
39185     +           %else %do;
39186     +             set tempsplitvals;
39187     +           %end;
39188     +           if display_var eq "" then delete;
39189     +           if _norm_level_ eq "" then _norm_level_ = _split_value_;
39190     +           keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_ _order_;
39191     +         run;
39193     +           %let obs = %sysfunc(fetch(&dsid));
39194     +         %end;
39195     +     %end;
39196     +   %end;
39197     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
39199     +   proc sort data=&EM_USER_SPLITVALS;
39200     +      by DISPLAY_VAR _Group_;
39201     +   run;
39203     +   /* delete temporary datasets */
39204     +   proc datasets library= work nolist;
39205     +     delete tempsplitvals varvals tempvariableset tempvars
39206     +     ;
39207     +   run;
39208     +   quit;
39209     +%mend EM_ORDVARS_GROUP;
39212     +%macro EM_CLASSVARS_GROUP(groupRare);
39214     +   /* retrieve all class variables from the incoming dataset */
39215     +   proc sort data=&EM_DATA_VARIABLESET out=tempvariableset;
39216     +     by NAME;
39217     +     where ((LEVEL = 'NOMINAL') OR (LEVEL='BINARY')) and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
39218     +   run;
39220     +   %if &useImport eq 1 %then %do;
39221     +     /* remove all variables from tempvariableset that are included in the importsubset */
39222     +     proc sort data=&EM_USER_IMPORTSUBSET out=tempimport(rename=(_VARIABLE_ = NAME));
39223     +       by _VARIABLE_ ;
39224     +     run;
39225     +     proc sort data=tempvariableset; by NAME; run;
39227     +     data tempvariableset;
39228     +       merge tempimport(in=_a) tempvariableset(in=_b);
39229     +       by NAME;
39230     +       if ^_a then output;
39231     +     run;
39232     +   %end;
39234     +   %if &useFreeze eq 1 %then %do;
39235     +     /* remove all variables from tempvariableset that are included in the freezesubset */
39236     +     proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze(rename=(_VARIABLE_ = NAME));
39237     +       by _VARIABLE_ ;
39238     +     run;
39239     +     proc sort data=tempvariableset; by NAME; run;
39241     +     data tempvariableset;
39242     +       merge tempfreeze(in=_a) tempvariableset(in=_b);
39243     +       by NAME;
39244     +       if ^_a then output;
39245     +     run;
39246     +   %end;
39248     +   /* run dmdb to retrieve list of all class levels and counts */
39249     +   %let dsid = %sysfunc(open(work.tempvariableset));
39250     +   %let nobs = 0;
39251     +   %if &dsid %then %do;
39252     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
39254     +   %end;
39256     +   %if &nobs gt 0 %then %do;
39257     +     proc dmdb data=&EM_IMPORT_DATA classout=tempclassout;
39258     +       class
39260     +        %let namenum = %sysfunc(VARNUM(&dsid, NAME));
39261     +        %let obs = %sysfunc(fetch(&dsid));
39262     +        %do %while(&obs=0);
39263     +           %let name = %sysfunc(getvarc(&dsid, &namenum));
39264     +           &name
39265     +           %let obs = %sysfunc(fetch(&dsid));
39266     +        %end;
39267     +     ;
39269     +     %if %EM_FREQ ne %then %do;
39270     +        freq %EM_FREQ;
39271     +     %end;
39272     +    run;
39273     +   %end;
39274     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
39276     +   %let dsid = %sysfunc(open(work.tempclassout));
39277     +   %let nobs = 0;
39278     +   %if &dsid %then %do;
39279     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
39280     +     %let dsid = %sysfunc(close(&dsid));
39281     +   %end;
39283     +   %if &nobs gt 0 %then %do;
39284     +    data tempclassout;
39285     +       set tempclassout;
39286     +       if LEVEL='MISSING' then level='Missing';
39287     +    run;
39289     +    proc sort data=tempclassout nodupkey;
39290     +      by NAME descending FREQUENCY LEVEL;
39291     +    run;
39293     +    data tempds(keep=NAME NOBS);
39294     +      retain NOBS;
39295     +      set tempclassout;
39296     +      by NAME;
39297     +      if first.NAME then
39298     +        NOBS = frequency;
39299     +      else
39300     +        NOBS=NOBS+frequency;
39301     +      if last.name then do;
39302     +        output;
39303     +      end;
39304     +    run;
39306     +    data tempds;
39307     +      merge tempclassout
39308     +      tempds;
39309     +      by NAME;
39310     +      if ((LEVEL ne '') AND (LEVEL ne "."));
39311     +      %if &groupRare eq Y %then %do;
39312     +        PCT = 100 * (FREQUENCY/NOBS);
39313     +        if PCT < &EM_PROPERTY_GROUPCUTOFF then flag=1;
39314     +        else flag=0;
39315     +      %end;
39316     +      %else %do;
39317     +        flag = 0;
39318     +      %end;
39319     +    run;
39321     +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
39322     +      data tempmissvalues;
39323     +        length NAME $32 LEVEL $200 _LEVEL_ $8 _GROUP_ 8;
39325     +      %let dsid = %sysfunc(open(WORK.TEMPVARIABLESET));
39326     +      %if &dsid %then %do;
39327     +        %let varnum = %sysfunc(VARNUM(&dsid, NAME));
39328     +        %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
39329     +        %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
39330     +        %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
39331     +        %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
39332     +        %let obs = %sysfunc(fetch(&dsid));
39334     +        %do %while(&obs=0);
39335     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
39336     +          %let format = %sysfunc(getvarc(&dsid, &fmtnum));
39337     +          %let type = %sysfunc(getvarc(&dsid, &typenum));
39338     +          %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
39340     +          NAME="&var";
39341     +          LEVEL="Missing";
39342     +          _LEVEL_="&varlvl";
39343     +          _group_ = 1;
39344     +          output;
39346     +          %let obs = %sysfunc(fetch(&dsid));
39347     +        %end;
39348     +      %end;
39349     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
39350     +      run;
39351     +    %end;
39353     +    /* generate Splitvals Data */
39354     +    data tempsplitvals;
39355     +      length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
39357     +      set tempclassout
39358     +      %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
39359     +         tempmissvalues
39360     +      %end;
39361     +      ;
39362     +      if ((level ne '') AND (level ne '.'));
39364     +     %let dsid = %sysfunc(open(WORK.TEMPVARIABLESET));
39365     +     %if &dsid %then %do;
39366     +        %let varnum = %sysfunc(VARNUM(&dsid, NAME));
39367     +        %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
39368     +        %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
39369     +        %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
39370     +        %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
39371     +        %let obs = %sysfunc(fetch(&dsid));
39373     +        %do %while(&obs=0);
39374     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
39375     +          %let format = %sysfunc(getvarc(&dsid, &fmtnum));
39376     +          %let type = %sysfunc(getvarc(&dsid, &typenum));
39377     +          %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
39379     +          if NAME = "&var" then do;
39380     +            _LEVEL_ = "&varlvl";
39382     +          /* cycle through levels, assigning group values;              */
39383     +          /* flag=1 indicates to put value in "_OTHER_" group;          */
39384     +          /* flag=0 indicates that value shoudld be in group of its own */
39385     +          %let choice = ((NAME="&Var") and (FLAG=0));
39386     +          %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
39387     +            %let group=2;
39388     +          %end;
39389     +          %else %do;
39390     +            %let group = 1;
39391     +          %end;
39392     +          %let fdsid = %sysfunc(open(work.tempds(where=(&choice))));
39393     +          %if &fdsid %then %do;
39395     +            %let lvlnum = %sysfunc(VARNUM(&fdsid, LEVEL));
39396     +            %let fobs = %sysfunc(fetch(&Fdsid));
39397     +            %let fflag = 0;
39398     +            %do %while(&fobs=0);
39399     +              %let fflag = 1;
39400     +              %let temp = %nrbquote(%sysfunc(getvarc(&fdsid, &lvlnum)));
39401     +              %let level = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
39402     +              %let level = %nrbquote(%sysfunc(strip(&level)));
39403     +              %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
39404     +                %if &group eq 2 %then %do;
39405     +                   if LEVEL = "&level" then _GROUP_ = &group;
39406     +                %end;
39407     +                %else %do;
39408     +                   else if LEVEL = "&level" then _GROUP_ = &group;
39409     +                %end;
39410     +              %end;
39411     +              %else %do;
39412     +                %if &group eq 1 %then %do;
39413     +                   if LEVEL = "&level" then _GROUP_ = &group;
39414     +                %end;
39415     +                %else %do;
39416     +                   else if LEVEL = "&level" then _GROUP_ = &group;
39417     +                %end;
39418     +              %end;
39420     +              %let group = %eval(&group + 1);
39421     +              %let fobs = %sysfunc(fetch(&fdsid));
39422     +            %end;
39424     +          %end;
39425     +          %if &fflag eq 1 %then %do;
39426     +            else if LEVEL ^='Missing' then _GROUP_ = &group;
39427     +          %end;
39428     +          end;
39430     +          %if &fdsid %then %let fdsid = %sysfunc(close(&fdsid));
39431     +          %let obs = %sysfunc(fetch(&dsid));
39432     +        %end;
39433     +     %end;
39434     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
39435     +     _VARIABLE_ = NAME;
39436     +     newgroup = .;
39437     +     rename NAME = DISPLAY_VAR
39438     +            LEVEL = _SPLIT_VALUE_;
39439     +     keep NAME NEWGROUP _VARIABLE_ LEVEL _LEVEL_ _GROUP_;
39440     +    run;
39441     +  %end;
39442     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
39444     +    /* determine if EM_USER_SPLITVALS already exists */
39445     +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
39446     +    %if &sdsid > 0 %then %do;
39447     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
39448     +      %if &nvars > 0 %then %do;
39449     +        proc sql;
39450     +          reset noprint;
39451     +          select count(*) into :nobs from &EM_USER_SPLITVALS;
39452     +        quit;
39453     +      %end;
39454     +      %else %let nobs=0;
39455     +    %end;
39456     +    %else %do;
39457     +       %let nobs=0;
39458     +       %let nvars=0;
39459     +    %end;
39460     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
39462     +   /* if tempsplitvals doesn't exist; create empty data set */
39463     +    %let sdsid = %sysfunc(open(work.tempsplitvals));
39464     +    %if &sdsid <= 0 %then %do;
39465     +      data tempsplitvals;
39466     +        length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
39467     +      run;
39468     +    %end;
39469     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
39471     +    %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
39472     +      proc sort data = &EM_USER_SPLITVALS; by _variable_ _split_value_; run;
39473     +      proc sort data = tempsplitvals nodupkey; by _variable_ _split_Value_ _group_; run;
39474     +    %end;
39476     +    /* if useIMport=1 also include import definitions here as well */
39477     +    %if &useImport eq 1 %then %do;
39478     +      proc sort data=&EM_USER_IMPORTSUBSET; by _variable_ _split_value_; run;
39479     +    %end;
39480     +    %if &useFreeze eq 1 %then %do;
39481     +      proc sort data=&EM_USER_FREEZESUBSET; by _variable_ _split_value_; run;
39482     +    %end;
39483     +    data &EM_USER_SPLITVALS;
39484     +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
39485     +        merge &EM_USER_SPLITVALS tempsplitvals
39486     +        %if &useImport eq 1 %then %do;
39487     +           &EM_USER_IMPORTSUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
39488     +        %end;
39489     +        %if &useFreeze eq 1 %then %do;
39490     +           &EM_USER_FREEZESUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
39491     +        %end;
39493     +        ;
39494     +        by _variable_ _split_value_
39495     +        ;
39496     +      %end;
39497     +      %else %do;
39498     +        set tempsplitvals
39499     +        %if &useImport eq 1 %then %do;
39500     +           &EM_USER_IMPORTSUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
39501     +        %end;
39502     +        %if &useFreeze eq 1 %then %do;
39503     +           &EM_USER_FREEZESUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
39504     +        %end;
39505     +        ;
39506     +      %end;
39507     +      if display_var eq "" then delete;
39508     +      if _norm_level_ eq "" then _norm_level_ = _split_value_;
39509     +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_;
39510     +    run;
39512     +    proc sort data=&EM_USER_SPLITVALS;
39513     +      by DISPLAY_VAR _Group_;
39514     +    run;
39516     +   /* delete temporary datasets */
39517     +   proc datasets library= work nolist;
39518     +     delete tempsplitvals tempds tempclassout tempvariableset tempvars
39519     +     %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
39520     +       tempmissvalues
39521     +     %end;
39522     +     ;
39523     +   run;
39524     +   quit;
39525     +%mend EM_CLASSVARS_GROUP;
39528     +%macro EM_SUMMARIZE_TABLE(data, inputData, outData, varname=);
39530     +  proc sort data=&EM_DATA_VARIABLESET out=tempvarset; by name; run;
39532     +  data temptrain ;
39533     +    set &data;
39534     +  run;
39536     +  /* normalize all values prior to calculating counts */
39537     +  filename _temp catalog 'sashelp.emapps.em_Prenormalizeclassvars.source';
39538     +  %include _temp;
39539     +  filename _temp;
39540     +  filename _temp catalog 'sashelp.emapps.em_Normalizeclassvars.source';
39541     +  %include _temp;
39542     +  filename _temp;
39544     +  proc sort data=&EM_USER_VARMAPPINGS
39545     +  %if &varname ne %then %do;
39546     +    (where=(_variable_="&varname"))
39547     +  %end;
39548     +  out=tempmap; by _variable_; run;
39550     +  data _cmeta;
39551     +    merge tempvarset tempmap(in=_a rename=(_variable_=name ));
39552     +    by name;
39553     +    if ((_a) or (role="TARGET"));
39554     +    if role="INPUT" or (role="REJECTED" and Use="Y") then name=_proc_var_;
39555     +    %if %length(%EM_BINARY_TARGET) %then %do;
39556     +      if role="TARGET" then role="INPUT";
39557     +    %end;
39558     +    level = procLevel;
39559     +    index = kindex(name, "BIN_");
39560     +    if index gt 0 then do;
39561     +     level="ORDINAL";
39562     +     format = "";
39563     +    end;
39564     +    drop index;
39565     +  run;
39567     +  %em_PreNormalizeClassVars(incmeta=_cmeta, outcmeta=_cmetatmp);
39568     +  %em_NormalizeClassVars(indata=work.temptrain, cmeta=_cmetatmp, encodedTarget=N, outdata=_tmp_train);
39570     +  proc sort data=&inputData out=sortedmap; by _proc_var_; run;
39572     +  data _null_;
39573     +    set sortedmap end=eof;
39574     +    by _proc_var_;
39575     +    if _n_=1 then do;
39576     +      call execute("ods output CrossTabFreqs=crosstabfreq ;");
39577     +      call execute("ods listing close;");
39578     +      call execute("proc freq data=_tmp_train order=formatted addnames;");
39579     +      call execute("tables ("||_proc_var_);
39580     +    end;
39581     +    else do;
39582     +      call execute(_proc_var_);
39583     +    end;
39584     +    if eof then do;
39585     +      call execute(") * &ignbintarget/ missing;");
39586     +      %if %EM_FREQ ne %then %do;
39587     +        call execute("weight %EM_FREQ;");
39588     +      %end;
39589     +      call execute("run;");
39590     +      call execute("ods output close;");
39591     +      call execute("ods listing;");
39592     +    end;
39593     +  run;
39595     +  data _null_;
39596     +    set sortedmap end=eof;
39597     +    by _proc_var_;
39598     +    if _n_=1 then do;
39599     +      call execute("data crosstabs;");
39600     +      call execute("  length _variable_ _split_value_  $200 ;");
39601     +      call execute("  set crosstabfreq(where=(_type_='11'));");
39602     +      call execute("  _variable_= RowVariable;");
39603     +    end;
39605     +    call execute("if strip(RowVariable) = '"||strip(_proc_var_)||"' then do;");
39606     +    call execute("  _split_value_="||_proc_var_||";");
39607     +    call execute("end;");
39609     +    if eof then do;
39610     +      call execute("keep _variable_ _split_value_ &ignbintarget Frequency Percent display_var;");
39611     +      call execute("run;");
39612     +    end;
39613     +  run;
39615     +  proc sort data=crosstabs; by _variable_ _split_value_; run;
39617     +  data crosstabs;
39618     +    length display_var $32;
39619     +    merge crosstabs sortedmap(rename=(_variable_=display_var _proc_var_=_variable_ ) keep=_variable_ _proc_var_ );
39620     +    by _variable_;
39621     +  run;
39623     +  proc sort data=crosstabs; by display_var _split_value_; run;
39624     +  proc sort data=&EM_DATA_VARIABLESET out=tempvarset; by name; run;
39626     +  data crosstabs;
39627     +    merge crosstabs tempvarset(rename=(name=display_var) keep=type format name level);
39628     +    by display_var;
39629     +    index = kindex(_variable_, "BIN_");
39630     +    if index gt 0 then do;
39631     +     level="ORDINAL";
39632     +     format = "";
39633     +    end;
39634     +    _temp = &ignbintarget;
39635     +    /*
39636     +    %if ((&target_type eq C) OR (&target_format ne ))  %then %do;
39637     +      %if &target_format ne %then %do;
39638     +        %if &target_type eq C %then %do;
39639     +           %dmnormcp(put(&ignbintarget, &target_format), _temp);
39640     +        %end;
39641     +        %else %do;
39642     +           %dmnormcp(put(&ignbintarget, &target_format), _temp);
39643     +        %end;
39644     +      %end;
39645     +      %else %do;
39646     +        %dmnormcp(&ignbintarget, _temp);
39647     +      %end;
39648     +    %end;
39649     +    %else %do;
39650     +      _temp = &ignbintarget;
39651     +    %end;
39652     +*/
39654     +    drop index;
39655     +  run;
39657     +  proc sort data=crosstabs; by _variable_ _split_value_; run;
39659     +  data &outdata;
39660     +    length _variable_ _split_value_ $200 eventCount nonEventCount Total EventRate nonEventRate  8 type $1 valfmt $20 ;
39662     +    retain eventCount noneventCount ;
39663     +    set crosstabs;
39664     +    by  _variable_ _split_value_;
39666     +    if first._split_value_ then do;
39667     +     total=0;
39668     +     eventcount=0;
39669     +     noneventcount=0;
39670     +    end;
39672     +    %if ((&target_type eq C) OR (&target_format ne ))  %then %do;
39673     +      %if &target_format ne %then %do;
39674     +        if upcase(strip(_temp))="&target_event" then
39675     +          eventCount=Frequency;
39676     +      %end;
39677     +      %else %do;
39678     +         if upcase(strip(_temp)) ="&target_event" then
39679     +          eventCount=Frequency;
39680     +      %end;
39681     +    %end;
39682     +    %else %do;
39683     +      if _temp=&target_event then
39684     +        eventCount=Frequency;
39685     +    %end;
39686     +    else
39687     +      noneventCount=Frequency;
39689     +    if last._split_value_ then do;
39690     +      total = eventCount + noneventCount;
39692     +      if total ne 0 then do;
39693     +        eventRate = eventCount / total;
39694     +        nonEventRate = nonEventCount / total;
39695     +      end;
39696     +      else do;
39697     +        eventRate = 0;
39698     +        nonEventRate = 0;
39699     +      end;
39700     +     output;
39701     +    end;
39702     +    valfmt = format;
39704     +    drop _temp Frequency percent;
39705     +   run;
39707     +%mend EM_SUMMARIZE_TABLE;
39710     +%macro EM_FINE_DETAIL(bindata, varmappings, fineDetailData, splitVals, binMappings, interactiveFlag=0);
39712     +   proc freq data=&bindata noprint;
39713     +     table &ignbintarget / missing out=temptargetB;
39714     +     %if %EM_FREQ ne %then %do;
39715     +       weight %EM_FREQ;
39716     +     %end;
39717     +   run;
39719     +   %let tdsid = %sysfunc(open(work.temptargetB));
39720     +   %if &tdsid %then %do;
39721     +      %let tarnum = %sysfunc(VARNUM(&tdsid, &ignbintarget));
39722     +      %let tnum  = %sysfunc(VARNUM(&tdsid, COUNT));
39724     +      %let temp = %nrbquote(%sysfunc(strip(&target_event)));
39725     +      %let target_event = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
39726     +      %let temp = %nrbquote(%sysfunc(strip(&target_nonevent)));
39727     +      %let target_nonevent = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
39730     +      %let obs = %sysfunc(fetch(&tdsid));
39731     +      %do %while(&obs = 0);
39732     +         %if ((&target_type eq C) or (&target_format ne )) %then %do;
39733     +           %if &target_type eq C %then %do;
39734     +             %let temp = %nrbquote(%sysfunc(getvarc(&tdsid, &tarnum)));
39735     +             %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
39736     +           %end;
39737     +           %else
39738     +             %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
39740     +           %if &target_format ne %then %do;
39741     +              %if &target_type eq C %then %do;
39742     +                %let temp = %nrbquote(%sysfunc(putc(%nrbquote(&tarvalue), &target_format)));
39743     +                %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
39744     +              %end;
39745     +              %else
39746     +                %let tarvalue = %sysfunc(putn(&tarvalue, &target_format));
39747     +           %end;
39748     +           %let tarvalue = %nrbquote(%upcase(%sysfunc(strip(&tarvalue))));
39749     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
39751     +           %if "&tarvalue" eq "&target_event" %then %do;
39752     +             %let totalevent = &count;
39753     +           %end;
39754     +           %else %if "&tarvalue" eq "&target_nonevent" %then %do;
39755     +              %let totalnonevent= &count;
39756     +           %end;
39757     +         %end;
39758     +         %else %do;
39759     +           %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
39760     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
39762     +           %if &tarvalue eq &target_event %then %do;
39763     +             %let totalevent = &count;
39764     +           %end;
39765     +           %else %if &tarvalue eq &target_nonevent %then %do;
39766     +              %let totalnonevent= &count;
39767     +           %end;
39768     +         %end;
39769     +         %let obs = %sysfunc(fetch(&tdsid));
39770     +      %end;
39771     +   %end;
39772     +   %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
39774     +   proc datasets lib=work nolist;
39775     +      delete temptargetB;
39776     +   run;
39777     +   quit;
39779     +   %if &interactiveFlag eq 0 %then %do;
39780     +     %EM_SUMMARIZE_TABLE(&bindata, &varmappings, &fineDetailData);
39781     +   %end;
39782     +   %else %do;
39783     +     %EM_SUMMARIZE_TABLE(&bindata, &varmappings, &fineDetailData, varname=&wherevar);
39784     +   %end;
39787     +   data &fineDetailData;
39788     +     length display_var $32 newgroup numsplitval 8;
39789     +     set &fineDetailData;
39791     +     display_var = _variable_;
39793     +     index = kindex(display_var, "BIN_");
39794     +     if index gt 0 then do;
39795     +       display_var = ksubstr(display_var, 5);
39796     +     end;
39798     +     index2 = kindex(display_var, "SV_");
39799     +     if index2 gt 0 then do;
39800     +       display_var = ksubstr(display_var, 4);
39801     +     end;
39803     +     /* re-code missing values to "Missing" */
39804     +     if ((_SPLIT_VALUE_ = "") or (_SPLIT_VALUE_ = " ") or (_SPLIT_VALUE_ = ".")) then _SPLIT_VALUE_="MISSING";
39805     +     _index_ = _N_;
39806     +     newgroup = .;
39807     +     drop index index2 ;
39808     +   run;
39810     +   /* add group information to fineDetailData; */
39811     +   /* add label information for binned variables to fineDetailData*/
39813     +   proc sort data=&fineDetailData; by _variable_ _split_value_; run;
39815     +   data tmpsplitvals;
39816     +     set &splitvals;
39817     +     _norm_level_ = upcase(_norm_level_);
39818     +     if _split_value_ eq 'Missing' then _split_value_ = 'MISSING';
39819     +    * drop _split_value_;
39820     +   run;
39822     +   proc sort data=tmpsplitvals out=sortedsplit; by _variable_ _split_value_; run;
39823     +   proc datasets library=work nolist;
39824     +     delete tmpsplitvals;
39825     +   run;
39826     +   quit;
39828     +   proc sort data=&BINMAPPINGS out=sortedbin; by BIN_NAME BIN; run;
39830     +   data &fineDetailData;
39831     +      merge &fineDetailData(in=_c) work.sortedsplit(in=_b) work.sortedbin(rename=(BIN_NAME=_variable_ BIN=_split_value_) in=_a);
39832     +      by _variable_ _split_value_;
39833     +      if _a then do;
39834     +        binFlag = 1;
39835     +        VALUE=EM_BIN_LABEL;
39836     +      end;
39837     +      else do;
39838     +        binFlag = 0;
39839     +        *VALUE=strip(display_var)!!"="!!strip(_split_value_);
39840     +        VALUE=strip(_split_value_);
39842     +      end;
39844     +      if ((eventCount=.) or (nonEventCount=.)) then do;
39845     +        eventCount=0;
39846     +        nonEventCount=0;
39847     +        total = 0;
39848     +        eventRate= 0;
39849     +        nonEventRate = 0;
39850     +      end;
39852     +      eventCount = round(eventCount, .001);
39853     +      nonEventCount = round(nonEventCount, .001);
39854     +      total= round(total, .001);
39855     +      eventRate = round(eventRate, .001);
39856     +      nonEventRate = round(nonEventRate, .001);
39858     +     if ((type='N') AND (VERIFY(trim(left(_split_value_)) , '.0123456789')=0) ) then
39859     +         numsplitval = _split_value_;
39860     +     else if ((type='N') AND (valfmt ne "")) then
39861     +        numsplitval = _order_;
39862     +     else numsplitval=.;
39864     +      if DISPLAY_VAR = "" and _VARIABLE_ = "" then delete;
39865     +      if _a and ^_b then delete;
39866     +      if _c and ^_b then delete;
39867     +      drop NAME EM_BIN_LABEL valfmt;
39868     +   run;
39870     +   /* for class variables that have values falling into the "other" category, set _LEVEL_ and _GROUP_ based on Missing level */
39871     +   data &fineDetailData;
39872     +     set &fineDetailData;
39874     +     %let choice = _LEVEL_ ne "INTERVAL" and _SPLIT_VALUE_ eq "Missing";
39875     +     %let dsid = %sysfunc(open(&splitvals(where=(&choice))));
39876     +     %if &dsid %then %do;
39877     +       %let dnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
39878     +       %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
39879     +       %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
39881     +       %let obs = %sysfunc(fetch(&dsid));
39882     +       %do %while(&obs=0);
39883     +         %let dispvar = %sysfunc(getvarc(&dsid, &dnum));
39884     +         %let lvl     = %sysfunc(getvarc(&dsid, &lvlnum));
39885     +         %let group   = %sysfunc(getvarn(&dsid, &grpnum));
39887     +         if DISPLAY_VAR = "&dispvar" then do;
39888     +           if _LEVEL_ = "" then _LEVEL_ ="&lvl";
39889     +           if _GROUP_ = . then _GROUP_ = &group;
39890     +         end;
39892     +         %let obs = %sysfunc(fetch(&dsid));
39893     +       %end;
39894     +     %end;
39895     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
39896     +     if _GROUP_ = . then delete;
39897     +    * if binFlag=1 and UB=LB then delete;
39898     +    * if upcase(_SPLIT_VALUE_) ne "MISSING" and _index_ eq . then delete;
39899     +   run;
39901     +   proc sort data=&fineDetailData;
39902     +     by DISPLAY_VAR _index_;
39903     +   run;
39905     +   proc datasets lib=work nolist;
39906     +     delete sortedsplit sortedbin
39907     +     ;
39908     +   run;
39909     +   quit;
39910     +%mend EM_FINE_DETAIL;
39912     +%macro EM_CREATE_GROUPING(bindata, fineDetailData, coarse);
39914     +   proc freq data=&bindata noprint;
39915     +     table &ignbintarget / missing out=temptargetC;
39916     +     %if %EM_FREQ ne %then %do;weight %EM_FREQ;
39917     +     %end;
39918     +   run;
39920     +   %let tdsid = %sysfunc(open(work.temptargetC));
39921     +   %if &tdsid %then %do;
39922     +      %let tarnum = %sysfunc(VARNUM(&tdsid, &ignbintarget));
39923     +      %let tnum  = %sysfunc(VARNUM(&tdsid, COUNT));
39925     +      %let obs = %sysfunc(fetch(&tdsid));
39926     +      %do %while(&obs = 0);
39927     +        /* %if &target_type eq C or &target_format ne %then %do; */
39928     +         %if ((&target_type eq C) or (&target_format ne )) %then %do;
39929     +           %if &target_type eq C %then %do;
39930     +             %let temp = %nrbquote(%sysfunc(getvarc(&tdsid, &tarnum)));
39931     +             %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
39932     +           %end;
39933     +           %else
39934     +             %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
39936     +           %if &target_format ne %then %do;
39937     +              %if &target_type eq C %then %do;
39938     +                %let temp = %nrbquote(%sysfunc(putc(%nrbquote(&tarvalue), &target_format)));
39939     +                %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
39940     +              %end;
39941     +              %else
39942     +                %let tarvalue = %sysfunc(putn(&tarvalue, &target_format));
39943     +           %end;
39944     +           %let tarvalue =%nrbquote(%upcase(&tarvalue));
39945     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
39947     +           %let tarvalue = %nrbquote(%upcase(%sysfunc(strip(&tarvalue))));
39948     +           %let target_event = %nrbquote(%sysfunc(strip(&target_event)));
39949     +           %let target_nonevent = %nrbquote(%sysfunc(strip(&target_nonevent)));
39951     +           %if "&tarvalue" eq "&target_event" %then %do;
39952     +             %let totalevent = &count;
39953     +           %end;
39954     +           %else %if "&tarvalue" eq "&target_nonevent" %then %do;
39955     +              %let totalnonevent= &count;
39956     +           %end;
39957     +         %end;
39958     +         %else %do;
39959     +           %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
39960     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
39962     +           %if &tarvalue eq &target_event %then %do;
39963     +             %let totalevent = &count;
39964     +           %end;
39965     +           %else %if &tarvalue eq &target_nonevent %then %do;
39966     +              %let totalnonevent= &count;
39967     +           %end;
39968     +         %end;
39969     +         %let obs = %sysfunc(fetch(&tdsid));
39970     +      %end;
39971     +   %end;
39972     +   %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
39974     +   proc datasets lib=work nolist;
39975     +      delete temptargetC;
39976     +   run;
39977     +   quit;
39979     +   proc means data=&FINEDETAILDATA noprint;
39980     +      var eventCount nonEventCount;
39981     +      class _variable_  _group_;
39982     +      output out=summ(where=(_type_ in(2,3))) sum=eventCount nonEventCount;
39983     +   run;
39985     +   proc sort data=summ(drop=_type_ _freq_);
39986     +     by _variable_ _group_;
39987     +   run;
39989     +   data gini(keep=_variable_ eventCount nonEventCount groupresprate)
39990     +        tempcoarse(keep=_variable_  _group_ eventCount nonEventCount groupresprate groupNonRespRate eventRate nonEventRate respper nrespper);
39991     +        set summ;
39992     +        *format groupresprate 6.2;
39993     +        *format groupnonresprate 6.2;
39994     +        by _variable_ ;
39995     +        if _group_=. then do;
39996     +        end;
39997     +        else do;
39998     +           respper = eventCount / &totalEvent;
39999     +           nrespper = nonEventCount / &totalNonEvent;
40001     +           if ((nonEventCount = 0) AND (eventCount = 0)) then do;
40002     +                groupresprate=0;
40003     +                groupNonresprate = 0;
40004     +                eventRate = 0;
40005     +                nonEventRate = 0;
40006     +           end;
40007     +           else do;
40008     +               groupresprate = eventCount / (eventCount + nonEventCount) ;
40009     +               groupNonRespRate = 1 - groupRespRate;
40010     +               eventRate = eventCount / &totalEvent ;
40011     +               nonEventRate = nonEventCount / &totalNonEvent ;
40012     +            end;
40014     +           output gini tempcoarse;
40016     +        end;
40017     +   run;
40018     +   proc sort data=gini;
40019     +      by _variable_ descending groupresprate;
40020     +   run;
40022     +   data gini(keep= _variable_ _gini_);
40023     +     retain between within cumresp cumnresp;
40024     +     set gini(keep=_variable_  eventCount nonEventCount);
40025     +     by _variable_;
40026     +     if first._variable_ then do;
40027     +       between  = 0;
40028     +       within   = 0;
40029     +       cumresp  = 0;
40030     +       cumnresp = 0;
40031     +     end;
40032     +     between + 2 * cumnresp * eventCount;
40033     +     within + nonEventCount * eventCount;
40034     +     cumresp + eventCount;
40035     +     cumnresp + nonEventCount;
40036     +     if last._variable_ then do;
40037     +       if ^(cumnresp=0 or cumresp=0) then do;
40038     +         _gini_ = 100 * (1 - (within + between) / (cumnresp * cumresp));
40039     +         output;
40040     +       end;
40041     +     end;
40042     +   run;
40044     +   data tempdisplayvar;
40045     +      set &EM_USER_VARMAPPINGS;
40046     +      rename _variable_ = display_var
40047     +      _proc_var_ = _variable_;
40048     +   keep _variable_ _proc_var_ label;
40049     +   run;
40050     +   proc sort data=tempdisplayvar; by _variable_; run;
40052     +   data  &COARSE;
40053     +     length display_Var $32 label _label_ $200 role $10 _group_ 8;
40054     +     merge tempdisplayvar tempcoarse gini ;
40055     +     by _variable_;
40056     +     label display_var = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel , NOQUOTE))"
40057     +           eventRate   = "%sysfunc(sasmsg(sashelp.dmine, rpt_eventrate_vlabel , NOQUOTE))"
40058     +           nonEventRate = "%sysfunc(sasmsg(sashelp.dmine, rpt_noneventrate_vlabel , NOQUOTE))"
40059     +           _group_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_group_vlabel , NOQUOTE))"
40060     +           role       = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel , NOQUOTE))"
40061     +           _gini_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_gini_vlabel  , NOQUOTE))"
40062     +           eventcount = "%sysfunc(sasmsg(sashelp.dmine, rpt_eventcount_vlabel  , NOQUOTE))"
40063     +           noneventcount = "%sysfunc(sasmsg(sashelp.dmine, rpt_noneventcount_vlabel  , NOQUOTE))"
40064     +           groupresprate = "%sysfunc(sasmsg(sashelp.dmine, rpt_groupresprate_vlabel  , NOQUOTE))"
40065     +           groupnonresprate = "%sysfunc(sasmsg(sashelp.dmine, rpt_groupnonresprate_vlabel  , NOQUOTE))"
40066     +           ;
40068     +    eventCount = round(eventCount, .001);
40069     +    nonEventCount = round(nonEventCount, .001);
40070     +    groupRespRate = round(groupRespRate, .001);
40072     +     drop _variable_ index index2 respper nrespper;
40073     +   run;
40075     +   proc datasets library=work nolist;
40076     +     delete  tempcoarse gini             ;
40078     +   run;
40079     +   quit;
40081     +%mend EM_CREATE_GROUPING;
40085     +%macro EM_GENERATE_LABELVALUES(filename, splitvals, binmappings, coarse);
40087     +         data _null_;
40088     +            FILE &filename;
40089     +            put " length _LABEL_ $200;";
40090     +            put ' label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";';
40091     +         run;
40093     +         proc sort data=&SPLITVALS out=work.sortedsplitval; by display_var _split_Value_; run;
40094     +         proc sort data=&BINMAPPINGS; by display_var bin; run;
40096     +         data temp;
40097     +           merge work.sortedsplitval(in=_a) &BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
40098     +           by Display_Var _Split_value_;
40099     +           if upcase(_Split_value_) ne 'MISSING';
40100     +           if _a then output;
40101     +           if display_var eq '' then delete;
40102     +         run;
40104     +         data temp_missing;
40105     +           merge work.sortedsplitval(in=_a rename=(_GROUP_=MISSGRP)) &BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
40106     +           by Display_Var _Split_value_;
40107     +           if upcase(_Split_value_) eq 'MISSING';
40108     +           if _a then output;
40109     +           keep _variable_ display_var missgrp;
40110     +         run;
40112     +         proc sort data=temp out=class;
40113     +            by _variable_ _group_ LB;
40114     +         run;
40116     +         data _null_;
40118     +            file &filename MOD;
40119     +            length string $200 flag 8;
40120     +            retain string flag;
40121     +            set class end=eof;
40122     +            by _variable_  _group_;
40124     +            index = kindex(_variable_, "BIN_");
40125     +            if index gt 0 then do;
40126     +              if first._group_ then do;
40127     +                flag = 0;
40128     +                if ^first._variable_ then
40129     +                    put 'else';
40130     +                 else
40131     +                    put ' ';
40133     +                 string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = "
40134     +                          !!strip(put(_GROUP_,best12.))!!' then do;';
40135     +                 put string;
40137     +                 if LB ne . then do;
40138     +                   * string = strip(string)!!" _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
40139     +                    string = " _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
40140     +                 end;
40141     +                 else do;
40142     +                    flag = 1;
40143     +                    *string = strip(string)!!" _LABEL_='"!!strip(DISPLAY_VAR);
40144     +                    string = " _LABEL_='"!!strip(DISPLAY_VAR);
40145     +                 end;
40147     +              end;
40148     +              if last._Group_ then do;
40149     +                 if UB ne . then do;
40150     +                    string = strip(string)!!'< '!!strip(UB)!!"';";
40151     +                 end;
40152     +                 else do;
40153     +                    if flag=1 then do;
40154     +                      string = strip(string)!!"';";
40155     +                     /* string = strip(string)!!'='!!strip(_split_Value_)!!"';";*/
40156     +                    end;
40157     +                    else do;
40158     +                      string = strip(string)!!"';";
40159     +                    end;
40160     +                 end;
40161     +                 put string;
40163     +                 string= " UB="!!strip(UB)!!";";
40164     +                 put string;
40165     +                 put "end;";
40168     +              end;
40169     +            end;
40170     +            else do;
40171     +              _split_value_ = tranwrd(_split_value_,"'","''");
40172     +              if first._group_ then do;
40173     +                 flag = 0;
40174     +                 if ^first._variable_ then
40175     +                    put 'else';
40176     +                 else
40177     +                    put ' ';
40178     +                 string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = "
40179     +                          !!strip(put(_GROUP_,best12.))!!' then';
40180     +                 put string;
40181     +                 string = "_LABEL_='"!!strip(_split_value_);
40182     +              end;
40183     +              else do;
40184     +                 if flag ne 1 then do;
40185     +                   tempstring = strip(string)!!', '!!strip(_split_value_);
40186     +                   length = length(tempstring);
40188     +                   if length < 195 then do;
40189     +                      string = tempstring;
40190     +                   end;
40191     +                   else do;
40192     +                      string = strip(string)||",...";
40193     +                      flag=1;
40194     +                   end;
40195     +                 end;
40196     +              end;
40198     +              if last._group_ then do;
40199     +                 string = strip(string)!!"';";
40200     +                 put string;
40201     +              end;
40202     +            end;
40203     +         run;
40205     +         data &COARSE;
40206     +           set &COARSE;
40207     +          /* %inc Y; */
40208     +           %inc &filename;
40209     +         run;
40210     +         *filename Y;
40212     +         /* add missing to appropriate label - based on temp_missing data */
40213     +         data &COARSE;
40214     +           set &COARSE;
40216     +           %let dsid = %sysfunc(open(work.temp_missing));
40217     +           %if &dsid %then %do;
40218     +              %let varnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
40219     +              %let grpnum = %sysfunc(VARNUM(&dsid, MISSGRP));
40221     +              %let obs = %sysfunc(fetch(&dsid));
40222     +              %do %while(&obs=0);
40223     +                 %let var = %sysfunc(getvarc(&dsid, &varnum));
40224     +                 %let grp = %sysfunc(getvarn(&dsid, &grpnum));
40226     +                 if DISPLAY_VAR = "&var" and _GROUP_ = &grp then do;
40227     +                   if _LABEL_ eq '' then do;
40228     +                     _LABEL_ = "Missing";
40229     +                   end;
40230     +                   else do;
40231     +                     _LABEL_ = strip(_LABEL_)!!", Missing";
40232     +                   end;
40233     +                 end;
40234     +                 %let obs = %sysfunc(fetch(&dsid));
40235     +              %end;
40236     +           %end;
40237     +           %if &dsid %then %let dsid = %sysfunc(close(&dsid));
40238     +           drop ub;
40239     +         run;
40241     +         proc datasets library=work nolist;
40242     +           delete class temp temp_missing;
40243     +         run;
40244     +         quit;
40246     +%mend EM_GENERATE_LABELVALUES;
40248     +%macro calcValidationCoarse(input, output, varmappings, resultsTable);
40251     +%mend calcValidationCoarse;
40254     +%macro EM_IBN_IntTargetTrans(inttgtvar,method,newlevels=binlevs);
40255     +/* macro for transforming interval target to binary */
40257     +   %if &method = CUTMEAN %then %do;
40258     +      proc sql noprint;
40259     +         %if %EM_FREQ ne %then %do;
40260     +            select sum(&inttgtvar * %EM_FREQ) / sum(%EM_FREQ)
40261     +         %end;
40262     +         %else %do;
40263     +            select mean(&inttgtvar)
40264     +         %end;
40265     +         into :ignbincut from &em_import_data;
40266     +      quit;
40267     +   %end;
40269     +   /* create binary target */
40270     +   data &EM_USER_NEWTRAIN;
40271     +      set &EM_IMPORT_DATA;
40272     +      %if &method = CUTUSER %then %do;
40273     +           %let ignbincut = &EM_PROPERTY_USERCUTVALUE;
40274     +      %end;
40275     +      if &inttgtvar = . then &IGNBinTarget = .;
40276     +      else do;
40277     +         if &inttgtvar > &ignbincut then &IGNBinTarget=1;
40278     +         else &IGNBinTarget=0;
40279     +      end;
40280     +   run;
40282     +   /* Check that new target is actually binary */
40283     +   proc sql noprint;
40284     +      select distinct &IGNBINTarget into :bintv1 - from &EM_USER_NEWTRAIN where &IGNBinTarget ne .;
40285     +   quit;
40286     +   %global &newlevels;
40287     +   %let &newlevels=&sqlobs;
40289     +%mend EM_IBN_IntTargetTrans;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename trtemp;
NOTE: Fileref TRTEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data temp;
MPRINT(TRAIN):   set EMWS3.BINNING_VariableSet;
MPRINT(TRAIN):   where NAME =
MPRINT(TRAIN):  "BAD";
MPRINT(TRAIN):   run;

NOTE: There were 1 observations read from the data set EMWS3.BINNING_VARIABLESET.
      WHERE NAME='BAD';
NOTE: The data set WORK.TEMP has 1 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc dmdb data=EMWS3.Part_TRAIN(where=(^missing(
MPRINT(EM_BINARY_TARGET):  BAD
MPRINT(TRAIN):  ))) classout=EVENTOUT;
MPRINT(TRAIN):   target
MPRINT(EM_BINARY_TARGET):   BAD
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   class
MPRINT(EM_BINARY_TARGET):   BAD
MPRINT(TRAIN):  (DESC);
MPRINT(TRAIN):   run;

NOTE: Records processed = 2979   Memory used = 511K.
NOTE: There were 2979 observations read from the data set EMWS3.PART_TRAIN.
      WHERE not MISSING(BAD);
NOTE: The data set WORK.EVENTOUT has 2 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   dsid = open("EVENTOUT");
MPRINT(TRAIN):   if dsid>0 then do;
MPRINT(TRAIN):   levelnum = VARNUM(dsid, "LEVEL");
MPRINT(TRAIN):   if levelnum then do;
MPRINT(TRAIN):   if ^fetch(dsid) then call symput('TARGET_EVENT', strip(getvarc(dsid, levelnum)));
MPRINT(TRAIN):   if ^fetch(dsid) then call symput('TARGET_NONEVENT',strip(getvarc(dsid, levelnum)));
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   dsid=close(dsid);
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete eventout;
MPRINT(TRAIN):   run;

NOTE: Deleting WORK.EVENTOUT (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   data EMWS3.BINNING_NEWTRAIN;
MPRINT(TRAIN):   set EMWS3.Part_TRAIN;
MPRINT(TRAIN):   run;

NOTE: There were 2979 observations read from the data set EMWS3.PART_TRAIN.
NOTE: The data set EMWS3.BINNING_NEWTRAIN has 2979 observations and 14 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data tempvarnames;
MPRINT(TRAIN):   set EMWS3.BINNING_VariableSet;
MPRINT(TRAIN):   where ((ROLE='INPUT' and USE in('Y', 'D')) or (ROLE='REJECTED' and USE='Y')) and level ne 'UNARY';
MPRINT(TRAIN):   keep NAME LEVEL LABEL;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set EMWS3.BINNING_VARIABLESET.
      WHERE (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y'))) and (level not = 'UNARY');
NOTE: The data set WORK.TEMPVARNAMES has 12 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc dmdb data=tempvarnames outtable=tempmapping nameserver;
MPRINT(TRAIN):   names NAME;
MPRINT(TRAIN):   prefix WOE_ GRP_ ;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPMAPPING has 12 observations and 3 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=tempmapping;
MPRINT(TRAIN):   by name;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPMAPPING has 12 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=tempvarnames;
MPRINT(TRAIN):   by name;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPVARNAMES has 12 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   data tempmapping;
MPRINT(TRAIN):   merge tempmapping tempvarnames;
MPRINT(TRAIN):   by NAME;
MPRINT(TRAIN):   rename LEVEL=procLevel;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPMAPPING.
NOTE: There were 12 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPMAPPING has 12 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_MAPPING_TABLE):  ;
MPRINT(EM_GENERATE_MAPPING_TABLE):   data EMWS3.BINNING_VARMAPPINGS(keep=_variable_ _grp_variable_ procLevel label);
MPRINT(EM_GENERATE_MAPPING_TABLE):   length _variable_ _grp_variable_ $32 procLevel $8;
MPRINT(EM_GENERATE_MAPPING_TABLE):   set tempmapping;
MPRINT(EM_GENERATE_MAPPING_TABLE):   label _variable_ = "Variable input" _grp_variable_ = "Variable de grupo";
MPRINT(EM_GENERATE_MAPPING_TABLE):   _variable_ = NAME;
MPRINT(EM_GENERATE_MAPPING_TABLE):   _grp_variable_ = GRP;
MPRINT(EM_GENERATE_MAPPING_TABLE):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set EMWS3.BINNING_VARMAPPINGS has 12 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete tempImport tempScore;
MPRINT(TRAIN):   run;

NOTE: The file WORK.TEMPIMPORT (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.TEMPSCORE (memtype=DATA) was not found, but appears on a DELETE statement.
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   data tempvariableset;
MPRINT(EM_PRE_BINNING):   set EMWS3.BINNING_VariableSet;
MPRINT(EM_PRE_BINNING):   where LEVEL = 'INTERVAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 7 observations read from the data set EMWS3.BINNING_VARIABLESET.
      WHERE (LEVEL='INTERVAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 7 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_ '' maxvar 0;
MPRINT(EM_VARMACRO):   set tempvariableset end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   maxvar +1;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 4 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' "'!!trim(NAME)!!'"n';
MPRINT(EM_VARMACRO):   if eof then do;
The SAS System

MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = '"'!!TRIM(NAME)!!'"n';
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=4,
      Created=dom, 14 de mar de 2021 13:51:27,
      Last Modified=dom, 14 de mar de 2021 13:51:27,
      Filename=C:\Users\JOSECA~1\AppData\Local\Temp\SAS Temporary Files\_TD9076_DESKTOP-97HB97B_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M6,
      Host Created=X64_10PRO,
      Owner Name=DESKTOP-97HB97B\Jose Caloca,
      File Size=             5KB,
      File Size (bytes)=5120

NOTE: 5 records were written to the file MACFILE.
      The minimum record length was 19.
      The maximum record length was 62.
NOTE: There were 7 observations read from the data set WORK.TEMPVARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
40294     +%macro intervalvars;
40295     +"CLAGE"n "CLNO"n "DEBTINC"n "LOAN"n "MORTDUE"n "VALUE"n "YOJ"n
40296     +%mend intervalvars;
40297     +%global num_intvars;
40298     +%let num_intvars = 7 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_PRE_BINNING):  ;
MPRINT(EM_PRE_BINNING):   proc dmdb data=EMWS3.BINNING_NEWTRAIN classout=_CLASSOUT maxlevel=5;
MPRINT(EM_PRE_BINNING):   class
MPRINT(INTERVALVARS):   "CLAGE"n "CLNO"n "DEBTINC"n "LOAN"n "MORTDUE"n "VALUE"n
MPRINT(EM_PRE_BINNING):   "YOJ"n;
MPRINT(EM_PRE_BINNING):   run;

NOTE: Records processed = 2979   Memory used = 511K.
NOTE: There were 2979 observations read from the data set EMWS3.BINNING_NEWTRAIN.
NOTE: The data set WORK._CLASSOUT has 35 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   proc freq data=_CLASSOUT order=DATA noprint;
MPRINT(EM_PRE_BINNING):   table NAME / OUT= _COUNT(where=(COUNT<5));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 35 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._COUNT has 0 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   data _null_;
MPRINT(EM_PRE_BINNING):   set _COUNT;
MPRINT(EM_PRE_BINNING):   call symput('_INTBINS',symget('_INTBINS') !! ' ' !! ktrim(kleft(NAME)));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 0 observations read from the data set WORK._COUNT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   proc sort data=_CLASSOUT;
MPRINT(EM_PRE_BINNING):   by NAME;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 35 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._CLASSOUT has 35 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   proc transpose data=_CLASSOUT out=_OUT(DROP=_NAME_ RENAME=(NAME=VARIABLE)) prefix=_MIDPOINT;
MPRINT(EM_PRE_BINNING):   var NRAW;
MPRINT(EM_PRE_BINNING):   by NAME;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 35 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._OUT has 7 observations and 6 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   data _null_;
MPRINT(EM_PRE_BINNING):   dsid = open('_OUT');
MPRINT(EM_PRE_BINNING):   if dsid then do;
MPRINT(EM_PRE_BINNING):   call symput('NUMCLASSBARS', kleft(ktrim(put(attrn(dsid, 'NVARS')-1, best12.))));
MPRINT(EM_PRE_BINNING):   csid = close(dsid);
MPRINT(EM_PRE_BINNING):   end;
MPRINT(EM_PRE_BINNING):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   data _INTMID;
MPRINT(EM_PRE_BINNING):   set _OUT;
MPRINT(EM_PRE_BINNING):   keep VARIABLE _MIDPOINT1--_MIDPOINT5 ;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK._OUT.
NOTE: The data set WORK._INTMID has 7 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data EMWS3.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   set EMWS3.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   label procLevel = "Nivel para Interactivo";
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set EMWS3.BINNING_VARMAPPINGS.
NOTE: The data set EMWS3.BINNING_VARMAPPINGS has 12 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename temp catalog 'sashelp.emapps.quantile_binning.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMAPPS.QUANTILE_BINNING.SOURCE.
40300     +%macro em_apps_quantile_binning(input, vartable, numbins, binmappings, binningCode, codeMappings=, precision=0.01, dropOriginal=N, IncludeTarget=N);
40302     +  /* initialize binmappings table */
40303     +  data &BINMAPPINGS;
40304     +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
40305     +  run;
40309     +  %if &IncludeTarget=N %then %do;
40310     +   /* process only INTERVAL INPUTS */
40311     +  data tempvars;
40312     +    set &vartable(where=(ROLE="INPUT" AND LEVEL="INTERVAL"));
40313     +  run;
40314     +  %end;
40316     +  %if &IncludeTarget=Y %then %do;
40317     +   /* process both INTERVAL INPUTS and INTERVAL TARGETS*/
40318     +  data tempvars;
40319     +    set &vartable(where=((ROLE="INPUT" AND LEVEL="INTERVAL") or (ROLE="TARGET" AND LEVEL="INTERVAL")));
40320     +  run;
40321     +  %end;
40323     +  /* retrieve the name of interval inputs to bin */
40324     +  filename tempopen catalog 'sashelp.emutil.em_varmacro.source';
40325     +  %include tempopen;
40326     +  filename tempopen;
40328     +  %let intvars = ;
40329     +  %global num_intvars;
40330     +  %let num_intvars = 0;
40331     +  %em_varmacro(name=intvars, metadata=tempvars, key=NAME, nummacro=num_intvars);
40333     +  /* retrieve the name of frequency variable if it exists */
40334     +  %let em_bin_freq = ;
40335     +  %let choice = ROLE="FREQ";
40336     +  %let fdsid = %sysfunc(open(&vartable(where=(&choice))));
40337     +  %if &fdsid %then %do;
40338     +    %let fvarnum = %sysfunc(VARNUM(&fdsid, NAME));
40339     +    %let fobs = %sysfunc(fetch(&fdsid));
40340     +    %do %while(&fobs=0);
40341     +       %let em_bin_freq = %sysfunc(getvarc(&fdsid, &fvarnum));
40342     +       %let fobs = %sysfunc(fetch(&fdsid));
40343     +    %end;
40344     +  %end;
40345     +  %if &fdsid >0 %then %let fdsid = %sysfunc(close(&fdsid));
40347     +  /* process all inputs */
40348     +  %if &num_intvars > 0 %then %do;
40350     +    /* Computing quantile binning of interval inputs */
40351     +    %let numbin = %eval(&NUMBINS - 1);
40352     +    %let optstr=;
40353     +    %do i=1 %to &numbin;
40354     +       %let optstr = &optstr %sysevalf(&i*100/&&NUMBINS);
40355     +    %end;
40357     +    data tempInt / view = tempInt;
40358     +      set &input(keep= %intvars
40359     +      %if &em_bin_freq ne %then %do;
40360     +        &em_bin_freq
40361     +      %end;
40362     +      );
40363     +    run;
40365     +    proc stdize data=work.tempInt outstat=work.pctdata out=_null_ pctlpts=&optstr;
40366     +       var %intvars;
40367     +       %if &em_bin_freq ne %then %do;
40368     +          freq &em_bin_freq / notrunc;
40369     +       %end;
40370     +    run;
40372     +    proc transpose data=work.pctdata(where=(_type_=:'P')) out=work.pctdata;
40373     +    run;
40375     +    /* generate unique BIN_xxx names for all inputs processed */
40376     +    proc dmdb data=tempvars outtable=tempmapping nameserver;
40377     +     names NAME;
40378     +     prefix BIN_ ;
40379     +    run;
40381     +    proc sort data=tempmapping(keep=NAME bin); by NAME; run;
40382     +    proc sort data=work.pctdata; by _NAME_; run;
40383     +    %if ((&codemappings ne ) and (%sysfunc(exist(&codemappings, data)))) %then %do;
40384     +      proc sort data=&codemappings nodupkey out=tempcodemappings(keep= codeVar variable) ; by codeVar; run;
40385     +    %end;
40387     +    data tempbins;
40388     +      length display_var $32;
40389     +      merge work.pctdata(in=_a) tempmapping(rename=(name=_name_ bin=binVar))
40390     +      %if ((&codemappings ne ) and (%sysfunc(exist(&codemappings, data)))) %then %do;
40391     +         tempcodemappings(rename=(codeVar=_name_ variable=display_var))
40392     +      %end;
40393     +      ;
40394     +      by _NAME_;
40395     +      if _a;
40396     +      if missing(display_var) then display_var = _NAME_;
40397     +    run;
40399     +    /* generate BINMAPPINGS dataset and binningCode file*/
40400     +    data _null_;
40401     +      FILE &binningCode;
40402     +      set tempbins end=eof;
40403     +      length string $200;
40404     +      by _NAME_;
40406     +      if _n_=1 then do;
40407     +        put "&EM_CODEBAR;";
40408     +        %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
40409     +        put "* &note;";
40410     +        put "&EM_CODEBAR;";
40412     +        call execute(" data &BINMAPPINGS; ");
40413     +        call execute("   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;");
40414     +      end;
40416     +      %do i=1 %to %eval(&numbins-1);
40417     +       %if &i eq 1 %then %do;
40418     +         %let colname = COL&i;
40419     +         %let binvalnum = 1;
40420     +         LB = .;
40421     +         UB = round(&colname, &precision);
40422     +         bin=&binvalnum;
40424     +         call execute("name='"||strip(_NAME_)||"'; ");
40425     +         call execute("bin_name='"||strip(binVar)||"'; ");
40426     +         call execute("bin='"||strip(bin)||"';");
40427     +         call execute("LB=.;");
40428     +         call execute("UB="||UB||";");
40429     +         call execute("EM_BIN_LABEL='"||strip(display_var)||" < "||strip(UB)||"';");
40430     +         call execute("output;");
40432     +         string = "if "||strip(_name_)||" eq . then "||strip(binVar)||"= .;";
40434     +         put string;
40435     +         string = "else do;";
40436     +         put string;
40438     +         string= "  if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
40439     +         put string;
40442     +       %end;
40443     +       %else %do;
40444     +         %let colname = COL&i;
40445     +         %let lbnum = %sysevalf(&i-1);
40446     +         %let lbcol = COL&lbnum;
40447     +         UB = round(&colname, &precision);
40448     +         LB = round(&lbcol, &precision);
40449     +         if UB ne LB then do;
40450     +           bin=bin+1;
40452     +           call execute("name='"||strip(_NAME_)||"'; ");
40453     +           call execute("bin_name='"||strip(binVar)||"'; ");
40454     +           call execute("bin='"||strip(bin)||"';");
40455     +           call execute("LB="||LB||";");
40456     +           call execute("UB="||UB||";");
40457     +           call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
40458     +           call execute("output;");
40460     +           string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
40461     +           put string;
40463     +         end;
40464     +       %end;
40465     +      %end;
40466     +      %let binvalnum = %sysevalf(&binvalnum + 1);
40467     +      bin=bin+1;
40468     +      LB = round(&colname, &precision);
40469     +      UB = .;
40471     +      call execute("name='"||strip(_NAME_)||"'; ");
40472     +      call execute("bin_name = '"||strip(binVar)||"'; ");
40473     +      call execute("bin='"||strip(bin)||"';");
40474     +      call execute("UB=.;");
40475     +      call execute("LB="||LB||";");
40476     +      call execute("EM_BIN_LABEL='"||strip(display_Var)||" >= "||strip(LB)||"';");
40477     +      call execute("output;");
40479     +      string= "  else if "||strip(_name_)||" >= "||strip(LB)||" then "||strip(binVar)||"="||strip(bin)||";";
40480     +      put string;
40481     +      string="end;";
40482     +      put string;
40484     +      if eof then do;
40485     +        call execute("  if NAME='' and BIN_NAME='' and BIN='' then delete;");
40486     +        call execute("  if LB=UB then delete;");
40487     +        call execute("run;");
40488     +      end;
40490     +    run;
40492     +    /* drop original inputs */
40493     +    %if &dropOriginal=Y %then %do;
40494     +      data _null_;
40495     +        set work.tempvars end=eof;
40496     +        FILE &binningCode MOD;
40497     +        length string $200;
40499     +        if _n_=1 then do;
40500     +          put "drop";
40501     +        end;
40502     +        string = " "||strip(name);
40503     +        put string;
40505     +        if eof then do;
40506     +          put ";";
40507     +        end;
40508     +      run;
40509     +    %end;
40511     +    proc datasets library=work nolist;
40512     +      delete pctdata tempmapping tempbins tempInt;
40513     +    run;
40514     +    quit;
40515     +  %end;
40517     +  proc datasets library=work nolist;
40518     +    delete tempvars;
40519     +  run;
40520     +  quit;
40522     +%mend em_apps_quantile_binning;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_QUANTILE_BINNING):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   filename X "C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\BINNINGCODE.sas";
MPRINT(EM_QUANTILE_BINNING):   data work.vartable;
MPRINT(EM_QUANTILE_BINNING):   set work._intmid;
MPRINT(EM_QUANTILE_BINNING):   level = "INTERVAL";
MPRINT(EM_QUANTILE_BINNING):   role = "INPUT";
MPRINT(EM_QUANTILE_BINNING):   rename variable=name;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK._INTMID.
NOTE: The data set WORK.VARTABLE has 7 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data EMWS3.BINNING_BINMAPPINGS;
MPRINT(EM_APPS_QUANTILE_BINNING):   length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Variable NAME is uninitialized.
NOTE: Variable BIN_NAME is uninitialized.
NOTE: Variable LB is uninitialized.
NOTE: Variable UB is uninitialized.
NOTE: Variable BIN is uninitialized.
NOTE: Variable EM_BIN_LABEL is uninitialized.
NOTE: The data set EMWS3.BINNING_BINMAPPINGS has 1 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data tempvars;
MPRINT(EM_APPS_QUANTILE_BINNING):   set work.vartable(where=(ROLE="INPUT" AND LEVEL="INTERVAL"));
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK.VARTABLE.
      WHERE (ROLE='INPUT') and (LEVEL='INTERVAL');
NOTE: The data set WORK.TEMPVARS has 7 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   filename tempopen catalog 'sashelp.emutil.em_varmacro.source';
NOTE: %INCLUDE (level 1) file TEMPOPEN is file SASHELP.EMUTIL.EM_VARMACRO.SOURCE.
40527     +%macro em_varMacro(name=emMacro, metadata=, where=, key=NAME, nummacro=, maxvar=-1);
40529     +   filename macFile catalog 'work.emutil.macro.source';
40530     +   %let _METAOBS = 0;
40531     +   %let _maxvar = &maxvar;
40532     +   %if "&_maxvar" eq "" %then %let maxvar = -1;
40534     +   %if (%sysfunc(exist(&metadata))<1 and %sysfunc(exist(&metadata, VIEW))<1)
40535     +                   or (&metadata eq ) %then %do;
40536     +       %put * No metadata data set defined;
40537     +       %goto doend;
40538     +   %end;
40540     +   data _null_;
40541     +      length _STRING_ $80;
40542     +      retain _STRING_ '' maxvar 0;
40543     +      set &metadata end=eof;
40544     +      file macFile;
40545     +      %if %nrbquote(&where) ne %then %do;
40546     +          %let whereClause = where (%nrbquote(&where));
40547     +          %unquote(&whereClause);
40548     +      %end;
40549     +      if _N_=1 then do;
40550     +         string = "%"!!"macro &name;";
40551     +         put string;
40552     +      end;
40553     +      maxvar +1;
40554     +      if (length(_STRING_) + length(trim(&key))+ 4 < 80) then do;
40555     +         _STRING_ = trim(_STRING_)!!' '!!trim(&key);
40556     +         if eof
40557     +            %if  %sysevalf(&_maxvar > 0) %then %do;
40558     +                or maxvar >= &maxvar
40559     +            %end;
40560     +            then do;
40561     +            put _STRING_;
40562     +            string = "%"!!"mend &name;";
40563     +            put string;
40564     +            string = strip(put(_N_, best.));
40565     +            call symput('_METAOBS', string);
40566     +            %if (&nummacro ne ) %then %do;
40567     +                put "%" "global &nummacro;";
40568     +                put "%" "let &nummacro = " string ";";
40569     +            %end;
40570     +            stop;
40571     +         end;
40572     +      end;
40573     +      else do;
40574     +         put _STRING_;
40575     +         _string_ = TRIM(&key);
40576     +         if eof
40577     +            %if  %sysevalf(&_maxvar > 0) %then %do;
40578     +              or maxvar >= &maxvar
40579     +           %end;
40580     +            then do;
40581     +            put _STRING_;
40582     +            string = "%"!!"mend &name;";
40583     +            put string;
40584     +        end;
40585     +      end;
40586     +      if eof
40587     +         %if  %sysevalf(&_maxvar > 0) %then %do;
40588     +             or maxvar >= &maxvar
40589     +         %end;
40590     +         then do;
40591     +         string = strip(put(_N_, best.));
40592     +         call symput('_METAOBS', string);
40593     +         %if (&nummacro ne ) %then %do;
40594     +             put "%" "global &nummacro;";
40595     +             put "%" "let &nummacro = " string ";";
40596     +         %end;
40597     +         stop;
40598     +      end;
40599     +   run;
40601     +   %doend:
40602     +   %if ^&_METAOBS %then %do;
40603     +       data _null_;
40604     +          file macFile;
40605     +          put "%" "macro &name;";
40606     +          put "%" "mend &name;";
40607     +          %if (&nummacro ne ) %then %do;
40608     +              put "%" "global &nummacro;";
40609     +              put "%" "let &nummacro = 0;";
40610     +          %end;
40611     +      run;
40612     +   %end;
40613     +   %inc macFile;
40614     +   filename macFile;
40615     +%mend em_varMacro;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_APPS_QUANTILE_BINNING):   filename tempopen;
NOTE: Fileref TEMPOPEN has been deassigned.
MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_ '' maxvar 0;
MPRINT(EM_VARMACRO):   set tempvars end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   maxvar +1;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 4 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=dom, 14 de mar de 2021 13:51:27,
      Last Modified=dom, 14 de mar de 2021 13:51:27,
      Filename=C:\Users\JOSECA~1\AppData\Local\Temp\SAS Temporary Files\_TD9076_DESKTOP-97HB97B_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M6,
      Host Created=X64_10PRO,
      Owner Name=DESKTOP-97HB97B\Jose Caloca,
      File Size=            17KB,
      File Size (bytes)=17408

NOTE: 5 records were written to the file MACFILE.
      The minimum record length was 14.
      The maximum record length was 41.
NOTE: There were 7 observations read from the data set WORK.TEMPVARS.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
40616     +%macro intvars;
40617     +CLAGE CLNO DEBTINC LOAN MORTDUE VALUE YOJ
40618     +%mend intvars;
40619     +%global num_intvars;
40620     +%let num_intvars = 7 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_APPS_QUANTILE_BINNING):  ;
MPRINT(EM_APPS_QUANTILE_BINNING):   data tempInt / view = tempInt;
MPRINT(EM_APPS_QUANTILE_BINNING):   set EMWS3.BINNING_NEWTRAIN(keep
MPRINT(EM_APPS_QUANTILE_BINNING):  = CLAGE CLNO DEBTINC LOAN MORTDUE VALUE YOJ );
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: DATA STEP view saved on file WORK.TEMPINT.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc stdize data=work.tempInt outstat=work.pctdata out=_null_ pctlpts=25 50 75;
MPRINT(EM_APPS_QUANTILE_BINNING):   var
MPRINT(INTVARS):   CLAGE CLNO DEBTINC LOAN MORTDUE VALUE YOJ
MPRINT(EM_APPS_QUANTILE_BINNING):  ;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: View WORK.TEMPINT.VIEW used (Total process time):
      real time           0.07 seconds
      cpu time            0.04 seconds
      
NOTE: There were 2979 observations read from the data set EMWS3.BINNING_NEWTRAIN.
NOTE: There were 2979 observations read from the data set WORK.TEMPINT.
NOTE: The data set WORK.PCTDATA has 11 observations and 8 variables.
NOTE: PROCEDURE STDIZE used (Total process time):
      real time           0.08 seconds
      cpu time            0.06 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc transpose data=work.pctdata(where=(_type_=:'P')) out=work.pctdata;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 3 observations read from the data set WORK.PCTDATA.
      WHERE _type_=:'P';
NOTE: The data set WORK.PCTDATA has 7 observations and 4 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc dmdb data=tempvars outtable=tempmapping nameserver;
MPRINT(EM_APPS_QUANTILE_BINNING):   names NAME;
MPRINT(EM_APPS_QUANTILE_BINNING):   prefix BIN_ ;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK.TEMPVARS.
NOTE: The data set WORK.TEMPMAPPING has 7 observations and 2 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc sort data=tempmapping(keep=NAME bin);
MPRINT(EM_APPS_QUANTILE_BINNING):   by NAME;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPMAPPING has 7 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc sort data=work.pctdata;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK.PCTDATA.
NOTE: The data set WORK.PCTDATA has 7 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data tempbins;
MPRINT(EM_APPS_QUANTILE_BINNING):   length display_var $32;
MPRINT(EM_APPS_QUANTILE_BINNING):   merge work.pctdata(in=_a) tempmapping(rename=(name=_name_ bin=binVar)) ;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _a;
MPRINT(EM_APPS_QUANTILE_BINNING):   if missing(display_var) then display_var = _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

WARNING: Multiple lengths were specified for the BY variable _NAME_ by input data sets. This might cause unexpected results.
NOTE: There were 7 observations read from the data set WORK.PCTDATA.
NOTE: There were 7 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPBINS has 7 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data _null_;
MPRINT(EM_APPS_QUANTILE_BINNING):   FILE X;
MPRINT(EM_APPS_QUANTILE_BINNING):   set tempbins end=eof;
MPRINT(EM_APPS_QUANTILE_BINNING):   length string $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _n_=1 then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put "*------------------------------------------------------------*;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put "* Generando clases para las variables de intervalo;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put "*------------------------------------------------------------*;";
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute(" data EMWS3.BINNING_BINMAPPINGS; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;");
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = .;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL1, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB=.;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(display_var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string = "if "||strip(_name_)||" eq . then "||strip(binVar)||"= .;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string = "else do;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL2, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL1, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   if UB ne LB then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL3, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL2, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   if UB ne LB then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL3, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = .;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name = '"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB=.;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(display_Var)||" >= "||strip(LB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" >= "||strip(LB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string="end;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   if eof then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("  if NAME='' and BIN_NAME='' and BIN='' then delete;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("  if LB=UB then delete;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("run;");
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      216:110   222:129   225:166   254:48    254:89    283:110   286:111   289:122   292:139   292:185   303:44    303:85    337:110   340:111   343:122   346:139   346:185   357:44    357:85    388:108   394:129   397:167   407:45    407:86    
NOTE: The file X is:
      Filename=C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\BINNINGCODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=14 de marzo de 2021 13H51,
      Create Time=14 de marzo de 2021 13H51

MPRINT(EM_APPS_QUANTILE_BINNING):   data EMWS3.BINNING_BINMAPPINGS;
MPRINT(EM_APPS_QUANTILE_BINNING):   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 116.22;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='CLAGE < 116.22';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 116.22;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 175.17;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='116.22 <= CLAGE < 175.17';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 175.17;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 230.93;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='175.17 <= CLAGE < 230.93';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 230.93;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='CLAGE >= 230.93';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 14;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='CLNO < 14';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 14;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 20;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='14 <= CLNO < 20';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 20;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 26;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='20 <= CLNO < 26';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 26;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='CLNO >= 26';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 28.87;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='DEBTINC < 28.87';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 28.87;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 34.73;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='28.87 <= DEBTINC < 34.73';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 34.73;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 39.2;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='34.73 <= DEBTINC < 39.2';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 39.2;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='DEBTINC >= 39.2';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 11100;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOAN < 11100';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 11100;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 16200;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='11100 <= LOAN < 16200';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 16200;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 23200;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='16200 <= LOAN < 23200';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 23200;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOAN >= 23200';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 46406;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='MORTDUE < 46406';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 46406;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 64674;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='46406 <= MORTDUE < 64674';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 64674;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 93520;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='64674 <= MORTDUE < 93520';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 93520;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='MORTDUE >= 93520';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 66345;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='VALUE < 66345';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 66345;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 89107;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='66345 <= VALUE < 89107';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 89107;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 121714;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='89107 <= VALUE < 121714';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 121714;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='VALUE >= 121714';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 3;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='YOJ < 3';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 3;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 7;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='3 <= YOJ < 7';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 7;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 13;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='7 <= YOJ < 13';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 13;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='YOJ >= 13';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   if NAME='' and BIN_NAME='' and BIN='' then delete;
MPRINT(EM_APPS_QUANTILE_BINNING):   if LB=UB then delete;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;
NOTE: 52 records were written to the file X.
      The minimum record length was 4.
      The maximum record length was 63.
NOTE: There were 7 observations read from the data set WORK.TEMPBINS.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: CALL EXECUTE generated line.
1         +  data EMWS3.BINNING_BINMAPPINGS;
2         +    length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;
MPRINT(EM_APPS_QUANTILE_BINNING):  32 LB UB EM_BIN_LABEL BIN200
3         + name='CLAGE';
4         + bin_name='BIN_CLAGE';
5         + bin='1';
6         + LB=.;
7         + UB=      116.22;
8         + EM_BIN_LABEL='CLAGE < 116.22';
9         + output;
10        + name='CLAGE';
11        + bin_name='BIN_CLAGE';
12        + bin='2';
13        + LB=      116.22;
14        + UB=      175.17;
15        + EM_BIN_LABEL='116.22 <= CLAGE < 175.17';
16        + output;
17        + name='CLAGE';
18        + bin_name='BIN_CLAGE';
19        + bin='3';
20        + LB=      175.17;
21        + UB=      230.93;
22        + EM_BIN_LABEL='175.17 <= CLAGE < 230.93';
23        + output;
24        + name='CLAGE';
25        + bin_name = 'BIN_CLAGE';
26        + bin='4';
27        + UB=.;
28        + LB=      230.93;
29        + EM_BIN_LABEL='CLAGE >= 230.93';
30        + output;
31        + name='CLNO';
32        + bin_name='BIN_CLNO';
33        + bin='1';
34        + LB=.;
35        + UB=          14;
36        + EM_BIN_LABEL='CLNO < 14';
37        + output;
38        + name='CLNO';
39        + bin_name='BIN_CLNO';
40        + bin='2';
41        + LB=          14;
42        + UB=          20;
43        + EM_BIN_LABEL='14 <= CLNO < 20';
44        + output;
45        + name='CLNO';
46        + bin_name='BIN_CLNO';
47        + bin='3';
48        + LB=          20;
49        + UB=          26;
50        + EM_BIN_LABEL='20 <= CLNO < 26';
51        + output;
52        + name='CLNO';
53        + bin_name = 'BIN_CLNO';
54        + bin='4';
55        + UB=.;
56        + LB=          26;
57        + EM_BIN_LABEL='CLNO >= 26';
58        + output;
59        + name='DEBTINC';
60        + bin_name='BIN_DEBTINC';
61        + bin='1';
62        + LB=.;
63        + UB=       28.87;
64        + EM_BIN_LABEL='DEBTINC < 28.87';
65        + output;
66        + name='DEBTINC';
67        + bin_name='BIN_DEBTINC';
68        + bin='2';
69        + LB=       28.87;
70        + UB=       34.73;
71        + EM_BIN_LABEL='28.87 <= DEBTINC < 34.73';
72        + output;
73        + name='DEBTINC';
74        + bin_name='BIN_DEBTINC';
75        + bin='3';
76        + LB=       34.73;
77        + UB=        39.2;
78        + EM_BIN_LABEL='34.73 <= DEBTINC < 39.2';
79        + output;
80        + name='DEBTINC';
81        + bin_name = 'BIN_DEBTINC';
82        + bin='4';
83        + UB=.;
84        + LB=        39.2;
85        + EM_BIN_LABEL='DEBTINC >= 39.2';
86        + output;
87        + name='LOAN';
88        + bin_name='BIN_LOAN';
89        + bin='1';
90        + LB=.;
91        + UB=       11100;
92        + EM_BIN_LABEL='LOAN < 11100';
93        + output;
94        + name='LOAN';
95        + bin_name='BIN_LOAN';
96        + bin='2';
97        + LB=       11100;
98        + UB=       16200;
99        + EM_BIN_LABEL='11100 <= LOAN < 16200';
100       + output;
101       + name='LOAN';
102       + bin_name='BIN_LOAN';
103       + bin='3';
104       + LB=       16200;
105       + UB=       23200;
106       + EM_BIN_LABEL='16200 <= LOAN < 23200';
107       + output;
108       + name='LOAN';
109       + bin_name = 'BIN_LOAN';
110       + bin='4';
111       + UB=.;
112       + LB=       23200;
113       + EM_BIN_LABEL='LOAN >= 23200';
114       + output;
115       + name='MORTDUE';
116       + bin_name='BIN_MORTDUE';
117       + bin='1';
118       + LB=.;
119       + UB=       46406;
120       + EM_BIN_LABEL='MORTDUE < 46406';
121       + output;
122       + name='MORTDUE';
123       + bin_name='BIN_MORTDUE';
124       + bin='2';
125       + LB=       46406;
126       + UB=       64674;
127       + EM_BIN_LABEL='46406 <= MORTDUE < 64674';
128       + output;
129       + name='MORTDUE';
130       + bin_name='BIN_MORTDUE';
131       + bin='3';
132       + LB=       64674;
133       + UB=       93520;
134       + EM_BIN_LABEL='64674 <= MORTDUE < 93520';
135       + output;
136       + name='MORTDUE';
137       + bin_name = 'BIN_MORTDUE';
138       + bin='4';
139       + UB=.;
140       + LB=       93520;
141       + EM_BIN_LABEL='MORTDUE >= 93520';
142       + output;
143       + name='VALUE';
144       + bin_name='BIN_VALUE';
145       + bin='1';
146       + LB=.;
147       + UB=       66345;
148       + EM_BIN_LABEL='VALUE < 66345';
149       + output;
150       + name='VALUE';
151       + bin_name='BIN_VALUE';
152       + bin='2';
153       + LB=       66345;
154       + UB=       89107;
155       + EM_BIN_LABEL='66345 <= VALUE < 89107';
156       + output;
157       + name='VALUE';
158       + bin_name='BIN_VALUE';
159       + bin='3';
160       + LB=       89107;
161       + UB=      121714;
162       + EM_BIN_LABEL='89107 <= VALUE < 121714';
163       + output;
164       + name='VALUE';
165       + bin_name = 'BIN_VALUE';
166       + bin='4';
167       + UB=.;
168       + LB=      121714;
169       + EM_BIN_LABEL='VALUE >= 121714';
170       + output;
171       + name='YOJ';
172       + bin_name='BIN_YOJ';
173       + bin='1';
174       + LB=.;
175       + UB=           3;
176       + EM_BIN_LABEL='YOJ < 3';
177       + output;
178       + name='YOJ';
179       + bin_name='BIN_YOJ';
180       + bin='2';
181       + LB=           3;
182       + UB=           7;
183       + EM_BIN_LABEL='3 <= YOJ < 7';
184       + output;
185       + name='YOJ';
186       + bin_name='BIN_YOJ';
187       + bin='3';
188       + LB=           7;
189       + UB=          13;
190       + EM_BIN_LABEL='7 <= YOJ < 13';
191       + output;
192       + name='YOJ';
193       + bin_name = 'BIN_YOJ';
194       + bin='4';
195       + UB=.;
196       + LB=          13;
197       + EM_BIN_LABEL='YOJ >= 13';
198       + output;
199       +   if NAME='' and BIN_NAME='' and BIN='' then delete;
200       +   if LB=UB then delete;
201       + run;

NOTE: The data set EMWS3.BINNING_BINMAPPINGS has 28 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data _null_;
MPRINT(EM_APPS_QUANTILE_BINNING):   set work.tempvars end=eof;
MPRINT(EM_APPS_QUANTILE_BINNING):   FILE X MOD;
MPRINT(EM_APPS_QUANTILE_BINNING):   length string $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _n_=1 then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put "drop";
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   string = " "||strip(name);
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   if eof then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put ";";
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: The file X is:
      Filename=C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\BINNINGCODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=1631,
      Last Modified=14 de marzo de 2021 13H51,
      Create Time=14 de marzo de 2021 13H51

NOTE: 9 records were written to the file X.
      The minimum record length was 1.
      The maximum record length was 7.
NOTE: There were 7 observations read from the data set WORK.TEMPVARS.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_APPS_QUANTILE_BINNING):   delete pctdata tempmapping tempbins tempInt;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: The file WORK.TEMPINT (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.PCTDATA (memtype=DATA).
NOTE: Deleting WORK.TEMPMAPPING (memtype=DATA).
NOTE: Deleting WORK.TEMPBINS (memtype=DATA).
MPRINT(EM_APPS_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_APPS_QUANTILE_BINNING):   delete tempvars;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Deleting WORK.TEMPVARS (memtype=DATA).
MPRINT(EM_APPS_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS3.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   by name lb;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 28 observations read from the data set EMWS3.BINNING_BINMAPPINGS.
NOTE: The data set EMWS3.BINNING_BINMAPPINGS has 28 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS3.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   set EMWS3.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   length display_var $32 grp $8;
MPRINT(EM_QUANTILE_BINNING):   display_var = name;
MPRINT(EM_QUANTILE_BINNING):   GRP = BIN + 1;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      76:92   
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      76:96   
NOTE: There were 28 observations read from the data set EMWS3.BINNING_BINMAPPINGS.
NOTE: The data set EMWS3.BINNING_BINMAPPINGS has 28 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X;
NOTE: Fileref X has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS3.BINNING_BINMAPPINGS out=sortedmapping nodupkey;
MPRINT(EM_QUANTILE_BINNING):   by NAME;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 28 observations read from the data set EMWS3.BINNING_BINMAPPINGS.
NOTE: 21 observations with duplicate key values were deleted.
NOTE: The data set WORK.SORTEDMAPPING has 7 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: The data set WORK.TEMPMISSVALUES has 1 observations and 0 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   set sortedmapping;
MPRINT(EM_QUANTILE_BINNING):   GRP="1";
MPRINT(EM_QUANTILE_BINNING):   bin="Missing";
MPRINT(EM_QUANTILE_BINNING):   _split_value_ = "Missing";
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 7 observations read from the data set WORK.SORTEDMAPPING.
NOTE: The data set WORK.TEMPMISSVALUES has 7 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X "C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\BINNINGCODE.sas";
MPRINT(EM_QUANTILE_BINNING):   data EMWS3.BINNING_BINDATA;
MPRINT(EM_QUANTILE_BINNING):   set EMWS3.BINNING_NEWTRAIN;
NOTE: %INCLUDE (level 1) file X is file C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\BINNINGCODE.sas.
40621     +*------------------------------------------------------------*;
MPRINT(EM_QUANTILE_BINNING):   *------------------------------------------------------------*;
40622     +* Generando clases para las variables de intervalo;
MPRINT(EM_QUANTILE_BINNING):   * Generando clases para las variables de intervalo;
40623     +*------------------------------------------------------------*;
MPRINT(EM_QUANTILE_BINNING):   *------------------------------------------------------------*;
40624     +if CLAGE eq . then BIN_CLAGE= .;
MPRINT(EM_QUANTILE_BINNING):   if CLAGE eq . then BIN_CLAGE= .;
40625     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
40626     +if CLAGE < 116.22 then BIN_CLAGE=1;
MPRINT(EM_QUANTILE_BINNING):   if CLAGE < 116.22 then BIN_CLAGE=1;
40627     +else if CLAGE < 175.17 then BIN_CLAGE=2;
MPRINT(EM_QUANTILE_BINNING):   else if CLAGE < 175.17 then BIN_CLAGE=2;
40628     +else if CLAGE < 230.93 then BIN_CLAGE=3;
MPRINT(EM_QUANTILE_BINNING):   else if CLAGE < 230.93 then BIN_CLAGE=3;
40629     +else if CLAGE >= 230.93 then BIN_CLAGE=4;
MPRINT(EM_QUANTILE_BINNING):   else if CLAGE >= 230.93 then BIN_CLAGE=4;
40630     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
40631     +if CLNO eq . then BIN_CLNO= .;
MPRINT(EM_QUANTILE_BINNING):   if CLNO eq . then BIN_CLNO= .;
40632     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
40633     +if CLNO < 14 then BIN_CLNO=1;
MPRINT(EM_QUANTILE_BINNING):   if CLNO < 14 then BIN_CLNO=1;
40634     +else if CLNO < 20 then BIN_CLNO=2;
MPRINT(EM_QUANTILE_BINNING):   else if CLNO < 20 then BIN_CLNO=2;
40635     +else if CLNO < 26 then BIN_CLNO=3;
MPRINT(EM_QUANTILE_BINNING):   else if CLNO < 26 then BIN_CLNO=3;
40636     +else if CLNO >= 26 then BIN_CLNO=4;
MPRINT(EM_QUANTILE_BINNING):   else if CLNO >= 26 then BIN_CLNO=4;
40637     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
40638     +if DEBTINC eq . then BIN_DEBTINC= .;
MPRINT(EM_QUANTILE_BINNING):   if DEBTINC eq . then BIN_DEBTINC= .;
40639     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
40640     +if DEBTINC < 28.87 then BIN_DEBTINC=1;
MPRINT(EM_QUANTILE_BINNING):   if DEBTINC < 28.87 then BIN_DEBTINC=1;
40641     +else if DEBTINC < 34.73 then BIN_DEBTINC=2;
MPRINT(EM_QUANTILE_BINNING):   else if DEBTINC < 34.73 then BIN_DEBTINC=2;
40642     +else if DEBTINC < 39.2 then BIN_DEBTINC=3;
MPRINT(EM_QUANTILE_BINNING):   else if DEBTINC < 39.2 then BIN_DEBTINC=3;
40643     +else if DEBTINC >= 39.2 then BIN_DEBTINC=4;
MPRINT(EM_QUANTILE_BINNING):   else if DEBTINC >= 39.2 then BIN_DEBTINC=4;
40644     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
40645     +if LOAN eq . then BIN_LOAN= .;
MPRINT(EM_QUANTILE_BINNING):   if LOAN eq . then BIN_LOAN= .;
40646     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
40647     +if LOAN < 11100 then BIN_LOAN=1;
MPRINT(EM_QUANTILE_BINNING):   if LOAN < 11100 then BIN_LOAN=1;
40648     +else if LOAN < 16200 then BIN_LOAN=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOAN < 16200 then BIN_LOAN=2;
40649     +else if LOAN < 23200 then BIN_LOAN=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOAN < 23200 then BIN_LOAN=3;
40650     +else if LOAN >= 23200 then BIN_LOAN=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOAN >= 23200 then BIN_LOAN=4;
40651     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
40652     +if MORTDUE eq . then BIN_MORTDUE= .;
MPRINT(EM_QUANTILE_BINNING):   if MORTDUE eq . then BIN_MORTDUE= .;
40653     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
40654     +if MORTDUE < 46406 then BIN_MORTDUE=1;
MPRINT(EM_QUANTILE_BINNING):   if MORTDUE < 46406 then BIN_MORTDUE=1;
40655     +else if MORTDUE < 64674 then BIN_MORTDUE=2;
MPRINT(EM_QUANTILE_BINNING):   else if MORTDUE < 64674 then BIN_MORTDUE=2;
40656     +else if MORTDUE < 93520 then BIN_MORTDUE=3;
MPRINT(EM_QUANTILE_BINNING):   else if MORTDUE < 93520 then BIN_MORTDUE=3;
40657     +else if MORTDUE >= 93520 then BIN_MORTDUE=4;
MPRINT(EM_QUANTILE_BINNING):   else if MORTDUE >= 93520 then BIN_MORTDUE=4;
40658     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
40659     +if VALUE eq . then BIN_VALUE= .;
MPRINT(EM_QUANTILE_BINNING):   if VALUE eq . then BIN_VALUE= .;
40660     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
40661     +if VALUE < 66345 then BIN_VALUE=1;
MPRINT(EM_QUANTILE_BINNING):   if VALUE < 66345 then BIN_VALUE=1;
40662     +else if VALUE < 89107 then BIN_VALUE=2;
MPRINT(EM_QUANTILE_BINNING):   else if VALUE < 89107 then BIN_VALUE=2;
40663     +else if VALUE < 121714 then BIN_VALUE=3;
MPRINT(EM_QUANTILE_BINNING):   else if VALUE < 121714 then BIN_VALUE=3;
40664     +else if VALUE >= 121714 then BIN_VALUE=4;
MPRINT(EM_QUANTILE_BINNING):   else if VALUE >= 121714 then BIN_VALUE=4;
40665     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
40666     +if YOJ eq . then BIN_YOJ= .;
MPRINT(EM_QUANTILE_BINNING):   if YOJ eq . then BIN_YOJ= .;
40667     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
40668     +if YOJ < 3 then BIN_YOJ=1;
MPRINT(EM_QUANTILE_BINNING):   if YOJ < 3 then BIN_YOJ=1;
40669     +else if YOJ < 7 then BIN_YOJ=2;
MPRINT(EM_QUANTILE_BINNING):   else if YOJ < 7 then BIN_YOJ=2;
40670     +else if YOJ < 13 then BIN_YOJ=3;
MPRINT(EM_QUANTILE_BINNING):   else if YOJ < 13 then BIN_YOJ=3;
40671     +else if YOJ >= 13 then BIN_YOJ=4;
MPRINT(EM_QUANTILE_BINNING):   else if YOJ >= 13 then BIN_YOJ=4;
40672     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
40673     +drop
40674     +CLAGE
40675     +CLNO
40676     +DEBTINC
40677     +LOAN
40678     +MORTDUE
40679     +VALUE
40680     +YOJ
40681     +;
MPRINT(EM_QUANTILE_BINNING):   drop CLAGE CLNO DEBTINC LOAN MORTDUE VALUE YOJ ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 2979 observations read from the data set EMWS3.BINNING_NEWTRAIN.
NOTE: The data set EMWS3.BINNING_BINDATA has 2979 observations and 14 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X;
NOTE: Fileref X has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   data tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   set EMWS3.BINNING_BINMAPPINGS tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   length newgroup _group_ _order_ 8 _level_ $8;
MPRINT(EM_QUANTILE_BINNING):   newgroup =.;
MPRINT(EM_QUANTILE_BINNING):   _LEVEL_ = 'ORDINAL';
MPRINT(EM_QUANTILE_BINNING):   _Group_ = grp;
MPRINT(EM_QUANTILE_BINNING):   rename NAME=DISPLAY_VAR BIN =_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
MPRINT(EM_QUANTILE_BINNING):   keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_ _ORDER_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      196:121   
NOTE: Variable _order_ is uninitialized.
NOTE: There were 28 observations read from the data set EMWS3.BINNING_BINMAPPINGS.
NOTE: There were 7 observations read from the data set WORK.TEMPMISSVALUES.
NOTE: The data set WORK.TEMPSPLITVALS has 35 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   set tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   _order_ = _N_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 35 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set WORK.TEMPSPLITVALS has 35 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS3.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   set tempsplitvals ;
MPRINT(EM_QUANTILE_BINNING):   keep display_var _split_value_ _variable_ newgroup _group_ _level_ _order_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 35 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set EMWS3.BINNING_SPLITVALS has 35 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempvariableset;
MPRINT(EM_QUANTILE_BINNING):   set EMWS3.BINNING_VariableSet;
MPRINT(EM_QUANTILE_BINNING):   where LEVEL ^= 'INTERVAL' and TYPE = 'C' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 2 observations read from the data set EMWS3.BINNING_VARIABLESET.
      WHERE (LEVEL not = 'INTERVAL') and (TYPE='C') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 2 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_ '' maxvar 0;
MPRINT(EM_VARMACRO):   set tempvariableset end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   maxvar +1;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 4 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=dom, 14 de mar de 2021 13:51:27,
      Last Modified=dom, 14 de mar de 2021 13:51:27,
      Filename=C:\Users\JOSECA~1\AppData\Local\Temp\SAS Temporary Files\_TD9076_DESKTOP-97HB97B_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M6,
      Host Created=X64_10PRO,
      Owner Name=DESKTOP-97HB97B\Jose Caloca,
      File Size=            21KB,
      File Size (bytes)=21504

NOTE: 5 records were written to the file MACFILE.
      The minimum record length was 10.
      The maximum record length was 24.
NOTE: There were 2 observations read from the data set WORK.TEMPVARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
40682     +%macro classvars;
40683     +JOB REASON
40684     +%mend classvars;
40685     +%global num_classvars;
40686     +%let num_classvars = 2 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   proc dmdb data =EMWS3.BINNING_BINDATA classout=_classout nonorm;
MPRINT(EM_QUANTILE_BINNING):   class
MPRINT(CLASSVARS):   JOB REASON
MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Records processed = 2979   Memory used = 511K.
NOTE: There were 2979 observations read from the data set EMWS3.BINNING_BINDATA.
NOTE: The data set WORK._CLASSOUT has 10 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc dmdb data=EMWS3.BINNING_BINDATA classout=_classout2;
MPRINT(EM_QUANTILE_BINNING):   class
MPRINT(CLASSVARS):   JOB REASON
MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Records processed = 2979   Memory used = 511K.
NOTE: There were 2979 observations read from the data set EMWS3.BINNING_BINDATA.
NOTE: The data set WORK._CLASSOUT2 has 10 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=_classout;
MPRINT(EM_QUANTILE_BINNING):   by NAME CRAW;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._CLASSOUT has 10 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=_classout2;
MPRINT(EM_QUANTILE_BINNING):   by NAME CRAW;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._CLASSOUT2.
NOTE: The data set WORK._CLASSOUT2 has 10 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data _classout;
MPRINT(EM_QUANTILE_BINNING):   length _variable_ $32;
MPRINT(EM_QUANTILE_BINNING):   merge _classout _classout2 (rename=(LEVEL=_split_value_));
MPRINT(EM_QUANTILE_BINNING):   by NAME CRAW;
MPRINT(EM_QUANTILE_BINNING):   _variable_ = NAME;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._CLASSOUT.
NOTE: There were 10 observations read from the data set WORK._CLASSOUT2.
NOTE: The data set WORK._CLASSOUT has 10 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=_classout;
MPRINT(EM_QUANTILE_BINNING):   by _variable_ _split_value_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._CLASSOUT has 10 observations and 11 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS3.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   by _variable_ _split_value_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 35 observations read from the data set EMWS3.BINNING_SPLITVALS.
NOTE: The data set EMWS3.BINNING_SPLITVALS has 35 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS3.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   length _norm_level_ $200 _split_value_ $200;
MPRINT(EM_QUANTILE_BINNING):   merge EMWS3.BINNING_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
MPRINT(EM_QUANTILE_BINNING):   by _variable_ _split_value_;
MPRINT(EM_QUANTILE_BINNING):   LEVEL = trim(left(LEVEL));
MPRINT(EM_QUANTILE_BINNING):   _split_value_ = trim(left(_split_value_));
MPRINT(EM_QUANTILE_BINNING):   _norm_level_ = trim(left(_norm_level_));
MPRINT(EM_QUANTILE_BINNING):   if _norm_level_ eq '' then _norm_level_= _split_value_;
MPRINT(EM_QUANTILE_BINNING):   drop NAME FREQUENCY TYPE CRAW NRAW;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      353:121   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      353:111   
NOTE: There were 35 observations read from the data set EMWS3.BINNING_SPLITVALS.
NOTE: There were 10 observations read from the data set WORK._CLASSOUT.
NOTE: The data set EMWS3.BINNING_SPLITVALS has 45 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_QUANTILE_BINNING):   delete _classout _classout2;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Deleting WORK._CLASSOUT (memtype=DATA).
NOTE: Deleting WORK._CLASSOUT2 (memtype=DATA).
MPRINT(EM_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS3.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   set EMWS3.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   if _norm_level_ eq '' then _norm_level_= _split_value_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 45 observations read from the data set EMWS3.BINNING_SPLITVALS.
NOTE: The data set EMWS3.BINNING_SPLITVALS has 45 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS3.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   by DISPLAY_VAR _Group_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 45 observations read from the data set EMWS3.BINNING_SPLITVALS.
NOTE: The data set EMWS3.BINNING_SPLITVALS has 45 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_QUANTILE_BINNING):   delete sortedmapping tempsplitvals tempmissvalues ;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Deleting WORK.SORTEDMAPPING (memtype=DATA).
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
NOTE: Deleting WORK.TEMPMISSVALUES (memtype=DATA).
MPRINT(EM_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_CLASSVARS_GROUP):   proc sort data=EMWS3.BINNING_VariableSet out=tempvariableset;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   where ((LEVEL = 'NOMINAL') OR (LEVEL='BINARY')) and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 5 observations read from the data set EMWS3.BINNING_VARIABLESET.
      WHERE LEVEL in ('BINARY', 'NOMINAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 5 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc dmdb data=EMWS3.Part_TRAIN classout=tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   class DELINQ DEROG JOB NINQ REASON ;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: Records processed = 2979   Memory used = 511K.
NOTE: There were 2979 observations read from the data set EMWS3.PART_TRAIN.
NOTE: The data set WORK.TEMPCLASSOUT has 53 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL='MISSING' then level='Missing';
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 53 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: The data set WORK.TEMPCLASSOUT has 53 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data=tempclassout nodupkey;
MPRINT(EM_CLASSVARS_GROUP):   by NAME descending FREQUENCY LEVEL;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 53 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPCLASSOUT has 53 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempds(keep=NAME NOBS);
MPRINT(EM_CLASSVARS_GROUP):   retain NOBS;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   if first.NAME then NOBS = frequency;
MPRINT(EM_CLASSVARS_GROUP):   else NOBS=NOBS+frequency;
MPRINT(EM_CLASSVARS_GROUP):   if last.name then do;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 53 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: The data set WORK.TEMPDS has 5 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempds;
MPRINT(EM_CLASSVARS_GROUP):   merge tempclassout tempds;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   if ((LEVEL ne '') AND (LEVEL ne "."));
MPRINT(EM_CLASSVARS_GROUP):   PCT = 100 * (FREQUENCY/NOBS);
MPRINT(EM_CLASSVARS_GROUP):   if PCT < 0.5 then flag=1;
MPRINT(EM_CLASSVARS_GROUP):   else flag=0;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 53 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: There were 5 observations read from the data set WORK.TEMPDS.
NOTE: The data set WORK.TEMPDS has 48 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempmissvalues;
MPRINT(EM_CLASSVARS_GROUP):   length NAME $32 LEVEL $200 _LEVEL_ $8 _GROUP_ 8;
MPRINT(EM_CLASSVARS_GROUP):   NAME="DELINQ";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="DEROG";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="JOB";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="NINQ";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="REASON";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="BINARY";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: The data set WORK.TEMPMISSVALUES has 5 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempsplitvals;
MPRINT(EM_CLASSVARS_GROUP):   length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout tempmissvalues ;
MPRINT(EM_CLASSVARS_GROUP):   if ((level ne '') AND (level ne '.'));
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "DELINQ" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "0" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "1" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "2" then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "3" then _GROUP_ = 5;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "4" then _GROUP_ = 6;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "5" then _GROUP_ = 7;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "6" then _GROUP_ = 8;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 9;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "DEROG" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "0" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "1" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "2" then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "3" then _GROUP_ = 5;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 6;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "JOB" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "OTHER" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "PROFEXE" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "OFFICE" then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "MGR" then _GROUP_ = 5;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "SELF" then _GROUP_ = 6;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "SALES" then _GROUP_ = 7;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 8;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "NINQ" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "0" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "1" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "2" then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "3" then _GROUP_ = 5;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "4" then _GROUP_ = 6;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "5" then _GROUP_ = 7;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "6" then _GROUP_ = 8;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "7" then _GROUP_ = 9;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 10;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "REASON" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "BINARY";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "DEBTCON" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "HOMEIMP" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   _VARIABLE_ = NAME;
MPRINT(EM_CLASSVARS_GROUP):   newgroup = .;
MPRINT(EM_CLASSVARS_GROUP):   rename NAME = DISPLAY_VAR LEVEL = _SPLIT_VALUE_;
MPRINT(EM_CLASSVARS_GROUP):   keep NAME NEWGROUP _VARIABLE_ LEVEL _LEVEL_ _GROUP_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: Variable _Split_value_ is uninitialized.
NOTE: There were 53 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: There were 5 observations read from the data set WORK.TEMPMISSVALUES.
NOTE: The data set WORK.TEMPSPLITVALS has 53 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sql;
MPRINT(EM_CLASSVARS_GROUP):   reset noprint;
MPRINT(EM_CLASSVARS_GROUP):   select count(*) into :nobs from EMWS3.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data = EMWS3.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_value_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 45 observations read from the data set EMWS3.BINNING_SPLITVALS.
NOTE: The data set EMWS3.BINNING_SPLITVALS has 45 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data = tempsplitvals nodupkey;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_Value_ _group_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 53 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPSPLITVALS has 53 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data EMWS3.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   merge EMWS3.BINNING_SPLITVALS tempsplitvals ;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_value_ ;
MPRINT(EM_CLASSVARS_GROUP):   if display_var eq "" then delete;
MPRINT(EM_CLASSVARS_GROUP):   if _norm_level_ eq "" then _norm_level_ = _split_value_;
MPRINT(EM_CLASSVARS_GROUP):   keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 45 observations read from the data set EMWS3.BINNING_SPLITVALS.
NOTE: There were 53 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set EMWS3.BINNING_SPLITVALS has 88 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data=EMWS3.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   by DISPLAY_VAR _Group_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 88 observations read from the data set EMWS3.BINNING_SPLITVALS.
NOTE: The data set EMWS3.BINNING_SPLITVALS has 88 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc datasets library= work nolist;
MPRINT(EM_CLASSVARS_GROUP):   delete tempsplitvals tempds tempclassout tempvariableset tempvars tempmissvalues ;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: The file WORK.TEMPVARS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
NOTE: Deleting WORK.TEMPDS (memtype=DATA).
NOTE: Deleting WORK.TEMPCLASSOUT (memtype=DATA).
NOTE: Deleting WORK.TEMPVARIABLESET (memtype=DATA).
NOTE: Deleting WORK.TEMPMISSVALUES (memtype=DATA).
MPRINT(EM_CLASSVARS_GROUP):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_ORDVARS_GROUP):   proc sort data=EMWS3.BINNING_VariableSet out=tempvariableset;
MPRINT(EM_ORDVARS_GROUP):   by NAME;
MPRINT(EM_ORDVARS_GROUP):   where LEVEL = 'ORDINAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: Input data set is empty.
NOTE: There were 0 observations read from the data set EMWS3.BINNING_VARIABLESET.
      WHERE (LEVEL='ORDINAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 0 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_ORDVARS_GROUP):   proc sort data=EMWS3.BINNING_SPLITVALS;
MPRINT(EM_ORDVARS_GROUP):   by DISPLAY_VAR _Group_;
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_ORDVARS_GROUP):   proc datasets library= work nolist;
MPRINT(EM_ORDVARS_GROUP):   delete tempsplitvals varvals tempvariableset tempvars ;
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: The file WORK.TEMPSPLITVALS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.VARVALS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.TEMPVARS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPVARIABLESET (memtype=DATA).
MPRINT(EM_ORDVARS_GROUP):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc print data=EMWS3.BINNING_VARMAPPINGS label;
MPRINT(TRAIN):   var _VARIABLE_ _GRP_VARIABLE_ ;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set EMWS3.BINNING_VARMAPPINGS.
NOTE: The PROCEDURE PRINT printed page 8.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=EMWS3.BINNING_SPLITVALS out=tempsplitvals nodupkey;
MPRINT(TRAIN):   by _VARIABLE_;
MPRINT(TRAIN):   run;

NOTE: There were 88 observations read from the data set EMWS3.BINNING_SPLITVALS.
NOTE: 76 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPSPLITVALS has 12 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   data EMWS3.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   set EMWS3.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   length _proc_var_ $32;
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "CLAGE" then _proc_var_ = "BIN_CLAGE";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "CLNO" then _proc_var_ = "BIN_CLNO";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "DEBTINC" then _proc_var_ = "BIN_DEBTINC";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOAN" then _proc_var_ = "BIN_LOAN";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "MORTDUE" then _proc_var_ = "BIN_MORTDUE";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "VALUE" then _proc_var_ = "BIN_VALUE";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "YOJ" then _proc_var_ = "BIN_YOJ";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "DELINQ" then _proc_var_ = "DELINQ";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "DEROG" then _proc_var_ = "DEROG";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "JOB" then _proc_var_ = "JOB";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "NINQ" then _proc_var_ = "NINQ";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "REASON" then _proc_var_ = "REASON";
MPRINT(TRAIN):   if missing(_proc_var_) then _proc_var_=_variable_;
MPRINT(TRAIN):   run;

NOTE: There were 12 observations read from the data set EMWS3.BINNING_VARMAPPINGS.
NOTE: The data set EMWS3.BINNING_VARMAPPINGS has 12 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete sortedbin tempsplitvals;
MPRINT(TRAIN):   run;

NOTE: The file WORK.SORTEDBIN (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   proc freq data=EMWS3.BINNING_BINDATA noprint;
MPRINT(EM_FINE_DETAIL):   table BAD / missing out=temptargetB;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 2979 observations read from the data set EMWS3.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTARGETB has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets lib=work nolist;
MPRINT(EM_FINE_DETAIL):   delete temptargetB;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.TEMPTARGETB (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS3.BINNING_VariableSet out=tempvarset;
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 14 observations read from the data set EMWS3.BINNING_VARIABLESET.
NOTE: The data set WORK.TEMPVARSET has 14 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data temptrain ;
MPRINT(EM_SUMMARIZE_TABLE):   set EMWS3.BINNING_BINDATA;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 2979 observations read from the data set EMWS3.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTRAIN has 2979 observations and 14 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   filename _temp catalog 'sashelp.emapps.em_Prenormalizeclassvars.source';
NOTE: %INCLUDE (level 1) file _TEMP is file SASHELP.EMAPPS.EM_PRENORMALIZECLASSVARS.SOURCE.
40687     +%macro em_PreNormalizeClassVars(incmeta=, outcmeta=);
40688     +
40689     +   data &outcmeta(keep=INDEXVAR NAME LEVEL TYPE LABEL FORMAT INFORMAT) ;
40690     +      length INDEXVAR $32; retain _index 0;
40691     +      set &incmeta(where=((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y'));
40692     +      if strip(LEVEL) eq 'INTERVAL' then delete;
40693     +      else do;
40694     +         _index+1;
40695     +         INDEXVAR='_INDEXVAR'||strip(put(_index, Best12.));
40696     +      end;
40697     +   run;
40698     +%mend em_PreNormalizeClassVars;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp;
NOTE: Fileref _TEMP has been deassigned.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp catalog 'sashelp.emapps.em_Normalizeclassvars.source';
NOTE: %INCLUDE (level 1) file _TEMP is file SASHELP.EMAPPS.EM_NORMALIZECLASSVARS.SOURCE.
40699     +%macro em_NormalizeClassVars(indata=,
40700     +                          cmeta=,
40701     +                          encodedTarget=N,
40702     +                          target=,
40703     +                          targetEvent=,
40704     +                          targetNonEvent=,
40705     +                          outdata=);
40706     + %let dsid = %sysfunc(open(&cmeta));
40707     + %let vn_name =%sysfunc(varnum(&dsid, NAME));
40708     + %let vn_indexvar =%sysfunc(varnum(&dsid, INDEXVAR));
40709     + %let vn_format =%sysfunc(varnum(&dsid, FORMAT));
40710     + %let vn_type =%sysfunc(varnum(&dsid, TYPE));
40711     +
40712     + data &outdata/view=&outdata;
40713     +      length _normedvar32 $32.;
40714     +      set &indata( rename = (
40715     +      %let k = 1;
40716     +      %do %while(^%sysfunc(fetch(&dsid)));
40717     +          %let _name     = %sysfunc(getvarc(&dsid, &vn_name));
40718     +          %let _indexvar = %sysfunc(getvarc(&dsid, &vn_indexvar));
40719     +          %let _format   = %sysfunc(getvarc(&dsid, &vn_format));
40720     +          &_name = &_indexvar
40721     +          %let k = %eval(&k+1);
40722     +      %end;
40723     +      ));
40724     +      drop  _normedvar32;
40725     +
40726     +      %let rc=%sysfunc(rewind(&dsid));
40727     +      %let k = 1;
40728     +      %do %while(^%sysfunc(fetch(&dsid)));
40729     +          %let _name     = %sysfunc(getvarc(&dsid, &vn_name));
40730     +          %let _indexvar = %sysfunc(getvarc(&dsid, &vn_indexvar));
40731     +          %let _format   = %sysfunc(getvarc(&dsid, &vn_format));
40732     +          %let _type     = %sysfunc(getvarc(&dsid, &vn_type));
40733     +          %if &_format ne %then %do;
40734     +              _normedvar32 = put(&_indexvar, &_format);
40735     +          %end;
40736     +          %else %do;
40737     +              %if &_type = N %then %do;
40738     +                  _normedvar32 = put(&_indexvar, Best12.);
40739     +              %end;
40740     +              %else %do;
40741     +                  _normedvar32 = put(&_indexvar, $32.);
40742     +              %end;
40743     +          %end;
40744     +          %DMNORMIP(_normedvar32);
40745     +          &_name = _normedvar32;
40746     +          drop &_indexvar;
40747     +          %let k = %eval(&k+1);
40748     +      %end;
40749     +      %let dsid = %sysfunc(close(&dsid));
40750     +
40751     +      %if &encodedTarget = Y %then %do;
40752     +          %let qtargetEvent = %sysfunc(quote(&targetEvent));
40753     +          %let qtargetNonEvent = %sysfunc(quote(&targetNonEvent));
40754     +          if upcase(strip(&target)) = &qtargetEvent then _EncodedTarget_ =1;
40755     +          else if upcase(strip(&target)) = &qtargetNonEvent then _EncodedTarget_ = 0;
40756     +      %end;
40757     + run;
40758     +
40759     +%mend em_NormalizeClassVars;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp;
NOTE: Fileref _TEMP has been deassigned.
MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS3.BINNING_VARMAPPINGS out=tempmap;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 12 observations read from the data set EMWS3.BINNING_VARMAPPINGS.
NOTE: The data set WORK.TEMPMAP has 12 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data _cmeta;
MPRINT(EM_SUMMARIZE_TABLE):   merge tempvarset tempmap(in=_a rename=(_variable_=name ));
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   if ((_a) or (role="TARGET"));
MPRINT(EM_SUMMARIZE_TABLE):   if role="INPUT" or (role="REJECTED" and Use="Y") then name=_proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if role="TARGET" then role="INPUT";
MPRINT(EM_SUMMARIZE_TABLE):   level = procLevel;
MPRINT(EM_SUMMARIZE_TABLE):   index = kindex(name, "BIN_");
MPRINT(EM_SUMMARIZE_TABLE):   if index gt 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   level="ORDINAL";
MPRINT(EM_SUMMARIZE_TABLE):   format = "";
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   drop index;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      83:121   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      86:105   
NOTE: There were 14 observations read from the data set WORK.TEMPVARSET.
NOTE: There were 12 observations read from the data set WORK.TEMPMAP.
NOTE: The data set WORK._CMETA has 13 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRENORMALIZECLASSVARS):   data _cmetatmp(keep=INDEXVAR NAME LEVEL TYPE LABEL FORMAT INFORMAT) ;
MPRINT(EM_PRENORMALIZECLASSVARS):   length INDEXVAR $32;
MPRINT(EM_PRENORMALIZECLASSVARS):   retain _index 0;
MPRINT(EM_PRENORMALIZECLASSVARS):   set _cmeta(where=((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y'));
MPRINT(EM_PRENORMALIZECLASSVARS):   if strip(LEVEL) eq 'INTERVAL' then delete;
MPRINT(EM_PRENORMALIZECLASSVARS):   else do;
MPRINT(EM_PRENORMALIZECLASSVARS):   _index+1;
MPRINT(EM_PRENORMALIZECLASSVARS):   INDEXVAR='_INDEXVAR'||strip(put(_index, Best12.));
MPRINT(EM_PRENORMALIZECLASSVARS):   end;
MPRINT(EM_PRENORMALIZECLASSVARS):   run;

NOTE: There were 13 observations read from the data set WORK._CMETA.
      WHERE ((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y'));
NOTE: The data set WORK._CMETATMP has 13 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_NORMALIZECLASSVARS):   data _tmp_train/view=_tmp_train;
MPRINT(EM_NORMALIZECLASSVARS):   length _normedvar32 $32.;
MPRINT(EM_NORMALIZECLASSVARS):   set work.temptrain( rename = ( BAD = _INDEXVAR1 BIN_CLAGE = _INDEXVAR2 BIN_CLNO = _INDEXVAR3 BIN_DEBTINC = _INDEXVAR4 DELINQ = _INDEXVAR5 DEROG = _INDEXVAR6 JOB = _INDEXVAR7 BIN_LOAN = _INDEXVAR8 BIN_MORTDUE = _INDEXVAR9 
NINQ = _INDEXVAR10 REASON = _INDEXVAR11 BIN_VALUE = _INDEXVAR12 BIN_YOJ = _INDEXVAR13 ));
MPRINT(EM_NORMALIZECLASSVARS):   drop _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR1, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BAD = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR1;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR2, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_CLAGE = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR2;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR3, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_CLNO = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR3;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR4, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_DEBTINC = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR4;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR5, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   DELINQ = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR5;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR6, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   DEROG = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR6;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR7, $32.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   JOB = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR7;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR8, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOAN = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR8;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR9, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_MORTDUE = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR9;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR10, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   NINQ = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR10;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR11, $32.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   REASON = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR11;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR12, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_VALUE = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR12;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR13, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_YOJ = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR13;
MPRINT(EM_NORMALIZECLASSVARS):   run;

NOTE: DATA STEP view saved on file WORK._TMP_TRAIN.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS3.BINNING_VARMAPPINGS out=sortedmap;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 12 observations read from the data set EMWS3.BINNING_VARMAPPINGS.
NOTE: The data set WORK.SORTEDMAP has 12 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data _null_;
MPRINT(EM_SUMMARIZE_TABLE):   set sortedmap end=eof;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if _n_=1 then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods output CrossTabFreqs=crosstabfreq ;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods listing close;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("proc freq data=_tmp_train order=formatted addnames;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("tables ("||_proc_var_);
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   else do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute(_proc_var_);
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if eof then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute(") * BAD/ missing;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("run;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods output close;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods listing;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   run;

MPRINT(EM_SUMMARIZE_TABLE):   ods output CrossTabFreqs=crosstabfreq ;
MPRINT(EM_SUMMARIZE_TABLE):   ods listing close;
MPRINT(EM_SUMMARIZE_TABLE):   proc freq data=_tmp_train order=formatted addnames;
MPRINT(EM_SUMMARIZE_TABLE):   ) * BAD/ missing;
MPRINT(EM_SUMMARIZE_TABLE):   run;
MPRINT(EM_SUMMARIZE_TABLE):   ods output close;
MPRINT(EM_SUMMARIZE_TABLE):   ods listing;
NOTE: There were 12 observations read from the data set WORK.SORTEDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: CALL EXECUTE generated line.
1         + ods output CrossTabFreqs=crosstabfreq ;
MPRINT(EM_SUMMARIZE_TABLE):   CrossTabFreqs ;
2         + ods listing close;
MPRINT(EM_SUMMARIZE_TABLE):   close
3         + proc freq data=_tmp_train order=formatted addnames;
4         + tables (BIN_CLAGE
5         + BIN_CLNO
6         + BIN_DEBTINC
7         + BIN_LOAN
8         + BIN_MORTDUE
9         + BIN_VALUE
10        + BIN_YOJ
11        + DELINQ
12        + DEROG
13        + JOB
14        + NINQ
15        + REASON
16        + ) * BAD/ missing;
17        + run;

NOTE: View WORK._TMP_TRAIN.VIEW used (Total process time):
      real time           0.14 seconds
      cpu time            0.06 seconds
      
NOTE: There were 2979 observations read from the data set WORK.TEMPTRAIN.
NOTE: The data set WORK.CROSSTABFREQ has 297 observations and 23 variables.
NOTE: There were 2979 observations read from the data set WORK._TMP_TRAIN.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.17 seconds
      cpu time            0.07 seconds
      

18        + ods output close;
MPRINT(EM_SUMMARIZE_TABLE):   close
19        + ods listing;
MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_SUMMARIZE_TABLE):   data _null_;
MPRINT(EM_SUMMARIZE_TABLE):   set sortedmap end=eof;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if _n_=1 then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("data crosstabs;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  length _variable_ _split_value_  $200 ;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  set crosstabfreq(where=(_type_='11'));");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  _variable_= RowVariable;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("if strip(RowVariable) = '"||strip(_proc_var_)||"' then do;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  _split_value_="||_proc_var_||";");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("end;");
MPRINT(EM_SUMMARIZE_TABLE):   if eof then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("keep _variable_ _split_value_ BAD Frequency Percent display_var;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("run;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   run;

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   length _variable_ _split_value_ $200 ;
MPRINT(EM_SUMMARIZE_TABLE):   set crosstabfreq(where=(_type_='11'));
MPRINT(EM_SUMMARIZE_TABLE):   _variable_= RowVariable;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_CLAGE' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_CLAGE ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_CLNO' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_CLNO ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_DEBTINC' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_DEBTINC ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOAN' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOAN ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_MORTDUE' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_MORTDUE ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_VALUE' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_VALUE ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_YOJ' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_YOJ ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'DELINQ' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=DELINQ ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'DEROG' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=DEROG ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'JOB' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=JOB ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'NINQ' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=NINQ ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'REASON' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=REASON ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   keep _variable_ _split_value_ BAD Frequency Percent display_var;
MPRINT(EM_SUMMARIZE_TABLE):   run;
NOTE: There were 12 observations read from the data set WORK.SORTEDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

NOTE: CALL EXECUTE generated line.
1         + data crosstabs;
2         +   length _variable_ _split_value_  $200 ;
MPRINT(EM_SUMMARIZE_TABLE):  200
3         +   set crosstabfreq(where=(_type_='11'));
4         +   _variable_= RowVariable;
5         + if strip(RowVariable) = 'BIN_CLAGE' then do;
6         +   _split_value_=BIN_CLAGE                       ;
7         + end;
8         + if strip(RowVariable) = 'BIN_CLNO' then do;
9         +   _split_value_=BIN_CLNO                        ;
10        + end;
11        + if strip(RowVariable) = 'BIN_DEBTINC' then do;
12        +   _split_value_=BIN_DEBTINC                     ;
13        + end;
14        + if strip(RowVariable) = 'BIN_LOAN' then do;
15        +   _split_value_=BIN_LOAN                        ;
16        + end;
17        + if strip(RowVariable) = 'BIN_MORTDUE' then do;
18        +   _split_value_=BIN_MORTDUE                     ;
19        + end;
20        + if strip(RowVariable) = 'BIN_VALUE' then do;
21        +   _split_value_=BIN_VALUE                       ;
22        + end;
23        + if strip(RowVariable) = 'BIN_YOJ' then do;
24        +   _split_value_=BIN_YOJ                         ;
25        + end;
26        + if strip(RowVariable) = 'DELINQ' then do;
27        +   _split_value_=DELINQ                          ;
28        + end;
29        + if strip(RowVariable) = 'DEROG' then do;
30        +   _split_value_=DEROG                           ;
31        + end;
32        + if strip(RowVariable) = 'JOB' then do;
33        +   _split_value_=JOB                             ;
34        + end;
35        + if strip(RowVariable) = 'NINQ' then do;
36        +   _split_value_=NINQ                            ;
37        + end;
38        + if strip(RowVariable) = 'REASON' then do;
39        +   _split_value_=REASON                          ;
40        + end;
41        + keep _variable_ _split_value_ BAD Frequency Percent display_var;
42        + run;

WARNING: The variable display_var in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 174 observations read from the data set WORK.CROSSTABFREQ.
      WHERE _type_='11';
NOTE: The data set WORK.CROSSTABS has 174 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 174 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 174 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   length display_var $32;
MPRINT(EM_SUMMARIZE_TABLE):   merge crosstabs sortedmap(rename=(_variable_=display_var _proc_var_=_variable_ ) keep=_variable_ _proc_var_ );
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 174 observations read from the data set WORK.CROSSTABS.
NOTE: There were 12 observations read from the data set WORK.SORTEDMAP.
NOTE: The data set WORK.CROSSTABS has 174 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by display_var _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 174 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 174 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS3.BINNING_VariableSet out=tempvarset;
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 14 observations read from the data set EMWS3.BINNING_VARIABLESET.
NOTE: The data set WORK.TEMPVARSET has 14 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   merge crosstabs tempvarset(rename=(name=display_var) keep=type format name level);
MPRINT(EM_SUMMARIZE_TABLE):   by display_var;
MPRINT(EM_SUMMARIZE_TABLE):   index = kindex(_variable_, "BIN_");
MPRINT(EM_SUMMARIZE_TABLE):   if index gt 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   level="ORDINAL";
MPRINT(EM_SUMMARIZE_TABLE):   format = "";
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   _temp = BAD;
MPRINT(EM_SUMMARIZE_TABLE):   drop index;
MPRINT(EM_SUMMARIZE_TABLE):   run;

WARNING: Multiple lengths were specified for the BY variable display_var by input data sets. This might cause unexpected results.
NOTE: There were 174 observations read from the data set WORK.CROSSTABS.
NOTE: There were 14 observations read from the data set WORK.TEMPVARSET.
NOTE: The data set WORK.CROSSTABS has 176 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 176 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 176 observations and 10 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data EMWS3.BINNING_FINEDETAILDATA;
MPRINT(EM_SUMMARIZE_TABLE):   length _variable_ _split_value_ $200 eventCount nonEventCount Total EventRate nonEventRate 8 type $1 valfmt $20 ;
MPRINT(EM_SUMMARIZE_TABLE):   retain eventCount noneventCount ;
MPRINT(EM_SUMMARIZE_TABLE):   set crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   if first._split_value_ then do;
MPRINT(EM_SUMMARIZE_TABLE):   total=0;
MPRINT(EM_SUMMARIZE_TABLE):   eventcount=0;
MPRINT(EM_SUMMARIZE_TABLE):   noneventcount=0;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if _temp=1 then eventCount=Frequency;
MPRINT(EM_SUMMARIZE_TABLE):   else noneventCount=Frequency;
MPRINT(EM_SUMMARIZE_TABLE):   if last._split_value_ then do;
MPRINT(EM_SUMMARIZE_TABLE):   total = eventCount + noneventCount;
MPRINT(EM_SUMMARIZE_TABLE):   if total ne 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   eventRate = eventCount / total;
MPRINT(EM_SUMMARIZE_TABLE):   nonEventRate = nonEventCount / total;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   else do;
MPRINT(EM_SUMMARIZE_TABLE):   eventRate = 0;
MPRINT(EM_SUMMARIZE_TABLE):   nonEventRate = 0;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   output;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   valfmt = format;
MPRINT(EM_SUMMARIZE_TABLE):   drop _temp Frequency percent;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      375:126   
NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      1 at 394:122   1 at 403:134   1 at 406:129   
NOTE: There were 176 observations read from the data set WORK.CROSSTABS.
NOTE: The data set EMWS3.BINNING_FINEDETAILDATA has 88 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):  ;
MPRINT(EM_FINE_DETAIL):   data EMWS3.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   length display_var $32 newgroup numsplitval 8;
MPRINT(EM_FINE_DETAIL):   set EMWS3.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   display_var = _variable_;
MPRINT(EM_FINE_DETAIL):   index = kindex(display_var, "BIN_");
MPRINT(EM_FINE_DETAIL):   if index gt 0 then do;
MPRINT(EM_FINE_DETAIL):   display_var = ksubstr(display_var, 5);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   index2 = kindex(display_var, "SV_");
MPRINT(EM_FINE_DETAIL):   if index2 gt 0 then do;
MPRINT(EM_FINE_DETAIL):   display_var = ksubstr(display_var, 4);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if ((_SPLIT_VALUE_ = "") or (_SPLIT_VALUE_ = " ") or (_SPLIT_VALUE_ = ".")) then _SPLIT_VALUE_="MISSING";
MPRINT(EM_FINE_DETAIL):   _index_ = _N_;
MPRINT(EM_FINE_DETAIL):   newgroup = .;
MPRINT(EM_FINE_DETAIL):   drop index index2 ;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Variable numsplitval is uninitialized.
NOTE: There were 88 observations read from the data set EMWS3.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS3.BINNING_FINEDETAILDATA has 88 observations and 16 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS3.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 88 observations read from the data set EMWS3.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS3.BINNING_FINEDETAILDATA has 88 observations and 16 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   data tmpsplitvals;
MPRINT(EM_FINE_DETAIL):   set EMWS3.BINNING_SPLITVALS;
MPRINT(EM_FINE_DETAIL):   _norm_level_ = upcase(_norm_level_);
MPRINT(EM_FINE_DETAIL):   if _split_value_ eq 'Missing' then _split_value_ = 'MISSING';
MPRINT(EM_FINE_DETAIL):   * drop _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 88 observations read from the data set EMWS3.BINNING_SPLITVALS.
NOTE: The data set WORK.TMPSPLITVALS has 88 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=tmpsplitvals out=sortedsplit;
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 88 observations read from the data set WORK.TMPSPLITVALS.
NOTE: The data set WORK.SORTEDSPLIT has 88 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets library=work nolist;
MPRINT(EM_FINE_DETAIL):   delete tmpsplitvals;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.TMPSPLITVALS (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS3.BINNING_BINMAPPINGS out=sortedbin;
MPRINT(EM_FINE_DETAIL):   by BIN_NAME BIN;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 28 observations read from the data set EMWS3.BINNING_BINMAPPINGS.
NOTE: The data set WORK.SORTEDBIN has 28 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   data EMWS3.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   merge EMWS3.BINNING_FINEDETAILDATA(in=_c) work.sortedsplit(in=_b) work.sortedbin(rename=(BIN_NAME=_variable_ BIN=_split_value_) in=_a);
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   if _a then do;
MPRINT(EM_FINE_DETAIL):   binFlag = 1;
MPRINT(EM_FINE_DETAIL):   VALUE=EM_BIN_LABEL;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   else do;
MPRINT(EM_FINE_DETAIL):   binFlag = 0;
MPRINT(EM_FINE_DETAIL):   *VALUE=strip(display_var)!!"="!!strip(_split_value_);
MPRINT(EM_FINE_DETAIL):   VALUE=strip(_split_value_);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if ((eventCount=.) or (nonEventCount=.)) then do;
MPRINT(EM_FINE_DETAIL):   eventCount=0;
MPRINT(EM_FINE_DETAIL):   nonEventCount=0;
MPRINT(EM_FINE_DETAIL):   total = 0;
MPRINT(EM_FINE_DETAIL):   eventRate= 0;
MPRINT(EM_FINE_DETAIL):   nonEventRate = 0;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   eventCount = round(eventCount, .001);
MPRINT(EM_FINE_DETAIL):   nonEventCount = round(nonEventCount, .001);
MPRINT(EM_FINE_DETAIL):   total= round(total, .001);
MPRINT(EM_FINE_DETAIL):   eventRate = round(eventRate, .001);
MPRINT(EM_FINE_DETAIL):   nonEventRate = round(nonEventRate, .001);
MPRINT(EM_FINE_DETAIL):   if ((type='N') AND (VERIFY(trim(left(_split_value_)) , '.0123456789')=0) ) then numsplitval = _split_value_;
MPRINT(EM_FINE_DETAIL):   else if ((type='N') AND (valfmt ne "")) then numsplitval = _order_;
MPRINT(EM_FINE_DETAIL):   else numsplitval=.;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "" and _VARIABLE_ = "" then delete;
MPRINT(EM_FINE_DETAIL):   if _a and ^_b then delete;
MPRINT(EM_FINE_DETAIL):   if _c and ^_b then delete;
MPRINT(EM_FINE_DETAIL):   drop NAME EM_BIN_LABEL valfmt;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      321:70   
NOTE: Variable _order_ is uninitialized.
NOTE: There were 88 observations read from the data set EMWS3.BINNING_FINEDETAILDATA.
NOTE: There were 88 observations read from the data set WORK.SORTEDSPLIT.
NOTE: There were 28 observations read from the data set WORK.SORTEDBIN.
NOTE: The data set EMWS3.BINNING_FINEDETAILDATA has 88 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   data EMWS3.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   set EMWS3.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "CLAGE" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "CLNO" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "DEBTINC" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "DELINQ" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "DEROG" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "JOB" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOAN" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "MORTDUE" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "NINQ" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "REASON" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="BINARY";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "VALUE" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "YOJ" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then delete;
MPRINT(EM_FINE_DETAIL):   * if binFlag=1 and UB=LB then delete;
MPRINT(EM_FINE_DETAIL):   * if upcase(_SPLIT_VALUE_) ne "MISSING" and _index_ eq . then delete;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 88 observations read from the data set EMWS3.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS3.BINNING_FINEDETAILDATA has 88 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS3.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   by DISPLAY_VAR _index_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 88 observations read from the data set EMWS3.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS3.BINNING_FINEDETAILDATA has 88 observations and 24 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets lib=work nolist;
MPRINT(EM_FINE_DETAIL):   delete sortedsplit sortedbin ;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.SORTEDSPLIT (memtype=DATA).
NOTE: Deleting WORK.SORTEDBIN (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_CREATE_GROUPING):   proc freq data=EMWS3.BINNING_BINDATA noprint;
MPRINT(EM_CREATE_GROUPING):   table BAD / missing out=temptargetC;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 2979 observations read from the data set EMWS3.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTARGETC has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc datasets lib=work nolist;
MPRINT(EM_CREATE_GROUPING):   delete temptargetC;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Deleting WORK.TEMPTARGETC (memtype=DATA).
MPRINT(EM_CREATE_GROUPING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc means data=EMWS3.BINNING_FINEDETAILDATA noprint;
MPRINT(EM_CREATE_GROUPING):   var eventCount nonEventCount;
MPRINT(EM_CREATE_GROUPING):   class _variable_ _group_;
MPRINT(EM_CREATE_GROUPING):   output out=summ(where=(_type_ in(2,3))) sum=eventCount nonEventCount;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 88 observations read from the data set EMWS3.BINNING_FINEDETAILDATA.
NOTE: The data set WORK.SUMM has 82 observations and 6 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=summ(drop=_type_ _freq_);
MPRINT(EM_CREATE_GROUPING):   by _variable_ _group_;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 82 observations read from the data set WORK.SUMM.
NOTE: The data set WORK.SUMM has 82 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   data gini(keep=_variable_ eventCount nonEventCount groupresprate) tempcoarse(keep=_variable_ _group_ eventCount nonEventCount groupresprate groupNonRespRate eventRate nonEventRate respper nrespper);
MPRINT(EM_CREATE_GROUPING):   set summ;
MPRINT(EM_CREATE_GROUPING):   *format groupresprate 6.2;
MPRINT(EM_CREATE_GROUPING):   *format groupnonresprate 6.2;
MPRINT(EM_CREATE_GROUPING):   by _variable_ ;
MPRINT(EM_CREATE_GROUPING):   if _group_=. then do;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   else do;
MPRINT(EM_CREATE_GROUPING):   respper = eventCount / 594;
MPRINT(EM_CREATE_GROUPING):   nrespper = nonEventCount / 2385;
MPRINT(EM_CREATE_GROUPING):   if ((nonEventCount = 0) AND (eventCount = 0)) then do;
MPRINT(EM_CREATE_GROUPING):   groupresprate=0;
MPRINT(EM_CREATE_GROUPING):   groupNonresprate = 0;
MPRINT(EM_CREATE_GROUPING):   eventRate = 0;
MPRINT(EM_CREATE_GROUPING):   nonEventRate = 0;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   else do;
MPRINT(EM_CREATE_GROUPING):   groupresprate = eventCount / (eventCount + nonEventCount) ;
MPRINT(EM_CREATE_GROUPING):   groupNonRespRate = 1 - groupRespRate;
MPRINT(EM_CREATE_GROUPING):   eventRate = eventCount / 594 ;
MPRINT(EM_CREATE_GROUPING):   nonEventRate = nonEventCount / 2385 ;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   output gini tempcoarse;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 82 observations read from the data set WORK.SUMM.
NOTE: The data set WORK.GINI has 70 observations and 4 variables.
NOTE: The data set WORK.TEMPCOARSE has 70 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=gini;
MPRINT(EM_CREATE_GROUPING):   by _variable_ descending groupresprate;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 70 observations read from the data set WORK.GINI.
NOTE: The data set WORK.GINI has 70 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   data gini(keep= _variable_ _gini_);
MPRINT(EM_CREATE_GROUPING):   retain between within cumresp cumnresp;
MPRINT(EM_CREATE_GROUPING):   set gini(keep=_variable_ eventCount nonEventCount);
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   if first._variable_ then do;
MPRINT(EM_CREATE_GROUPING):   between = 0;
MPRINT(EM_CREATE_GROUPING):   within = 0;
MPRINT(EM_CREATE_GROUPING):   cumresp = 0;
MPRINT(EM_CREATE_GROUPING):   cumnresp = 0;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   between + 2 * cumnresp * eventCount;
MPRINT(EM_CREATE_GROUPING):   within + nonEventCount * eventCount;
MPRINT(EM_CREATE_GROUPING):   cumresp + eventCount;
MPRINT(EM_CREATE_GROUPING):   cumnresp + nonEventCount;
MPRINT(EM_CREATE_GROUPING):   if last._variable_ then do;
MPRINT(EM_CREATE_GROUPING):   if ^(cumnresp=0 or cumresp=0) then do;
MPRINT(EM_CREATE_GROUPING):   _gini_ = 100 * (1 - (within + between) / (cumnresp * cumresp));
MPRINT(EM_CREATE_GROUPING):   output;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 70 observations read from the data set WORK.GINI.
NOTE: The data set WORK.GINI has 12 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   data tempdisplayvar;
MPRINT(EM_CREATE_GROUPING):   set EMWS3.BINNING_VARMAPPINGS;
MPRINT(EM_CREATE_GROUPING):   rename _variable_ = display_var _proc_var_ = _variable_;
MPRINT(EM_CREATE_GROUPING):   keep _variable_ _proc_var_ label;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 12 observations read from the data set EMWS3.BINNING_VARMAPPINGS.
NOTE: The data set WORK.TEMPDISPLAYVAR has 12 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=tempdisplayvar;
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPDISPLAYVAR.
NOTE: The data set WORK.TEMPDISPLAYVAR has 12 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   data EMWS3.BINNING_COARSE;
MPRINT(EM_CREATE_GROUPING):   length display_Var $32 label _label_ $200 role $10 _group_ 8;
MPRINT(EM_CREATE_GROUPING):   merge tempdisplayvar tempcoarse gini ;
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   label display_var = "Variable" eventRate = "Tasa de eventos" nonEventRate = "Tasa de no evento" _group_ = "Grupo" role = "Rol" _gini_ = "Coeficiente Gini" eventcount = "Número de eventos" noneventcount = "Número de no 
eventos" groupresprate = "Tasa de eventos del grupo" groupnonresprate = "Tasa de no evento de grupo" ;
MPRINT(EM_CREATE_GROUPING):   eventCount = round(eventCount, .001);
MPRINT(EM_CREATE_GROUPING):   nonEventCount = round(nonEventCount, .001);
MPRINT(EM_CREATE_GROUPING):   groupRespRate = round(groupRespRate, .001);
MPRINT(EM_CREATE_GROUPING):   drop _variable_ index index2 respper nrespper;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Variable _label_ is uninitialized.
NOTE: Variable role is uninitialized.
WARNING: Multiple lengths were specified for the BY variable _variable_ by input data sets. This might cause unexpected results.
WARNING: The variable index in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable index2 in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 12 observations read from the data set WORK.TEMPDISPLAYVAR.
NOTE: There were 70 observations read from the data set WORK.TEMPCOARSE.
NOTE: There were 12 observations read from the data set WORK.GINI.
NOTE: The data set EMWS3.BINNING_COARSE has 70 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc datasets library=work nolist;
MPRINT(EM_CREATE_GROUPING):   delete tempcoarse gini ;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Deleting WORK.TEMPCOARSE (memtype=DATA).
NOTE: Deleting WORK.GINI (memtype=DATA).
MPRINT(EM_CREATE_GROUPING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename Y "C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\GROUPMAPPINGSCORECODE.sas";
MPRINT(EM_GENERATE_LABELVALUES):   data _null_;
MPRINT(EM_GENERATE_LABELVALUES):   FILE Y;
MPRINT(EM_GENERATE_LABELVALUES):   put " length _LABEL_ $200;";
MPRINT(EM_GENERATE_LABELVALUES):   put ' label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";';
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: The file Y is:
      Filename=C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\GROUPMAPPINGSCORECODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=14 de marzo de 2021 13H51,
      Create Time=14 de marzo de 2021 13H51

NOTE: 2 records were written to the file Y.
      The minimum record length was 21.
      The maximum record length was 83.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=EMWS3.BINNING_SPLITVALS out=work.sortedsplitval;
MPRINT(EM_GENERATE_LABELVALUES):   by display_var _split_Value_;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 88 observations read from the data set EMWS3.BINNING_SPLITVALS.
NOTE: The data set WORK.SORTEDSPLITVAL has 88 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=EMWS3.BINNING_BINMAPPINGS;
MPRINT(EM_GENERATE_LABELVALUES):   by display_var bin;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 28 observations read from the data set EMWS3.BINNING_BINMAPPINGS.
NOTE: The data set EMWS3.BINNING_BINMAPPINGS has 28 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data temp;
MPRINT(EM_GENERATE_LABELVALUES):   merge work.sortedsplitval(in=_a) EMWS3.BINNING_BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
MPRINT(EM_GENERATE_LABELVALUES):   by Display_Var _Split_value_;
MPRINT(EM_GENERATE_LABELVALUES):   if upcase(_Split_value_) ne 'MISSING';
MPRINT(EM_GENERATE_LABELVALUES):   if _a then output;
MPRINT(EM_GENERATE_LABELVALUES):   if display_var eq '' then delete;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 88 observations read from the data set WORK.SORTEDSPLITVAL.
NOTE: There were 28 observations read from the data set EMWS3.BINNING_BINMAPPINGS.
NOTE: The data set WORK.TEMP has 76 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data temp_missing;
MPRINT(EM_GENERATE_LABELVALUES):   merge work.sortedsplitval(in=_a rename=(_GROUP_=MISSGRP)) EMWS3.BINNING_BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
MPRINT(EM_GENERATE_LABELVALUES):   by Display_Var _Split_value_;
MPRINT(EM_GENERATE_LABELVALUES):   if upcase(_Split_value_) eq 'MISSING';
MPRINT(EM_GENERATE_LABELVALUES):   if _a then output;
MPRINT(EM_GENERATE_LABELVALUES):   keep _variable_ display_var missgrp;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 88 observations read from the data set WORK.SORTEDSPLITVAL.
NOTE: There were 28 observations read from the data set EMWS3.BINNING_BINMAPPINGS.
NOTE: The data set WORK.TEMP_MISSING has 12 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=temp out=class;
MPRINT(EM_GENERATE_LABELVALUES):   by _variable_ _group_ LB;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 76 observations read from the data set WORK.TEMP.
NOTE: The data set WORK.CLASS has 76 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data _null_;
MPRINT(EM_GENERATE_LABELVALUES):   file Y MOD;
MPRINT(EM_GENERATE_LABELVALUES):   length string $200 flag 8;
MPRINT(EM_GENERATE_LABELVALUES):   retain string flag;
MPRINT(EM_GENERATE_LABELVALUES):   set class end=eof;
MPRINT(EM_GENERATE_LABELVALUES):   by _variable_ _group_;
MPRINT(EM_GENERATE_LABELVALUES):   index = kindex(_variable_, "BIN_");
MPRINT(EM_GENERATE_LABELVALUES):   if index gt 0 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if first._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 0;
MPRINT(EM_GENERATE_LABELVALUES):   if ^first._variable_ then put 'else';
MPRINT(EM_GENERATE_LABELVALUES):   else put ' ';
MPRINT(EM_GENERATE_LABELVALUES):   string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = " !!strip(put(_GROUP_,best12.))!!' then do;';
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   if LB ne . then do;
MPRINT(EM_GENERATE_LABELVALUES):   * string = strip(string)!!" _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   string = " _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 1;
MPRINT(EM_GENERATE_LABELVALUES):   *string = strip(string)!!" _LABEL_='"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   string = " _LABEL_='"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if last._Group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   if UB ne . then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!'< '!!strip(UB)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   if flag=1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   string= " UB="!!strip(UB)!!";";
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   put "end;";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _split_value_ = tranwrd(_split_value_,"'","''");
MPRINT(EM_GENERATE_LABELVALUES):   if first._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 0;
MPRINT(EM_GENERATE_LABELVALUES):   if ^first._variable_ then put 'else';
MPRINT(EM_GENERATE_LABELVALUES):   else put ' ';
MPRINT(EM_GENERATE_LABELVALUES):   string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = " !!strip(put(_GROUP_,best12.))!!' then';
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   string = "_LABEL_='"!!strip(_split_value_);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   if flag ne 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   tempstring = strip(string)!!', '!!strip(_split_value_);
MPRINT(EM_GENERATE_LABELVALUES):   length = length(tempstring);
MPRINT(EM_GENERATE_LABELVALUES):   if length < 195 then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = tempstring;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)||",...";
MPRINT(EM_GENERATE_LABELVALUES):   flag=1;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if last._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      171:84    206:151   246:25    
NOTE: The file Y is:
      Filename=C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\GROUPMAPPINGSCORECODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=108,
      Last Modified=14 de marzo de 2021 13H51,
      Create Time=14 de marzo de 2021 13H51

NOTE: 230 records were written to the file Y.
      The minimum record length was 1.
      The maximum record length was 49.
NOTE: There were 76 observations read from the data set WORK.CLASS.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data EMWS3.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   set EMWS3.BINNING_COARSE;
NOTE: %INCLUDE (level 1) file Y is file C:\Jose\DM_ang\Workspaces\EMWS3\BINNING\GROUPMAPPINGSCORECODE.sas.
40760     + length _LABEL_ $200;
MPRINT(EM_GENERATE_LABELVALUES):   length _LABEL_ $200;
40761     + label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";
MPRINT(EM_GENERATE_LABELVALUES):   label _LABEL_= "Valores de grupo";
40762     +
40763     +if DISPLAY_VAR='CLAGE' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='CLAGE' and _GROUP_ = 2 then do;
40764     +_LABEL_='CLAGE< 116.22';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='CLAGE< 116.22';
40765     +UB=116.22;
MPRINT(EM_GENERATE_LABELVALUES):   UB=116.22;
40766     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40767     +else
40768     +if DISPLAY_VAR='CLAGE' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='CLAGE' and _GROUP_ = 3 then do;
40769     +_LABEL_='116.22<= CLAGE< 175.17';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='116.22<= CLAGE< 175.17';
40770     +UB=175.17;
MPRINT(EM_GENERATE_LABELVALUES):   UB=175.17;
40771     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40772     +else
40773     +if DISPLAY_VAR='CLAGE' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='CLAGE' and _GROUP_ = 4 then do;
40774     +_LABEL_='175.17<= CLAGE< 230.93';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='175.17<= CLAGE< 230.93';
40775     +UB=230.93;
MPRINT(EM_GENERATE_LABELVALUES):   UB=230.93;
40776     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40777     +else
40778     +if DISPLAY_VAR='CLAGE' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='CLAGE' and _GROUP_ = 5 then do;
40779     +_LABEL_='230.93<= CLAGE';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='230.93<= CLAGE';
40780     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
40781     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40782     +
40783     +if DISPLAY_VAR='CLNO' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='CLNO' and _GROUP_ = 2 then do;
40784     +_LABEL_='CLNO< 14';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='CLNO< 14';
40785     +UB=14;
MPRINT(EM_GENERATE_LABELVALUES):   UB=14;
40786     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40787     +else
40788     +if DISPLAY_VAR='CLNO' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='CLNO' and _GROUP_ = 3 then do;
40789     +_LABEL_='14<= CLNO< 20';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='14<= CLNO< 20';
40790     +UB=20;
MPRINT(EM_GENERATE_LABELVALUES):   UB=20;
40791     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40792     +else
40793     +if DISPLAY_VAR='CLNO' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='CLNO' and _GROUP_ = 4 then do;
40794     +_LABEL_='20<= CLNO< 26';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='20<= CLNO< 26';
40795     +UB=26;
MPRINT(EM_GENERATE_LABELVALUES):   UB=26;
40796     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40797     +else
40798     +if DISPLAY_VAR='CLNO' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='CLNO' and _GROUP_ = 5 then do;
40799     +_LABEL_='26<= CLNO';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='26<= CLNO';
40800     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
40801     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40802     +
40803     +if DISPLAY_VAR='DEBTINC' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='DEBTINC' and _GROUP_ = 2 then do;
40804     +_LABEL_='DEBTINC< 28.87';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='DEBTINC< 28.87';
40805     +UB=28.87;
MPRINT(EM_GENERATE_LABELVALUES):   UB=28.87;
40806     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40807     +else
40808     +if DISPLAY_VAR='DEBTINC' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DEBTINC' and _GROUP_ = 3 then do;
40809     +_LABEL_='28.87<= DEBTINC< 34.73';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='28.87<= DEBTINC< 34.73';
40810     +UB=34.73;
MPRINT(EM_GENERATE_LABELVALUES):   UB=34.73;
40811     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40812     +else
40813     +if DISPLAY_VAR='DEBTINC' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DEBTINC' and _GROUP_ = 4 then do;
40814     +_LABEL_='34.73<= DEBTINC< 39.2';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='34.73<= DEBTINC< 39.2';
40815     +UB=39.2;
MPRINT(EM_GENERATE_LABELVALUES):   UB=39.2;
40816     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40817     +else
40818     +if DISPLAY_VAR='DEBTINC' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DEBTINC' and _GROUP_ = 5 then do;
40819     +_LABEL_='39.2<= DEBTINC';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='39.2<= DEBTINC';
40820     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
40821     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40822     +
40823     +if DISPLAY_VAR='LOAN' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOAN' and _GROUP_ = 2 then do;
40824     +_LABEL_='LOAN< 11100';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOAN< 11100';
40825     +UB=11100;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11100;
40826     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40827     +else
40828     +if DISPLAY_VAR='LOAN' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOAN' and _GROUP_ = 3 then do;
40829     +_LABEL_='11100<= LOAN< 16200';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11100<= LOAN< 16200';
40830     +UB=16200;
MPRINT(EM_GENERATE_LABELVALUES):   UB=16200;
40831     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40832     +else
40833     +if DISPLAY_VAR='LOAN' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOAN' and _GROUP_ = 4 then do;
40834     +_LABEL_='16200<= LOAN< 23200';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='16200<= LOAN< 23200';
40835     +UB=23200;
MPRINT(EM_GENERATE_LABELVALUES):   UB=23200;
40836     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40837     +else
40838     +if DISPLAY_VAR='LOAN' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOAN' and _GROUP_ = 5 then do;
40839     +_LABEL_='23200<= LOAN';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='23200<= LOAN';
40840     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
40841     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40842     +
40843     +if DISPLAY_VAR='MORTDUE' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='MORTDUE' and _GROUP_ = 2 then do;
40844     +_LABEL_='MORTDUE< 46406';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='MORTDUE< 46406';
40845     +UB=46406;
MPRINT(EM_GENERATE_LABELVALUES):   UB=46406;
40846     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40847     +else
40848     +if DISPLAY_VAR='MORTDUE' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='MORTDUE' and _GROUP_ = 3 then do;
40849     +_LABEL_='46406<= MORTDUE< 64674';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='46406<= MORTDUE< 64674';
40850     +UB=64674;
MPRINT(EM_GENERATE_LABELVALUES):   UB=64674;
40851     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40852     +else
40853     +if DISPLAY_VAR='MORTDUE' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='MORTDUE' and _GROUP_ = 4 then do;
40854     +_LABEL_='64674<= MORTDUE< 93520';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='64674<= MORTDUE< 93520';
40855     +UB=93520;
MPRINT(EM_GENERATE_LABELVALUES):   UB=93520;
40856     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40857     +else
40858     +if DISPLAY_VAR='MORTDUE' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='MORTDUE' and _GROUP_ = 5 then do;
40859     +_LABEL_='93520<= MORTDUE';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='93520<= MORTDUE';
40860     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
40861     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40862     +
40863     +if DISPLAY_VAR='VALUE' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='VALUE' and _GROUP_ = 2 then do;
40864     +_LABEL_='VALUE< 66345';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='VALUE< 66345';
40865     +UB=66345;
MPRINT(EM_GENERATE_LABELVALUES):   UB=66345;
40866     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40867     +else
40868     +if DISPLAY_VAR='VALUE' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='VALUE' and _GROUP_ = 3 then do;
40869     +_LABEL_='66345<= VALUE< 89107';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='66345<= VALUE< 89107';
40870     +UB=89107;
MPRINT(EM_GENERATE_LABELVALUES):   UB=89107;
40871     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40872     +else
40873     +if DISPLAY_VAR='VALUE' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='VALUE' and _GROUP_ = 4 then do;
40874     +_LABEL_='89107<= VALUE< 121714';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='89107<= VALUE< 121714';
40875     +UB=121714;
MPRINT(EM_GENERATE_LABELVALUES):   UB=121714;
40876     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40877     +else
40878     +if DISPLAY_VAR='VALUE' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='VALUE' and _GROUP_ = 5 then do;
40879     +_LABEL_='121714<= VALUE';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='121714<= VALUE';
40880     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
40881     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40882     +
40883     +if DISPLAY_VAR='YOJ' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='YOJ' and _GROUP_ = 2 then do;
40884     +_LABEL_='YOJ< 3';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='YOJ< 3';
40885     +UB=3;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3;
40886     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40887     +else
40888     +if DISPLAY_VAR='YOJ' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='YOJ' and _GROUP_ = 3 then do;
40889     +_LABEL_='3<= YOJ< 7';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3<= YOJ< 7';
40890     +UB=7;
MPRINT(EM_GENERATE_LABELVALUES):   UB=7;
40891     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40892     +else
40893     +if DISPLAY_VAR='YOJ' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='YOJ' and _GROUP_ = 4 then do;
40894     +_LABEL_='7<= YOJ< 13';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='7<= YOJ< 13';
40895     +UB=13;
MPRINT(EM_GENERATE_LABELVALUES):   UB=13;
40896     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40897     +else
40898     +if DISPLAY_VAR='YOJ' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='YOJ' and _GROUP_ = 5 then do;
40899     +_LABEL_='13<= YOJ';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='13<= YOJ';
40900     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
40901     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
40902     +
40903     +if DISPLAY_VAR='DELINQ' and _GROUP_ = 2 then
40904     +_LABEL_='0';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='DELINQ' and _GROUP_ = 2 then _LABEL_='0';
40905     +else
40906     +if DISPLAY_VAR='DELINQ' and _GROUP_ = 3 then
40907     +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DELINQ' and _GROUP_ = 3 then _LABEL_='1';
40908     +else
40909     +if DISPLAY_VAR='DELINQ' and _GROUP_ = 4 then
40910     +_LABEL_='2';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DELINQ' and _GROUP_ = 4 then _LABEL_='2';
40911     +else
40912     +if DISPLAY_VAR='DELINQ' and _GROUP_ = 5 then
40913     +_LABEL_='3';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DELINQ' and _GROUP_ = 5 then _LABEL_='3';
40914     +else
40915     +if DISPLAY_VAR='DELINQ' and _GROUP_ = 6 then
40916     +_LABEL_='4';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DELINQ' and _GROUP_ = 6 then _LABEL_='4';
40917     +else
40918     +if DISPLAY_VAR='DELINQ' and _GROUP_ = 7 then
40919     +_LABEL_='5';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DELINQ' and _GROUP_ = 7 then _LABEL_='5';
40920     +else
40921     +if DISPLAY_VAR='DELINQ' and _GROUP_ = 8 then
40922     +_LABEL_='6';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DELINQ' and _GROUP_ = 8 then _LABEL_='6';
40923     +else
40924     +if DISPLAY_VAR='DELINQ' and _GROUP_ = 9 then
40925     +_LABEL_='10, 11, 12, 13, 15, 7, 8';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DELINQ' and _GROUP_ = 9 then _LABEL_='10, 11, 12, 13, 15, 7, 8';
40926     +
40927     +if DISPLAY_VAR='DEROG' and _GROUP_ = 2 then
40928     +_LABEL_='0';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='DEROG' and _GROUP_ = 2 then _LABEL_='0';
40929     +else
40930     +if DISPLAY_VAR='DEROG' and _GROUP_ = 3 then
40931     +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DEROG' and _GROUP_ = 3 then _LABEL_='1';
40932     +else
40933     +if DISPLAY_VAR='DEROG' and _GROUP_ = 4 then
40934     +_LABEL_='2';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DEROG' and _GROUP_ = 4 then _LABEL_='2';
40935     +else
40936     +if DISPLAY_VAR='DEROG' and _GROUP_ = 5 then
40937     +_LABEL_='3';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DEROG' and _GROUP_ = 5 then _LABEL_='3';
40938     +else
40939     +if DISPLAY_VAR='DEROG' and _GROUP_ = 6 then
40940     +_LABEL_='10, 4, 5, 6, 7, 8, 9';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='DEROG' and _GROUP_ = 6 then _LABEL_='10, 4, 5, 6, 7, 8, 9';
40941     +
40942     +if DISPLAY_VAR='JOB' and _GROUP_ = 2 then
40943     +_LABEL_='OTHER';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='JOB' and _GROUP_ = 2 then _LABEL_='OTHER';
40944     +else
40945     +if DISPLAY_VAR='JOB' and _GROUP_ = 3 then
40946     +_LABEL_='PROFEXE';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='JOB' and _GROUP_ = 3 then _LABEL_='PROFEXE';
40947     +else
40948     +if DISPLAY_VAR='JOB' and _GROUP_ = 4 then
40949     +_LABEL_='OFFICE';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='JOB' and _GROUP_ = 4 then _LABEL_='OFFICE';
40950     +else
40951     +if DISPLAY_VAR='JOB' and _GROUP_ = 5 then
40952     +_LABEL_='MGR';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='JOB' and _GROUP_ = 5 then _LABEL_='MGR';
40953     +else
40954     +if DISPLAY_VAR='JOB' and _GROUP_ = 6 then
40955     +_LABEL_='SELF';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='JOB' and _GROUP_ = 6 then _LABEL_='SELF';
40956     +else
40957     +if DISPLAY_VAR='JOB' and _GROUP_ = 7 then
40958     +_LABEL_='SALES';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='JOB' and _GROUP_ = 7 then _LABEL_='SALES';
40959     +
40960     +if DISPLAY_VAR='NINQ' and _GROUP_ = 2 then
40961     +_LABEL_='0';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='NINQ' and _GROUP_ = 2 then _LABEL_='0';
40962     +else
40963     +if DISPLAY_VAR='NINQ' and _GROUP_ = 3 then
40964     +_LABEL_='1';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='NINQ' and _GROUP_ = 3 then _LABEL_='1';
40965     +else
40966     +if DISPLAY_VAR='NINQ' and _GROUP_ = 4 then
40967     +_LABEL_='2';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='NINQ' and _GROUP_ = 4 then _LABEL_='2';
40968     +else
40969     +if DISPLAY_VAR='NINQ' and _GROUP_ = 5 then
40970     +_LABEL_='3';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='NINQ' and _GROUP_ = 5 then _LABEL_='3';
40971     +else
40972     +if DISPLAY_VAR='NINQ' and _GROUP_ = 6 then
40973     +_LABEL_='4';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='NINQ' and _GROUP_ = 6 then _LABEL_='4';
40974     +else
40975     +if DISPLAY_VAR='NINQ' and _GROUP_ = 7 then
40976     +_LABEL_='5';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='NINQ' and _GROUP_ = 7 then _LABEL_='5';
40977     +else
40978     +if DISPLAY_VAR='NINQ' and _GROUP_ = 8 then
40979     +_LABEL_='6';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='NINQ' and _GROUP_ = 8 then _LABEL_='6';
40980     +else
40981     +if DISPLAY_VAR='NINQ' and _GROUP_ = 9 then
40982     +_LABEL_='7';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='NINQ' and _GROUP_ = 9 then _LABEL_='7';
40983     +else
40984     +if DISPLAY_VAR='NINQ' and _GROUP_ = 10 then
40985     +_LABEL_='10, 11, 12, 13, 14, 8, 9';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='NINQ' and _GROUP_ = 10 then _LABEL_='10, 11, 12, 13, 14, 8, 9';
40986     +
40987     +if DISPLAY_VAR='REASON' and _GROUP_ = 2 then
40988     +_LABEL_='DEBTCON';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='REASON' and _GROUP_ = 2 then _LABEL_='DEBTCON';
40989     +else
40990     +if DISPLAY_VAR='REASON' and _GROUP_ = 3 then
40991     +_LABEL_='HOMEIMP';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='REASON' and _GROUP_ = 3 then _LABEL_='HOMEIMP';
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 70 observations read from the data set EMWS3.BINNING_COARSE.
NOTE: The data set EMWS3.BINNING_COARSE has 70 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   *filename Y;
MPRINT(EM_GENERATE_LABELVALUES):   data EMWS3.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   set EMWS3.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "CLAGE" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "CLNO" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "DEBTINC" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "DELINQ" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "DEROG" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "JOB" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOAN" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "MORTDUE" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "NINQ" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "REASON" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "VALUE" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "YOJ" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   drop ub;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 70 observations read from the data set EMWS3.BINNING_COARSE.
NOTE: The data set EMWS3.BINNING_COARSE has 70 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc datasets library=work nolist;
MPRINT(EM_GENERATE_LABELVALUES):   delete class temp temp_missing;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: Deleting WORK.CLASS (memtype=DATA).
NOTE: Deleting WORK.TEMP (memtype=DATA).
NOTE: Deleting WORK.TEMP_MISSING (memtype=DATA).
MPRINT(EM_GENERATE_LABELVALUES):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename Y;
NOTE: Fileref Y has been deassigned.
MPRINT(EM_MODEL):   data WORK.EM_USER_MODEL;
MPRINT(EM_MODEL):   length DATA $65 TARGET $32 PREDICTED ASSESS DECSCORECODE ADJUSTPOST FITSTATISTICS CLASSIFICATION RESIDUALS $1;
MPRINT(EM_MODEL):   data = "";
MPRINT(EM_MODEL):   target = "BAD";
MPRINT(EM_MODEL):   predicted = "Y";
MPRINT(EM_MODEL):   assess = "N";
MPRINT(EM_MODEL):   decscorecode = "N";
MPRINT(EM_MODEL):   fitstatistics = "N";
MPRINT(EM_MODEL):   classification = "N";
MPRINT(EM_MODEL):   residuals = "N";
MPRINT(EM_MODEL):   adjustpost = "D";
MPRINT(EM_MODEL):   run;

NOTE: The data set WORK.EM_USER_MODEL has 1 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   retain id 0;
MPRINT(EM_REPORT):   id + 1;
MPRINT(EM_REPORT):   length VIEW 8 NAME $32 VALUE $400;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "COARSE";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "DATA";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "EVENTRATESTAT";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "MODEL";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.62019091174946;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   run;

NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: BINNING;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
40992      *------------------------------------------------------------*;
40993      * End TRAIN: BINNING;
40994      *------------------------------------------------------------*;
40995      

40996      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
40997      * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
40998      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
40999      ;
MPRINT(EM_DIAGRAM):   ;
41000      ;
MPRINT(EM_DIAGRAM):   ;
41001      ;
MPRINT(EM_DIAGRAM):   ;
41002      ;
MPRINT(EM_DIAGRAM):   ;
41003      quit;
MPRINT(EM_DIAGRAM):   quit;
41004      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
41005      * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
41006      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
41007      /*; *"; *'; */
41008      ;
MPRINT(EM_DIAGRAM):   ;
41009      run;
MPRINT(EM_DIAGRAM):   run;
41010      quit;
MPRINT(EM_DIAGRAM):   quit;
41011      /* Reset EM Options */
41012      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
41013      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
41014      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
41015      proc sort data=WORK.EM_USER_REPORT;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_USER_REPORT;
41016      by ID VIEW;
MPRINT(EM_DIAGRAM):   by ID VIEW;
41017      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
